<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo搭建博客+部署Github</title>
    <url>/2021/02/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E9%83%A8%E7%BD%B2Github/</url>
    <content><![CDATA[<h1 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>去 <a href="https://git-scm.com/">Git官网</a> 下载 64-bit Git for Windows Setup</p>
<p>检验是否安装成功：回到电脑桌面，鼠标右击如果看到Git GUI Here和Git Bash Here则安装成功</p>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><strong>Git安装之后需要进行一些基本信息设置</strong>     <strong>打开Git Bash</strong> </p>
<ul>
<li>设置用户名：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  config --global  user.name  &#39;github的用户名&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置用户邮箱：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  config --global  user.email  &#39;注册时候的邮箱&#39;</span><br></pre></td></tr></table></figure>
<p>注意：该配置会在github主页上显示谁提交了该文件</p>
<ul>
<li>配置ok之后，我们用如下命令来看看是否配置成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>注意：git  config –global 参数，有了这个参数表示这台机器上所有的git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和邮箱</p>
<p><strong>配置SSH key</strong></p>
<p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。如果使用SSH，就可以记住用户名，并创建属于自己的密码来保证安全操作，还有神奇的一招可以“不用输入密码”</p>
<ol>
<li>检查本机已存在的ssh密钥</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建一对新的SSH密钥(keys)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>
<p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa</p>
<p>接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码)</p>
<p>最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key:将刚复制的内容粘贴到key那里，title随便填，保存</p>
<ol start="3">
<li>测试是否成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，如果看到下面信息，就说明成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>去 <a href="https://nodejs.org/en/">Node.js官网</a> 下载 Windows (x64) 长期支持版 Long Term Support (LTS) schedule</p>
<p>安装完成后打开 Git Bash 查看版本号验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">v14.15.5</span><br></pre></td></tr></table></figure>
<p>Node.js 中自带了 npm 包管理工具，在 Git Bash 中查看 npm 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line">6.14.11</span><br></pre></td></tr></table></figure>
<p>由于 npm 代码仓库的服务器在国外，为了下载速度快使用淘宝的 npm 代码仓库，通过 npm 安装 cnpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>查看版本验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>打开 Git Bash，使用 cnpm 安装 Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>Hexo 安装完成后,在本地磁盘新建Blog目录，如：D:\Programming\Blog ，这个目录存放的东西就是以后操作博客的东西</p>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>进入Blog目录，右键 Git Bash Here ,初始化命令只用一次，后面不会再用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure>
<p>此时，会在 Blogs 目录下生成相应的项目文件</p>
<p>需要记住的几个常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  #清理缓存文件</span><br><span class="line">hexo  g     #生成博客静态文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d     #上传到服务器</span><br></pre></td></tr></table></figure>
<h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo  s</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:4000/">http://localhost:4000</a> </p>
<p>这样就可以在本地4000端口查看自己的博客了，初始自带默认主体。</p>
<p>至此完成了 Hexo 搭建博客，接下来部署到 Github 上，就可以通过外网访问自己的博客了。</p>
<h1 id="部署Github"><a href="#部署Github" class="headerlink" title="部署Github"></a>部署Github</h1><p>首先登录 GitHub，创建新 public 仓库，仓库名称一定要是自己昵称+github.io</p>
<p>接下来在Blog目录下安装一个hexo部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>找到Blog文件中的  _config.yml  文件,使用编译器打开,拉到最下面找到并修改deploy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>更改以后进行保存</p>
<p>将本地文件部署到github新建的仓库中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo  d</span><br></pre></td></tr></table></figure>
<p>通过访问  自己的仓库名  就可以访问部署到github上的blog了</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Learn-Markdown</title>
    <url>/2021/02/11/Learn-Markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+空格+一级标题</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##+空格+二级标题</span><br></pre></td></tr></table></figure>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>Hello,World</em>       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体：两边加*</span><br></pre></td></tr></table></figure>
<p><strong>Hello,World</strong>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">粗体：两边加**</span><br></pre></td></tr></table></figure>
<p><strong><em>Hello,World</em></strong>      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体加粗：两边加***</span><br></pre></td></tr></table></figure>
<p><del>Hello,World</del>       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">废弃：两边加~~</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>test    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用 </span><br></pre></td></tr></table></figure>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---或***</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[名称](地址)</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![名称](本地地址或虚拟地址)</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.+空格</span><br></pre></td></tr></table></figure>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-+空格</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th>名字</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>java</td>
<td>26</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 名字 | 年龄 |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">| java | 26 |</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···+java : tab上面的 ·</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Markdowm</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day1（基础知识、数据类型）</title>
    <url>/2021/02/15/StudyNotes_day1/</url>
    <content><![CDATA[<h1 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h1><p>位（bit）：一个数字0或1，代表一位，数据存储的最小单位</p>
<p>字节（Byte）：每逢8位是一个字节</p>
<p>1 Byte = 8 bit</p>
<p>1 KB = 1024 Byte</p>
<p>1 MB = 1024 KB</p>
<h1 id="字节与字符的区别"><a href="#字节与字符的区别" class="headerlink" title="字节与字符的区别"></a>字节与字符的区别</h1><p>字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。</p>
<p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
<p>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</p>
<p>数字和字符的对照关系表（编码表）</p>
<h1 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h1><p>关键字：是电脑语言里事先定义的，有特别意义的标识符</p>
<p>关键字特征：完全小写的字母，在编辑器中有颜色</p>
<p>String不是关键字，是数据类型中的引用类型，是java中的一个类</p>
<p>标识符：自定义内容，比如类的名字、方法的名字和变量的名字等</p>
<p>标识符的命名规则：（硬性要求）</p>
<ul>
<li>标识符可以包含26个英文字母（区分大小写）、0-9数字、$(美元符号)和 _（下划线）</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字</li>
</ul>
<p>标识符的命名规范：（软性建议）</p>
<ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式），HelloWorld</li>
<li>变量名规范：首字母小写，后面每个单词首字母小写（小驼峰式），helloWorld</li>
<li>方法名规范：同变量名</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java的数据类型分为两大类</p>
<ul>
<li>基本类型：整数、浮点数、字符、布尔</li>
<li>引用类型：类、接口、数组、字符串(String)、Lambda</li>
</ul>
<p>数据类型转换</p>
<p>​    低——————————————————————&gt;高</p>
<p>​    byte,short,char——&gt;int——&gt;long——&gt;float——&gt;double</p>
<p>自动转换：低到高</p>
<p>强制转换：高到低    （类型）变量名</p>
<p>注意点：</p>
<ul>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换成不相干的类型</li>
<li>在把高容量转到低容量的时候，强制转换</li>
<li>转换的时候可能存在内存溢出，或者精度问题</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day10（总结、注意事项）</title>
    <url>/2021/09/13/StudyNotes_day10/</url>
    <content><![CDATA[<h2 id="标识符的命名规范"><a href="#标识符的命名规范" class="headerlink" title="标识符的命名规范"></a>标识符的命名规范</h2><ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式），HelloWorld</li>
<li>变量名规范：首字母小写，后面每个单词首字母小写（小驼峰式），helloWorld</li>
<li>方法名规范：同变量名</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li><p>变量创建格式：</p>
<p>数据类型 变量名称 = 数据值；</p>
</li>
<li><p>数组创建格式：</p>
<p>数据类型[] 数组名称 = new 数据类型[数组长度];</p>
<p>数据类型[] 数组名称 = new 数据类型[]{ 元素1, 元素2, …};</p>
<p>数据类型[] 数组名称 = { 元素1, 元素2, …};</p>
</li>
<li><p>对象创建格式：</p>
<p>类名称 对象名称 = new 类名称（）；</p>
</li>
</ul>
<p>new一个对象就是new一个类的构造方法</p>
<p>new     调用的是构造方法</p>
<p>对象名.（点）    调用的是成员方法</p>
<p>非静态方法使用，要先创建此方法所在类的对象，通过对象名称去调用</p>
<p>静态方法直接用类名去调用，不用创建对象</p>
<p>静态方法只能访问静态的成员变量和静态的成员方法</p>
<p>静态访问静态</p>
<p>​    </p>
<p>需要特殊方式获取实现类：</p>
<ul>
<li><p>Calendar为抽象类。调用其中的静态方法，返回子类对象</p>
<p>static Calendar getInstance():使用默认时区和语言环境获得一个日历</p>
</li>
<li><p>Iterator            Collection接口中的    iterator( )    方法获取迭代器实现类对象</p>
</li>
</ul>
<p>​    </p>
<p>面向对象的思想：做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情</p>
<p>​    </p>
<p>学习一个类步骤：先看有没有静态的成员，有就可以直接通过类调用，再看构造方法，就可通过构造方法创建对象，再看普遍的成员方法，通过对象名调用成员方法</p>
<p>集合就是一个容器，存取数据，最重要就是会存和取</p>
<p>​    </p>
<p>标准的类也叫做Java Bean</p>
<p>1、所有属性为private</p>
<p>2、提供默认构造方法</p>
<p>3、提供getter和setter</p>
<p>4、实现serializable接口</p>
<p>几个标准类：</p>
<ul>
<li><p><strong>pojo(plain old java object)</strong>:普通的Java对象,没有业务逻辑</p>
</li>
<li><p><strong>po(persistence object)</strong>:用于持久化时(例如保存到数据库或者缓存);</p>
</li>
<li><p><strong>vo(value object)</strong>:用于前端展示使用(例如放置到JSP中解析或者给前端传递数据)</p>
</li>
<li><p><strong>dto(data transfer object)</strong>:用于接口互相调用返回,数据传输(例如很多接口调用返回值或消息队列内容)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day11（ArrayList集合初步使用）</title>
    <url>/2021/09/14/StudyNotes_day11/</url>
    <content><![CDATA[<h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><h2 id="ArrayList集合概述和基本使用"><a href="#ArrayList集合概述和基本使用" class="headerlink" title="ArrayList集合概述和基本使用"></a>ArrayList集合概述和基本使用</h2><p>数组的长度不可发生改变</p>
<p>但是ArrayList集合的长度是可以随意变化的</p>
<p>对于ArrayList来说，有一个尖括号<E>代表泛型</p>
<p>泛型：也就是装在集合当中的所有元素，全都是统一的类型</p>
<p>注意：泛型只能是引用类型，不能是基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放字符串类型数据</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//存放int类型数据</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容</p>
<p>如果内容是空，得到的是空的中括号：[ ]</p>
<h2 id="ArrayList集合的常用方法和遍历"><a href="#ArrayList集合的常用方法和遍历" class="headerlink" title="ArrayList集合的常用方法和遍历"></a>ArrayList集合的常用方法和遍历</h2><p>ArrayList当中的常用方法有：</p>
<p>​    </p>
<p>public boolean add(E e)向集合当中添加元素，参数的类型和泛型一致，返回值代表添加是否成功</p>
<p>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可以不用</p>
<p>但对于其他集合来说，add添加动作就不一定成功</p>
<p>public E get(int index)从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</p>
<p>public E remove(int index)从集合当中删除元素，参数是索引编号，返回值就是删除掉的元素</p>
<p>public int size()获取集合尺寸长度，返回值是集合中包含的元素个数</p>
<h2 id="ArrayList集合存储基本数据类型"><a href="#ArrayList集合存储基本数据类型" class="headerlink" title="ArrayList集合存储基本数据类型"></a>ArrayList集合存储基本数据类型</h2><p>如果要向集合ArrayList当中存储基本类型的数据，必须使用基本类型对应的“包装类”</p>
<p>​    </p>
<p>基本类型        包装类型（引用类型，包装类都位于java.lang包下）</p>
<p>byte                  Byte</p>
<p>short                Short</p>
<p>int                     Integer    【特殊】</p>
<p>long                  Long</p>
<p>floot                 Floot</p>
<p>double             Double</p>
<p>char                 Character    【特殊】</p>
<p>boolean           Boolean</p>
<p>​    </p>
<p>从JDK1.5+开始，支持自动装箱、自动拆箱</p>
<p>自动装箱：基本类型    ——&gt;    包装类型</p>
<p>自动拆箱：包装类型    ——&gt;    基本类型</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day14（接口）</title>
    <url>/2021/09/25/StudyNotes_day14/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种<strong>公共的规范标准</strong></p>
<p>只要符合规范标准，就可以大家通用</p>
<h2 id="接口的定义基本格式"><a href="#接口的定义基本格式" class="headerlink" title="接口的定义基本格式"></a>接口的定义基本格式</h2><p>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法</p>
<p>​    </p>
<p>如何定义一个接口的格式：</p>
<p>public interface 接口名称 {</p>
<p>​    //接口内容</p>
<p>}</p>
<p>备注：换成了interface之后，源文件是：.java，编译生成的字节码文件仍然是：.class</p>
<p>​    </p>
<p>如果是Java 7，那么接口中可以包含的内容有：</p>
<p>1.常量</p>
<p>2.抽象方法</p>
<p>如果是Java 8，还可以额外包含有：</p>
<p>3.默认方法</p>
<p>4.静态方法</p>
<p>如果是Java 9，还可以额外包含有：</p>
<p>5.私有方法</p>
<h2 id="接口的抽象方法定义"><a href="#接口的抽象方法定义" class="headerlink" title="接口的抽象方法定义"></a>接口的抽象方法定义</h2><p>在任何版本的Java中，接口都能定义抽象方法</p>
<p>格式：</p>
<p>public abstract 返回值类型 方法名称（参数列表）；</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.接口当中的抽象方法，修饰符必须是两个固定的关键字，public abstract</p>
<p>2.这两个关键字修饰符，可以选择性地省略</p>
<h2 id="接口的抽象方法使用"><a href="#接口的抽象方法使用" class="headerlink" title="接口的抽象方法使用"></a>接口的抽象方法使用</h2><p>接口的使用步骤：</p>
<p>1.接口不能直接使用，必须有一个“实现类”来“实现”该接口</p>
<p>格式：</p>
<p>public class 实现类名称 implements 接口名称 {</p>
<p>​    //…</p>
<p>}</p>
<p>2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法</p>
<p>实现：去掉abstract关键字，加上方法大括号</p>
<p>3.创建实现类的对象，进行使用</p>
<p>​    </p>
<p>注意事项：</p>
<p>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类</p>
<h2 id="接口的默认方法定义"><a href="#接口的默认方法定义" class="headerlink" title="接口的默认方法定义"></a>接口的默认方法定义</h2><p>从Java 8开始，接口里允许定义默认方法</p>
<p>格式：</p>
<p>public default 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>备注：接口当中的默认方法，可以解决接口升级问题</p>
<h2 id="接口的默认方法使用"><a href="#接口的默认方法使用" class="headerlink" title="接口的默认方法使用"></a>接口的默认方法使用</h2><p>1.接口的默认方法，可以通过接口实现类对象，直接调用</p>
<p>2.接口的默认方法，也可以被接口实现类进行覆盖重写</p>
<h2 id="接口的静态方法定义"><a href="#接口的静态方法定义" class="headerlink" title="接口的静态方法定义"></a>接口的静态方法定义</h2><p>从Java 8开始，接口当中允许定义静态方法</p>
<p>格式：</p>
<p>public static 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>提示：就是将abstract或者defualt换成static即可，带上方法体</p>
<h2 id="接口的静态方法使用"><a href="#接口的静态方法使用" class="headerlink" title="接口的静态方法使用"></a>接口的静态方法使用</h2><p>注意事项：不能通过接口实现类的对象来调用接口当中的静态方法</p>
<p>正确用法：通过接口名称，直接调用其中的静态方法</p>
<p>格式：</p>
<p>接口名称 . 静态方法（参数列表）；</p>
<h2 id="接口的私有方法定义"><a href="#接口的私有方法定义" class="headerlink" title="接口的私有方法定义"></a>接口的私有方法定义</h2><p>问题描述：</p>
<p>我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题</p>
<p>但是这个共有方法不应该让实现类使用，应该是私有化的</p>
<p>​    </p>
<p>解决方案：</p>
<p>从Java 9开始，接口当中允许定义私有方法</p>
<p>1.普通私有方法，解决多个默认方法之间重复代码问题</p>
<p>格式：</p>
<p>private 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>2.静态私有方法，解决多个静态方法之间重复代码问题</p>
<p>格式：</p>
<p>private static 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<h2 id="接口的私有方法使用"><a href="#接口的私有方法使用" class="headerlink" title="接口的私有方法使用"></a>接口的私有方法使用</h2><p>​    </p>
<h2 id="接口的常量定义和使用"><a href="#接口的常量定义和使用" class="headerlink" title="接口的常量定义和使用"></a>接口的常量定义和使用</h2><p>接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰</p>
<p>从效果上看，这其实就是接口的【常量】</p>
<p>格式：</p>
<p>public static final 数据类型 常量名称 = 数据值；</p>
<p>备注：</p>
<p>一旦使用final关键字进行修饰，说明不可改变</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.接口当中的常量，可以省略public static final，注意：不写也是这样</p>
<p>2.接口当中的常量，必须进行赋值，不能不赋值</p>
<p>3.接口当中常量的名称，使用完全大写的字母，用下划线进行分隔</p>
<h2 id="接口的内容小结"><a href="#接口的内容小结" class="headerlink" title="接口的内容小结"></a>接口的内容小结</h2><p>在Java 9+版本中，接口的内容可以有：</p>
<p>​    </p>
<p>[ ]的关键字可以省略不写</p>
<p>1.成员变量其实是常量，格式：</p>
<p>[public] [static] [final] 数据类型 常量名称 = 数据值；</p>
<p>注意：</p>
<p>​        常量必须进行赋值，而且一旦赋值不能改变</p>
<p>​        常量名称完全大写，用下划线进行分隔</p>
<p>​    </p>
<p>2.接口中最重要的就是抽象方法，格式：</p>
<p>[public] [abstract] 返回值类型 方法名称（参数列表）;</p>
<p>注意：实现类必须覆盖重写接口中所有的抽象方法，除非实现类是抽象类</p>
<p>​    </p>
<p>3.从Java 8开始，接口里允许定义静态方法，格式：</p>
<p>[public] default 返回值类型 方法名称（参数列表）{ 方法体 } </p>
<p>注意：默认方法也可被覆盖重写</p>
<p>​    </p>
<p>4.从Java 8开始，接口里允许定义静态方法，格式：</p>
<p>[public] static 返回值类型 方法名称（参数列表）{ 方法体 } </p>
<p>注意：应该通过接口名称进行调用，不能通过实行类对象调用接口静态方法</p>
<p>​    </p>
<p>5.从Java 9开始，接口里允许定义私有方法，格式：</p>
<p>普通私有方法：private 返回值类型 方法名称（参数列表）{ 方法体 }</p>
<p>静态私有方法：private static 返回值类型 方法名称（参数列表）{ 方法体 }</p>
<p>注意：private的方法只有接口自己才能调用，不能被实现类或别人使用</p>
<h2 id="继承父类并实现多个接口"><a href="#继承父类并实现多个接口" class="headerlink" title="继承父类并实现多个接口"></a>继承父类并实现多个接口</h2><p>使用接口的时候，需要注意：</p>
<p>1.接口是没有静态代码块或构造方法的</p>
<p>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</p>
<p>格式：</p>
<p>public class MyInterfaceImpl extends Object implements MyInterfaceA, MyInterfaceB{</p>
<p>​    //覆盖重写所有的抽象方法</p>
<p>}</p>
<p>3.如果实现类实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p>
<p>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类</p>
<p>5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p>
<p>6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法</p>
<p>继承优先于接口实现</p>
<h2 id="接口之间的多继承"><a href="#接口之间的多继承" class="headerlink" title="接口之间的多继承"></a>接口之间的多继承</h2><p>1.类与类之间是单继承的，直接父类只有一个</p>
<p>2.类与接口之间是多实现的，一个类可以实现多个接口</p>
<p>3.接口与接口之间是多继承的</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.多个父接口当中的抽象方法如果重复，没关系</p>
<p>2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】</p>
<p>​    </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day13（继承、抽象类）</title>
    <url>/2021/09/23/StudyNotes_day13/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的概述"><a href="#继承的概述" class="headerlink" title="继承的概述"></a>继承的概述</h2><p>面向对象的三大特征：封装性、继承性、多态性</p>
<p>继承是多态的前提，如果没有继承，就没有多态</p>
<p>继承主要解决的问题就是：共性抽取</p>
<p>父类，也可以叫基类、超类</p>
<p>子类，也可以叫派生类</p>
<p>​    </p>
<p>继承关系当中的特点：</p>
<p>1.子类可以拥有父类的“内容”</p>
<p>2.子类还可以拥有自己专有的内容</p>
<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><p>在继承的关系中，“子类就是一个父类”，也就是说，子类可以被当做父类看待</p>
<p>例如：父类是员工Employee，子类是讲师Teacher，那么“讲师就是一个员工”，关系：is - a</p>
<p>​    </p>
<p>定义父类的格式：（一个普通的类定义）</p>
<p>public class 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<p>定义子类的格式</p>
<p>public class 子类名称 extends 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<h2 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h2><p>在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</p>
<p>​    </p>
<p>直接通过子类对象访问成员变量：</p>
<p>​        等号左边是谁，就优先用谁，没有则向上找</p>
<p>间接通过成员方法访问成员变量：</p>
<p>​        该方法属于谁，就优先用谁，没有则向上找</p>
<h2 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h2><p>局部变量：                直接写</p>
<p>本来的成员变量：    this.成员变量</p>
<p>父类的成员变量：    super.成员变量</p>
<h2 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h2><p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</p>
<p>​        创建的对象是谁，就优先用谁，如果没有则向上找</p>
<p>注意思想：</p>
<p>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类</p>
<h2 id="继承中方法的覆盖重写"><a href="#继承中方法的覆盖重写" class="headerlink" title="继承中方法的覆盖重写"></a>继承中方法的覆盖重写</h2><p>重写（Override）</p>
<p>概念：在继承关系当中，方法的名称一样，参数列表也一样</p>
<p>​    </p>
<p>重写（Override）:方法的名称一样，参数列表【也一样】，覆盖、覆写</p>
<p>重载（Overload）:方法的名称一样，参数列表【不一样】</p>
<p>​     </p>
<p>方法的覆盖重写的特点：创建的是子类对象，则优先用子类方法</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.必须保证父子类之间方法的名称相同，参数列表也相同</p>
<p>@Override，写在方法上面，用来检测是不是有效的覆盖重写</p>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
<p>java.lang.Objet类是所有类的公共最高父类，java.lang.String就是Object的子类</p>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>public &gt; protected &gt; (default) &gt;private</p>
<p>备注：（default）不是关键字，而是什么都不写，留空</p>
<p>​    </p>
<p>应用场景：</p>
<p>设计原则：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新类继承，来重复利用其中的共性内容，并添加改动新内容</p>
<h2 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h2><p>1.子类构造方法当中有一个默认隐含的“super( )”调用，所以一定是先调用的父类构造，后执行子类的构造</p>
<p>2.子类构造可以通过super关键字来调用父类重载构造</p>
<p>3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p>
<p>只要子类的构造方法才能调用父类的构造方法</p>
<p>总结：</p>
<p>子类必须调用父类构造方法，不写则赠送super( )；写了则用写的指定的super调用，super只能有一个，还必须是第一个</p>
<h2 id="super关键字的三种用法"><a href="#super关键字的三种用法" class="headerlink" title="super关键字的三种用法"></a>super关键字的三种用法</h2><p>1.在子类的成员方法中，访问父类的成员变量    super.</p>
<p>2.在子类的成员方法中，访问父类的成员方法    super.</p>
<p>3.在子类的构造方法中，访问父类的构造方法    super()</p>
<h2 id="this关键字的三种用法"><a href="#this关键字的三种用法" class="headerlink" title="this关键字的三种用法"></a>this关键字的三种用法</h2><p>1.在本来的成员方法中，访问本类的成员变量                this.</p>
<p>2.在本来的成员方法中，访问本类的另一个成员方法    this.</p>
<p>3.在本来的构造方法中，访问本类的另一个构造方法    this()</p>
<p>在第三种用法中注意：</p>
<p>A.this(…)调用也必须是构造方法的第一个语句，唯一一个</p>
<p>B.super和this两种构造调用，不能同时使用</p>
<h2 id="java继承的三个特点"><a href="#java继承的三个特点" class="headerlink" title="java继承的三个特点"></a>java继承的三个特点</h2><p>1.Java语言是单继承的</p>
<p>一个类的直接父类只能有唯一一个</p>
<p>2.Java语言可以多级继承</p>
<p>3.一个子类的直接父类是唯一的，但是一个父类可以有多个子类</p>
<h1 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h1><h2 id="抽象方法和抽象类的格式"><a href="#抽象方法和抽象类的格式" class="headerlink" title="抽象方法和抽象类的格式"></a>抽象方法和抽象类的格式</h2><p>抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束</p>
<p>抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstaract即可</p>
<p>如：</p>
<p>public abstract calss Demo {</p>
<p>​    public abstract void method( );</p>
<p>}</p>
<h2 id="抽象方法和抽象类的使用"><a href="#抽象方法和抽象类的使用" class="headerlink" title="抽象方法和抽象类的使用"></a>抽象方法和抽象类的使用</h2><p>1.不能直接创建new抽象类对象</p>
<p>2.必须用一个子类继承抽象父类</p>
<p>3.子类必须覆盖重写抽象父类中所有的抽象方法</p>
<p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p>
<p>4.创建子类对象进行使用</p>
<h2 id="抽象方法和抽象类的注意事项"><a href="#抽象方法和抽象类的注意事项" class="headerlink" title="抽象方法和抽象类的注意事项"></a>抽象方法和抽象类的注意事项</h2><p>1.抽象类不能创建对象</p>
<p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super(); 需要访问父类构造方法</p>
</blockquote>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必须是抽象类</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的是不想让调用者创建该类对象，通常用于某些特殊的类结构设计</p>
</blockquote>
<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day12（字符串、静态static关键字、工具类Arrays、Math）</title>
    <url>/2021/09/15/StudyNotes_day12/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串概述和特点"><a href="#字符串概述和特点" class="headerlink" title="字符串概述和特点"></a>字符串概述和特点</h2><p>java.lang.String类代表字符串</p>
<p>API当中说：Java程序中的所有字符串字母值（如“abc”）都作为此类的实例实现</p>
<p>其实就是说：程序当中所有的双引号字符串，都是String类的对象（就算没有new,也照样是）</p>
<p>​    </p>
<p>字符串的特点：</p>
<p>1.字符串的内容永不可变【重点】</p>
<p>2.正因为字符串不可改变，所以字符串是可以共享的</p>
<p>3.字符串效果上相当于char[ ]字符数组，但是底层原理是byte[ ]字节数组</p>
<h2 id="字符串的构造方法和直接创建"><a href="#字符串的构造方法和直接创建" class="headerlink" title="字符串的构造方法和直接创建"></a>字符串的构造方法和直接创建</h2><p>创建字符串的常见3+1种方式：</p>
<p>三种构造方法：</p>
<p>public String()：创建一个空白字符串，不含任何内容</p>
<p>public String(char[ ] array)：根据字符数组的内容，来创建对应的字符串</p>
<p>public String(byte[ ] array)：根据字节数组的内容，来创建对应的字符串</p>
<p>一种直接创建：</p>
<p>String str = “Hello”; //右边直接用双引号</p>
<p>注意：直接写上双引号，就是字符串对象</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>1.对于引用类型来说，==进行的是地址值的比较</p>
<p>2.双引号直接写的字符串在常量池当中，new的不在池当中</p>
<h2 id="字符串的比较方法"><a href="#字符串的比较方法" class="headerlink" title="字符串的比较方法"></a>字符串的比较方法</h2><p>==是进行对象的地址值的比较，如果确实需要字符串的内容比较，可以使用两个方法：</p>
<p>public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串且内容相同的才会给true，否则返回false</p>
<p>注意事项：</p>
<p><strong>1.任何对象都能用Object进行接收</strong></p>
<p>2.equals方法具有对称性，也就是a.equals(b)和b.equals(a)等效</p>
<p>3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面</p>
<p>推荐：“abc”.equals(str)    不推荐：str.equals(“abc”)当str=null时出现空指针异常</p>
<p>​    </p>
<p>public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较</p>
<h2 id="字符串的获取相关方法"><a href="#字符串的获取相关方法" class="headerlink" title="字符串的获取相关方法"></a>字符串的获取相关方法</h2><p>public int length()：获取字符串当中含有的字符个数，拿到字符串长度</p>
<p>public String concat(String str)：将当前字符串和参数字符串拼接，返回值新的字符串</p>
<p>public char charAt(int index)：获取指定索引位置的单个字符（索引从0开始）</p>
<p>public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的位置，如果没有返回-1值</p>
<h2 id="字符串的截取方法"><a href="#字符串的截取方法" class="headerlink" title="字符串的截取方法"></a>字符串的截取方法</h2><p>public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串</p>
<p>public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串</p>
<p>备注：[begin, end )，包含左边，不包含右边</p>
<h2 id="字符串的转换相关方法"><a href="#字符串的转换相关方法" class="headerlink" title="字符串的转换相关方法"></a>字符串的转换相关方法</h2><p>public char[ ] toCharArray()：将当前字符串拆分成为字符数组作为返回值</p>
<p>public byte[ ] getBytes()：获得当前字符串底层的字节数组</p>
<p>public String replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串</p>
<h2 id="字符串的分割方法"><a href="#字符串的分割方法" class="headerlink" title="字符串的分割方法"></a>字符串的分割方法</h2><p>public String[ ] split(String regex)：按照参数的规则，将字符串切分成为若干部分</p>
<p>注意事项：</p>
<p>split方法的参数是一个正则表达式</p>
<h2 id="判断字符串是否以某个形式结尾"><a href="#判断字符串是否以某个形式结尾" class="headerlink" title="判断字符串是否以某个形式结尾"></a>判断字符串是否以某个形式结尾</h2><p>boolean endsWith( String suffix )：测试此字符串是否以指定的后缀结束</p>
<h2 id="将String中的所有字符都转为小写，或大写"><a href="#将String中的所有字符都转为小写，或大写" class="headerlink" title="将String中的所有字符都转为小写，或大写"></a>将String中的所有字符都转为小写，或大写</h2><p>String toLowerCase( )：使用默认语言环境的规则将此String中的所有字符串都转换为小写</p>
<p>string toUpperCase( )：使用默认语言环境规则将此String中所有的字符都转换为大写</p>
<h1 id="静态static关键字"><a href="#静态static关键字" class="headerlink" title="静态static关键字"></a>静态static关键字</h1><p>概述：一旦用了static 关键字，那么这样的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份</p>
<p>无论是成员变量，还是成员方法，如果有了static，都推荐使用类名称进行调用</p>
<p>静态变量：类名称. 静态变量</p>
<p>静态方法：类名称. 静态方法（）</p>
<p>注意事项：</p>
<p>1.静态不能直接访问非静态</p>
<p>原因：在内存当中时【先】有的静态内容，【后】有的非静态内容</p>
<p>“先人不知道后人，但是后人知道先人”</p>
<p>2.静态方法当中不能用this</p>
<p>原因：this代表当前对象，通过谁调用的方法，谁就是当前对象</p>
<p>静态代码块：</p>
<p>格式：</p>
<p>public class 类名称{</p>
<p>​    static {</p>
<p>​        //静态代码的内容</p>
<p>​    }</p>
<p>}</p>
<p>特点：当第一次用到本类时，静态代码块执行唯一的一次</p>
<p>静态内容总是优先于非静态，所以静态代码比构造方法先执行</p>
<p>​    </p>
<p>静态代码块的典型用途：</p>
<p>用来一次性地对静态成员变量进行赋值</p>
<h1 id="数组工具类Arrays"><a href="#数组工具类Arrays" class="headerlink" title="数组工具类Arrays"></a>数组工具类Arrays</h1><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作</p>
<p>​    </p>
<p>public static String toString(数组)：将参赛数组变成字符串，按照默认格式：[元素1， 元素2， 元素3 … ]</p>
<p>public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序</p>
<p>备注：</p>
<p>1.如果是数值，sort默认按照数值升序</p>
<p>2.如果是字符串，sort默认按照字母升序</p>
<p>3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持</p>
<h1 id="数学工具类Math"><a href="#数学工具类Math" class="headerlink" title="数学工具类Math"></a>数学工具类Math</h1><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作</p>
<p>public static double abs(double num)：获取绝对值</p>
<p>public static double ceil(double num)：向上取整</p>
<p>public static double floor(double num)：向下取整</p>
<p>public static long round(double num)：四舍五入</p>
<p>Math.PI代表近似的圆周率常量</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day15（多态）</title>
    <url>/2021/09/27/StudyNotes_day15/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态的概述"><a href="#多态的概述" class="headerlink" title="多态的概述"></a>多态的概述</h2><p>面向对象的三大特征：封装性、继承性、多态性</p>
<p>extends继承或者implements实现，是多态性的前提</p>
<p>包括了类与类之间继承，接口与接口之间继承，类与接口之间实现</p>
<p>​    </p>
<p>一个对象拥有多种形态，这就是：对象的多态性</p>
<p>继承说的是类，多态说的是对象</p>
<h2 id="多态的格式与使用"><a href="#多态的格式与使用" class="headerlink" title="多态的格式与使用"></a>多态的格式与使用</h2><p>代码当中体现多态性，其实就是一句话，父类引用指向子类对象</p>
<p>​    </p>
<p>格式：</p>
<p>左侧父类的引用，指向了右侧子类的对象</p>
<p>父类名称 对象名 = new 子类名称（）；</p>
<p>或者：</p>
<p>接口名称 对象名 = new 实现类名称（）；</p>
<h2 id="多态中成员变量的使用特点"><a href="#多态中成员变量的使用特点" class="headerlink" title="多态中成员变量的使用特点"></a>多态中成员变量的使用特点</h2><p>访问成员变量的两种方式：</p>
<p>1.直接：通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有向上找</p>
<p>2.间接：通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有向上找</p>
<h2 id="多态中成员方法的使用特点"><a href="#多态中成员方法的使用特点" class="headerlink" title="多态中成员方法的使用特点"></a>多态中成员方法的使用特点</h2><p>在多态代码当中，成员方法的访问规则是：</p>
<p>​        看new的是谁，就优先用谁，没有则向上找</p>
<p>​    </p>
<p>口诀：编译看左边，运行看有右边</p>
<p>​    </p>
<p>对比：</p>
<p>成员变量：编译看左边，运行还看左边</p>
<p>成员方法：编译看左边，运行看右边</p>
<h2 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h2><p>无论右边new的时候换成哪个子类，等号左边调用的方法都不会变化</p>
<p>只能调用父类共有的方法</p>
<p>如果要用子类特有的方法就需要向下转型</p>
<h2 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h2><p>对象的向上转型，其实就是多态的写法</p>
<p>格式：父类名称 对象名称 = new 子类名称（）；</p>
<p>含义：右侧创建一个子类对象，把它当做父类来看待使用</p>
<p>注意事项：向上转型一定是安全的，从小范围转向大范围</p>
<h2 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h2><p>对象的向下转型，其实是一个【还原】的动作</p>
<p>格式：子类名称 对象名称 = （子类名称）父类对象；</p>
<p>含义：将父类对象，【还原】成为本来的子类对象</p>
<p>Animal animal = new Cat()；//本来是猫，向上转型成为动物</p>
<p>Cat cat = (Cat) animal；//本来是猫，已经当做动物了，还原回来成为本来的猫</p>
<p>注意事项：</p>
<p>a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫</p>
<p>b.如果对象创建的时候本来不是猫，非要向下转型成为猫，就会报错，ClassCastException</p>
<h2 id="用instanceof关键字来进行类型判断"><a href="#用instanceof关键字来进行类型判断" class="headerlink" title="用instanceof关键字来进行类型判断"></a>用instanceof关键字来进行类型判断</h2><p>格式：</p>
<p>对象    instanceof    类名称</p>
<p>这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面的类型的实例</p>
<p>向下转型一定要进行instanceof判断</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day16（权限修饰符、内部类）</title>
    <url>/2021/09/30/StudyNotes_day16/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="final关键字概念与四种用法"><a href="#final关键字概念与四种用法" class="headerlink" title="final关键字概念与四种用法"></a>final关键字概念与四种用法</h2><p>final关键字代表最终，不可改变的</p>
<p>​    </p>
<p>常见四种用法：</p>
<p>1.可以用来修饰一个类</p>
<p>2.可以用来修饰一个成员方法</p>
<p>3.还可以用来修饰一个局部变量</p>
<p>4.还可以用来修饰一个成员变量</p>
<h2 id="final关键字用于修饰类"><a href="#final关键字用于修饰类" class="headerlink" title="final关键字用于修饰类"></a>final关键字用于修饰类</h2><p>final修饰类格式：</p>
<p>public final class 类名称{</p>
<p>​    //…</p>
<p>}</p>
<p>修饰的此类不能有子类，因此其中的方法不能进行覆盖重写</p>
<h2 id="final关键字用于修饰成员方法"><a href="#final关键字用于修饰成员方法" class="headerlink" title="final关键字用于修饰成员方法"></a>final关键字用于修饰成员方法</h2><p>修饰方法的时候，这个方法就是最终方法，不能被覆盖重写</p>
<p>格式：</p>
<p>修饰符 final 返回值类型 方法名称（参数列表）{</p>
<p>​    //方法体</p>
<p>}</p>
<p>注意事项：</p>
<p>对于类、方法来说，abstract关键字和final关键字不能同时使用</p>
<h2 id="final关键字用于修饰局部变量"><a href="#final关键字用于修饰局部变量" class="headerlink" title="final关键字用于修饰局部变量"></a>final关键字用于修饰局部变量</h2><p>一旦使用final用来修饰局部变量，这个变量只能有唯一一次的赋值，这个变量不能进行更改</p>
<p>对于基本类型来说，不可变说的是变量当中的数据不可改变</p>
<p>对于引用类型来说，不可变说的是变量当中的地址不可改变</p>
<h2 id="final关键字用于修饰成员变量"><a href="#final关键字用于修饰成员变量" class="headerlink" title="final关键字用于修饰成员变量"></a>final关键字用于修饰成员变量</h2><p>对于成员变量来说，用final关键字修饰，那么这个变量也照样不可改变</p>
<p>1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值</p>
<p>2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一</p>
<p>3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值</p>
<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><h2 id="四种权限的修饰符"><a href="#四种权限的修饰符" class="headerlink" title="四种权限的修饰符"></a>四种权限的修饰符</h2><p>Java中有四种权限修饰符：</p>
<p>​                        public     &gt;    protected    &gt;    (default)    &gt;    private</p>
<p>同一个类            YES                YES                        YES                YES</p>
<p>同一个包            YES                YES                        YES                NO</p>
<p>不同包子类        YES                YES                        NO                 NO    </p>
<p>不同包非子类    YES                NO                         NO                 NO        </p>
<p>注意事项：(default)并不是关键字”default“,而是根本不写</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类的概念与分类"><a href="#内部类的概念与分类" class="headerlink" title="内部类的概念与分类"></a>内部类的概念与分类</h2><p>类是模拟一个事物的，如果一个事物内部包含另一个事物，那么这就是一个类内部包含另一类</p>
<p>例如：身体和心脏的关系。又如：汽车和发动机的关系</p>
<p>​    </p>
<p>分类：</p>
<p>1.成员内部类</p>
<p>2.局部内部类（包含匿名内部类）</p>
<h2 id="成员内部类的定义"><a href="#成员内部类的定义" class="headerlink" title="成员内部类的定义"></a>成员内部类的定义</h2><p>定义格式：</p>
<p>修饰符 class 外部类名称 {</p>
<p>​    修饰符 class 内部类名称{</p>
<p>​        //…</p>
<p>​    }</p>
<p>​    //…</p>
<p>}</p>
<p>注意：内用外，随意访问；外用内，需要内部类对象</p>
<h2 id="成员内部类的使用"><a href="#成员内部类的使用" class="headerlink" title="成员内部类的使用"></a>成员内部类的使用</h2><p>两种方式：</p>
<p>1.间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法</p>
<p>2.直接方式：公式：</p>
<p>【外部类名称.内部类名称    对象名称    =    new    外部类名称（）.new    内部类名称（）；】</p>
<h2 id="内部类的同名变量访问"><a href="#内部类的同名变量访问" class="headerlink" title="内部类的同名变量访问"></a>内部类的同名变量访问</h2><p>格式：外部类.this.外部类成员变量名</p>
<h2 id="局部内部类的定义"><a href="#局部内部类的定义" class="headerlink" title="局部内部类的定义"></a>局部内部类的定义</h2><p>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类</p>
<p>“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能使用了</p>
<p>​    </p>
<p>定义格式：</p>
<p>修饰符 class 外部类名称 {</p>
<p>​    修饰符 返回值类型 方法名称（参数列表）{ </p>
<p>​        class 局部内部类名称 {</p>
<p>​            //…</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>小节一下类的权限修饰：</p>
<p>public &gt; protected &gt; (default) &gt;private</p>
<p>定义一个类的时候，权限修饰符规则：</p>
<p>1.外部类：public / (default)</p>
<p>2.成员内部类：pulbic / protected / (default) / private</p>
<p>3.局部内部类：什么都不能写</p>
<h2 id="局部内部类的final问题"><a href="#局部内部类的final问题" class="headerlink" title="局部内部类的final问题"></a>局部内部类的final问题</h2><p>局部内部类，如果希望访问所在的方法的局部变量，那么这个局部变量必须是【有效的final的】</p>
<p>备注：从Java 8+开始，只有局部变量事实不变，那么final关键字可以省略</p>
<p>原因：</p>
<p>生命周期问题</p>
<p>1.new出来的对象在堆内存中</p>
<p>2.局部变量是跟着方法走的，在栈内存中</p>
<p>3.方法运行结束之后，立刻出栈，局部变量就会立刻消失</p>
<p>4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次</p>
<p>那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】</p>
<p>​    </p>
<p>定义格式：</p>
<p>接口名称 对象名称 = new 接口名称 {</p>
<p>​    //覆盖重写所有的抽象方法</p>
<p>}</p>
<h2 id="匿名内部类的注意事项"><a href="#匿名内部类的注意事项" class="headerlink" title="匿名内部类的注意事项"></a>匿名内部类的注意事项</h2><p>对格式“new 接口名称（）{ .. }”进行解析：</p>
<p>1.new代表创建对象的动作</p>
<p>2.接口名称就是匿名内部类需要实现哪个接口</p>
<p>3.{ … } 这才是匿名内部类的内容</p>
<p>​    </p>
<p>另外还需要注意：</p>
<p>1.匿名内部类，在【创建对象】的时候，只能使用唯一一次</p>
<p>如果需要多次创建对象，而且类的内容一样的话，那就必须使用单独定义的实现类</p>
<p>2.匿名对象，在【调用方法】的时候，只能调用唯一一次</p>
<p>如果希望同一个对象，调用多次方法，那么必须给对象起个名字</p>
<p>3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】</p>
<p>匿名内部类和匿名对象不是一回事</p>
<h2 id="类作为成员变量类型"><a href="#类作为成员变量类型" class="headerlink" title="类作为成员变量类型"></a>类作为成员变量类型</h2><h2 id="接口作为成员变量类型"><a href="#接口作为成员变量类型" class="headerlink" title="接口作为成员变量类型"></a>接口作为成员变量类型</h2><h2 id="接口作为方法的参数和返回值"><a href="#接口作为方法的参数和返回值" class="headerlink" title="接口作为方法的参数和返回值"></a>接口作为方法的参数和返回值</h2><h1 id="成员内部类代码"><a href="#成员内部类代码" class="headerlink" title="成员内部类代码"></a>成员内部类代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//间接访问成员内部类</span></span><br><span class="line"><span class="comment">//        Outer outer = new Outer();</span></span><br><span class="line"><span class="comment">//        outer.methodOuter();</span></span><br><span class="line">        <span class="comment">//直接访问成员内部类</span></span><br><span class="line">        Outer.Inner obj = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        obj.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="局部内部代码"><a href="#局部内部代码" class="headerlink" title="局部内部代码"></a>局部内部代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.methodOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="匿名内部类代码"><a href="#匿名内部类代码" class="headerlink" title="匿名内部类代码"></a>匿名内部类代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单独使用匿名内部类，再通过对象名去调用匿名内部类中的方法</span></span><br><span class="line"><span class="comment">//        MyInterface obj = new MyInterface() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void method() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;匿名内部类实现了方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        obj.method();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时使用匿名内部类和匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现了接口中的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day17（Object类、Objects工具类、日期时间类、包装类）</title>
    <url>/2021/10/02/StudyNotes_day17/</url>
    <content><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>java.lang.Object</p>
<p>Object类是所有的类的父类，一个类都会直接或者间接的继承自该类</p>
<p>该类中提供了一些非常常用的方法</p>
<h2 id="Object类的toString方法"><a href="#Object类的toString方法" class="headerlink" title="Object类的toString方法"></a>Object类的toString方法</h2><p>toSring方法返回地址值</p>
<p>直接打印对象的名字，其实就是调用对象的toString方法</p>
<p>作用：打印对象的信息</p>
<p>重写前：打印的是包名类名@地址值</p>
<p>重写后：打印的是对象中的属性值</p>
<h2 id="Object类的equals方法"><a href="#Object类的equals方法" class="headerlink" title="Object类的equals方法"></a>Object类的equals方法</h2><p>Object类equals方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数：Object obj ：可以传递任意的对象</p>
<p>方法体：</p>
<p>​        == :比较运算符：返回的就是一个布尔值</p>
<p>​        基本数据类型：比较的是值</p>
<p>​        引用数据类型：比较的两个对象的地址值</p>
<p>作用：比较两个对象的</p>
<p>重写前：比较的是对象的地址值</p>
<p>重写后：比较的是对象中的属性值</p>
<h1 id="Objects工具类"><a href="#Objects工具类" class="headerlink" title="Objects工具类"></a>Objects工具类</h1><p>java.util.Objects</p>
<h2 id="Objects类的equals方法"><a href="#Objects类的equals方法" class="headerlink" title="Objects类的equals方法"></a>Objects类的equals方法</h2><p>可以跟Null值比较，两个对象比较，防止空指针异常</p>
<p>作用：比较两个对象是否相同，但是增加了一些完善的判断</p>
<h1 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h1><h2 id="毫秒值的概念和作用"><a href="#毫秒值的概念和作用" class="headerlink" title="毫秒值的概念和作用"></a>毫秒值的概念和作用</h2><p>毫秒：千分之一秒，1000ms = 1s</p>
<p>毫秒值的作用：可以对时间和日期进行计算</p>
<p>2088-01-01到2099-01-03 中间一共有多少天</p>
<p>可以把日期转换为毫秒进行计算，计算完，再把毫秒转换为日期</p>
<p>​    </p>
<p>把日期转换为毫秒：</p>
<p>​        当前日期：2088-01-01</p>
<p>​        时间原点（0毫秒）：1970年1月1日00：00：00</p>
<p>​        计算当前日期到时间原之间一共经历了多少毫秒</p>
<p>注意：</p>
<p>​        中国属于东八区，会把时间增加8个小时</p>
<p>System.currentTimeMillis();获取当前系统时间到1970年1月1日00：00：00经历了多少毫秒</p>
<h2 id="Date类的构造方法和成员方法"><a href="#Date类的构造方法和成员方法" class="headerlink" title="Date类的构造方法和成员方法"></a>Date类的构造方法和成员方法</h2><p>java.util.Date</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>无参构造：Date( )    获取当前系统的日期和时间</p>
<p>有参构造：Date( Long date )    传递毫秒值，把毫秒转换为Data日期 </p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>Long getTime( ):把日期转换为毫秒（相当于System.currentTimeMillis() ）</p>
<p>返回自时间原点之间经过的毫秒</p>
<h2 id="DateFormat类-amp-SimpleDateFormat类"><a href="#DateFormat类-amp-SimpleDateFormat类" class="headerlink" title="DateFormat类&amp;SimpleDateFormat类"></a>DateFormat类&amp;SimpleDateFormat类</h2><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>父类Format:格式化类</p>
<p>子类SimpleDateFormat</p>
<p>java.text.DateFormat是日期/时间格式化子类的<strong>抽象类</strong>，我们可以通过这个类可以帮我们完成日期和文本之间的转换，也就是可以再Data对象与String对象之间进行来回转换</p>
<p>格式化：按照指定格式，从Date对象转换为String对象（日期 -&gt; 文本）</p>
<p>解析：按照指定格式，从String对象转换为Date对象（文本 -&gt; 日期）</p>
<p>成员方法：</p>
<p>​        String format(Date date)    按照指定的格式，把Date日期，格式化为符合模式的字符串</p>
<p>​        Date parse(String source)    把符合模式的字符串，解析为Date日期</p>
<p>注意：</p>
<p>​    DateFormat类是一个抽象类，无法直接创建对象使用，可以创建子类SimpleDateFormat对象</p>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p>构造方法：</p>
<p>​    SimpleDateFormat( String pattern )    用给定的模式和默认语言环境的日期格式符合构造</p>
<p>​    参数：</p>
<p>​            String pattern:传递指定的模式</p>
<p>​            写对应的模式，会把模式替换为对应的日期和时间</p>
<p>​                “yyyy-MM-dd HH:mm:ss”</p>
<p>​                “yyyy年MM月dd日 HH时mm分ss秒”</p>
<p>使用步骤：</p>
<ul>
<li><p>格式化日期</p>
<ol>
<li>创建Date对象</li>
<li>创建SimpleDateFormat对象，构造方法中传递指定的模式</li>
<li>调用SimpleDateFormat对象中的format方法</li>
</ol>
</li>
<li><p>日期解析</p>
<ol>
<li><p>创建SimpleDateFormat对象，构造方法中传递指定的模式</p>
</li>
<li><p>调用SimpleDateFormat对象中的parse方法</p>
</li>
</ol>
</li>
</ul>
<h2 id="日期时间类代码"><a href="#日期时间类代码" class="headerlink" title="日期时间类代码"></a>日期时间类代码</h2><h3 id="Date类使用代码"><a href="#Date类使用代码" class="headerlink" title="Date类使用代码"></a>Date类使用代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统当前的日期和时间</span></span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(d1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传递毫秒参数计算对应的日期和时间</span></span><br><span class="line">        Date d2 = <span class="keyword">new</span> Date(<span class="number">0l</span>);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传递系统当前时间到时间原点经过的毫秒计算当前的日期和时间</span></span><br><span class="line">        Date d3 = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        System.out.println(d3);</span><br><span class="line"></span><br><span class="line">        Date d4 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//getTime等效于System.currentTimeMillis();获取系统当前时间到时间原点之间的毫秒</span></span><br><span class="line">        <span class="keyword">long</span> time = d4.getTime();</span><br><span class="line">        <span class="keyword">long</span> timeMillis = System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(timeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        String text = sdf.format(date);</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//格式化日期</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        String text = sdf.format(date);</span><br><span class="line">        System.out.println(text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//日期解析</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date parse = simpleDateFormat.parse(<span class="string">&quot;2021-10-04 17:08:00&quot;</span>);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>java.util.Calendar是日历类，在Date后出现，替换了许多Date的方法，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的</p>
<p>Calendar为抽象类。调用其中的静态方法，返回子类对象</p>
<p>static Calendar getInstance():使用默认时区和语言环境获得一个日历</p>
<h3 id="Calendar类的常用成员方法"><a href="#Calendar类的常用成员方法" class="headerlink" title="Calendar类的常用成员方法"></a>Calendar类的常用成员方法</h3><p>public int get( int field )：返回给定日历字段的值</p>
<p>public  void set( int field, int value )：将给定日历字段设置为给定值</p>
<p>public abstract void add( int field, int amount )：根据日历的规则，为给定的日历字段添加或减去指定的时间量</p>
<p>public Date getTime( )：把日历对象转成日期对象</p>
<h3 id="日历Calendar类代码"><a href="#日历Calendar类代码" class="headerlink" title="日历Calendar类代码"></a>日历Calendar类代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCalendar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用getInstance静态方法创建Calendar的子类对象</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取给定日历字段的值，西方月份是0-11月</span></span><br><span class="line">        <span class="keyword">int</span> i = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = c.get(Calendar.MARCH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DATE);</span><br><span class="line">        <span class="keyword">int</span> h = c.get(Calendar.HOUR);</span><br><span class="line">        <span class="keyword">int</span> min = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> s = c.get(Calendar.SECOND);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date getTime()把日历对象转成日期对象</span></span><br><span class="line"><span class="comment">//        Date time = c.getTime();</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System类-amp-StringBuilder类"><a href="#System类-amp-StringBuilder类" class="headerlink" title="System类&amp;StringBuilder类"></a>System类&amp;StringBuilder类</h1><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作</p>
<p>常用方法：</p>
<p>public static long currentTimeMillis( )：获取当前系统毫秒值</p>
<p>public static void arraycopy(Object src , int srcPos , Object dest , int dest Pos , int length )：将源数组的部分内容复制到目标数组中</p>
<p>​        参数：src：源数组</p>
<p>​                    srcPos:源数组起始位置</p>
<p>​                    dest:目标数组</p>
<p>​                    destPos:目标数组起始位置</p>
<p>​                    length:要复制的数组元素数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看程序运行效率</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(dest));</span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>java.lang.StringBuilder类：字符串缓冲区，可以提高字符串的效率</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>public StringBuilder( )：创建一个空的字符串缓冲区对象</p>
<p>public StringBuilder( String str )：根据传入的内容创建一个字符串缓冲区对象</p>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><p>public StringBuilder append( … )：添加任意类型数据的字符串形式，并返回当前对象自身</p>
<p>public String toString( )：将当前StringBuilder对象转换为String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder bu1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder bu2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(bu1);</span><br><span class="line">        System.out.println(bu2);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu3 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        bu3.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        bu3.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        bu3.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(bu3);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu4 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        bu4.append(<span class="number">1</span>).append(<span class="number">3.14</span>).append(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        System.out.println(bu4);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu5 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">        String s = bu5.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="基本类型与字符串类型之间的相互转换"><a href="#基本类型与字符串类型之间的相互转换" class="headerlink" title="基本类型与字符串类型之间的相互转换"></a>基本类型与字符串类型之间的相互转换</h2><p>基本类型数据的值 + “ ” 最简单的方式（工作中常用） </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day18（Collection单列集合、Iterator迭代器接口、增强for循环(foreach)、泛型）</title>
    <url>/2021/10/03/StudyNotes_day18/</url>
    <content><![CDATA[<h1 id="Collection单列集合"><a href="#Collection单列集合" class="headerlink" title="Collection单列集合"></a>Collection单列集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>集合（Collection单列集合和Map双列集合）</p>
<p>集合：java中提供的一种容器，可以用来存储多个数据</p>
<p>数组和集合都是容器，区别有：</p>
<ul>
<li><p>数组长度固定。集合长度可变</p>
</li>
<li><p>数组中存储的是同一类型的元素，可以是基本数据类型或者引用类型。集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用集合进行存储</p>
</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>javaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口实现架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map</p>
<p>集合框架的学习方式：</p>
<p>1.学习顶层：学习顶层接口/抽象类中共性方法，所有的子类都可以使用</p>
<p>2.使用底层：顶层不是接口就是抽象类，无法直接创建对象使用，需要使用底层的子类创建对象使用</p>
<p>​    </p>
<p>Collection:单列集合最顶层的接口，所有单列集合共性的方法，无索引</p>
<p>​    </p>
<p>List集合：有序（可以保证存取顺序），可以存储重复元素，有索引</p>
<p>ArrayList：底层是数组实现的，查询快，增删慢</p>
<p>LinkedList：底层是链表实现的，查询慢，增删快    </p>
<p>​        </p>
<p>Set集合：无序，不可以存储重复的元素，无索引</p>
<p>TreeSet：底层是二叉树实现，一般用于排序</p>
<p>HashSet：底层是哈希表+（红黑树）实现的，无索引，不可存储重复元素，存储无序</p>
<p>LinkedHashSet：底层是哈希表+链表实现的，无索引，不可存储重复元素，存储有序</p>
<h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><ul>
<li>public boolean add( E e )：把给定的对象添加到当前的集合中</li>
<li>public boolean remove( E e )：把给定的对象在当前集合中删除</li>
<li>public boolean contains( E e )：判断当前集合中是否包含给定的对象</li>
<li>public void clear( )：清空集合中所有的元素，清空后集合还在</li>
<li>public boolean  isEmpty( )：判断当前集合是否为空</li>
<li>public int size( )：返回集合中元素的个数</li>
<li>public Object[ ] toArray( )：把集合中的元素，存储到数组中</li>
</ul>
<h1 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h1><p>java.util.Iterator接口：迭代器（对集合进行遍历）</p>
<p>有两个常用方法</p>
<p>​        boolean hasNext( )：判断集合中还有没有下个元素</p>
<p>​        E next( )：返回迭代的下一个元素</p>
<p>创建实现类：</p>
<p>​        Collection接口中的    iterator( )    获取迭代器实现类对象</p>
<p>​        Iterator<E> iterator( ) :泛型<E>和Collection中的元素类型一致</p>
<h1 id="增强for循环-foreach"><a href="#增强for循环-foreach" class="headerlink" title="增强for循环(foreach)"></a>增强for循环(foreach)</h1><p>JDK 1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实就是个Iterator迭代器</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( 元素的数据类型 变量名 ： 需要遍历的集合/数组的名称 )&#123;</span><br><span class="line">    <span class="comment">//循环体语句</span></span><br><span class="line">    System.out.println( 变量名 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Iterator和foreach使用代码"><a href="#Iterator和foreach使用代码" class="headerlink" title="Iterator和foreach使用代码"></a>Iterator和foreach使用代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            String e = iter.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候，确定泛型的数据类型</p>
<h3 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.定义实现类时确定泛型的类型</p>
<p>2.在创建对象时确定泛型类型</p>
<h3 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名（参数列表（使用泛型））&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法时，确定泛型的类型</p>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>不知道用什么类型来接收数据的时候，用泛型通配符&lt;?&gt;</p>
<p>使用方式：</p>
<p>​    不能创建对象使用</p>
<p>​    只能作为方法的参数使用</p>
<p>通配符的高级使用-受限泛型</p>
<p>指定泛型的上限和下限</p>
<p>泛型的上限：</p>
<ul>
<li><p>格式：类型名称&lt;? extends 类&gt;对象名称</p>
</li>
<li><p>意义：只能接受该类型及其子类</p>
</li>
</ul>
<p>泛型的下限：</p>
<ul>
<li>格式：类型名称&lt;? super 类&gt;对象名称</li>
<li>意义：只能接受该类型及其父类</li>
</ul>
<h2 id="泛型代码"><a href="#泛型代码" class="headerlink" title="泛型代码"></a>泛型代码</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E element;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericClass&lt;String&gt; gc1 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc1.setElement(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        String s = gc1.getElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setElement(<span class="number">100</span>);</span><br><span class="line">        Integer i = gc2.getElement();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用成员内部类来方式来测试泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> E element;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DemoGenericClass&lt;String&gt; dgc = <span class="keyword">new</span> DemoGenericClass&lt;&gt;();</span><br><span class="line">        dgc.setElement(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        String s = dgc.getElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DemoGenericClass&lt;Integer&gt; dgc = <span class="keyword">new</span> DemoGenericClass&lt;&gt;();</span><br><span class="line">        dgc.setElement(<span class="number">100</span>);</span><br><span class="line">        Integer i = dgc.getElement();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.method1();</span><br><span class="line">        d.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口，第一种使用方式：定义接口实现类的时候，指定接口的泛型</span></span><br><span class="line"><span class="comment"> * 在创建实现类的时候，就确定了泛型的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口，第二张使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></span><br><span class="line"><span class="comment"> * 相当于定义了一个含有泛型的类，创建对象的时候，确定泛型的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericInterfaceImpl1 gi1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        gi1.print(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; gi2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi2.print(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterface&lt;Double&gt; gi = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi.print(<span class="number">3.14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        gm.method01(<span class="number">100</span>);</span><br><span class="line">        gm.method01(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        gm.method01(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">100</span>);</span><br><span class="line">        GenericMethod.method02(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">3.14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型通配符-1"><a href="#泛型通配符-1" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型通配符测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list02.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printArray(list01);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        printArray(list02);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个方法，能遍历所有类型的ArrayList集合</span></span><br><span class="line"><span class="comment">    这时候不知道ArrayList集合使用什么类型，可以用泛型通配符&lt;?&gt;来接收数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            <span class="comment">//next()方法，取出的元素是Object，可以接收任意的数据类型</span></span><br><span class="line">            Object o = iter.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day2（常量、变量）</title>
    <url>/2021/02/16/StudyNotes_day2/</url>
    <content><![CDATA[<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>​    java程序运行期间固定不变的数据</p>
<p>分类：</p>
<ul>
<li>整数常量        例如：100， 0 ， -100</li>
<li>小数常量        例如：1.1， 0.0 ， -1.1</li>
<li>布尔常量                    true,false</li>
<li>字符常量        例如:   ‘a’,’A’,’9’</li>
<li>字符串常量    例如：”abc”,”a”,”123”</li>
<li>空常量                         null,代表没有任何数据</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>​    程序运行期间，内容可以发生改变的量</p>
<p>创建一个变量的一步到位格式：</p>
<p>数据类型    变量名称    =    数据值</p>
<p>​    </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day20（Map双列集合、Map双列集合)</title>
    <url>/2021/10/06/StudyNotes_day20/</url>
    <content><![CDATA[<h1 id="Map双列集合"><a href="#Map双列集合" class="headerlink" title="Map双列集合"></a>Map双列集合</h1><p>java.util</p>
<p>接口    Map&lt;K,V&gt;</p>
<h2 id="Map集合的特点"><a href="#Map集合的特点" class="headerlink" title="Map集合的特点"></a>Map集合的特点</h2><p>1.Map集合是一个双列集合，一个元素包含两个值（一个key,一个value），即Map存放的是两个对象</p>
<p>2.Map集合中的元素，key和value的数据可以相同，也可以不同</p>
<p>3.Map集合中的元素，key是不允许重复的，value是可以重复的</p>
<p>4.Map集合中的元素，key和value是一一对应</p>
<h2 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h2><p>常用的HashMap集合，LinkedHashMap集合</p>
<p>java.util.HashMap&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</p>
<p>HashMap集合的特点：</p>
<p>1.HashMapj集合底层是哈希表：查询的速度特别快</p>
<p>​                Jdk 1.8之前：数组+单向链表</p>
<p>​                Jdk 1.8之后：数组+单向链表/红黑树（链表长度超过8）</p>
<p>2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p>
<p>java.util.LinkHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合</p>
<p>LinkedHashMap集合的特点：</p>
<p>1.底层是哈希表+链表（保证迭代的顺序）</p>
<p>2.有序集合</p>
<h2 id="Map接口中常用的方法"><a href="#Map接口中常用的方法" class="headerlink" title="Map接口中常用的方法"></a>Map接口中常用的方法</h2><ul>
<li>public V put( K key, V value )：把指定的键与值添加到Map集合中</li>
<li>public V remove( Object key )：把指定的键所对应的键值对元素，在Map集合中删除，返回被删除元素的值</li>
<li>public V get( Object key )：根据指定的键，在Map集合中获取对应的值</li>
<li>boolean containsKey( Object key )：判断集合中是否包含指定的键</li>
<li>public Set<K> keySet( )： 获取Map集合中所有的键，存储到Set集合中</li>
<li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet( )：获取到Map集合中所有的键值对对象的集合（Set集合）</li>
</ul>
<h2 id="Map集合遍历-键找值的方式"><a href="#Map集合遍历-键找值的方式" class="headerlink" title="Map集合遍历_键找值的方式"></a>Map集合遍历_键找值的方式</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map集合的第一种遍历方式：通过键找值的方式</span></span><br><span class="line"><span class="comment"> * 实现步骤：</span></span><br><span class="line"><span class="comment"> *      1.使用Map集合中的keySet(),把Map集合中所有的key取出来，存储到一个Set集合中</span></span><br><span class="line"><span class="comment"> *      2.遍历Set集合，获取Map集合中的每一个key</span></span><br><span class="line"><span class="comment"> *      3.用Map集合中的get(kay)方法找到value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">&quot;John&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            String key = iter.next();</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String key : set)&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><p>java.util.Map.Entry&lt;K,V&gt; 是 Map&lt;K,V&gt;接口中静态的成员内部类</p>
<p>Map集合中存放的是两种对象，一种称为Key（键），一种称为Value（值），他们在Map集合中一一对应，Entry将键值对的对应关系封装成了对象。</p>
<p>键值对（Entry）对象中获取对应键和值的方法：</p>
<ul>
<li>public K getKey( )：获取Entry对象中的键</li>
<li>public V getValue( )：获取Entry对象中的值</li>
</ul>
<h2 id="Map集合遍历-键值对的方式"><a href="#Map集合遍历-键值对的方式" class="headerlink" title="Map集合遍历_键值对的方式"></a>Map集合遍历_键值对的方式</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map集合的第二张遍历方式：通过键值对（Entry）对象</span></span><br><span class="line"><span class="comment"> * 实现步骤：</span></span><br><span class="line"><span class="comment"> *      1.Map集合中的entrySet()方法，把Map集合中所有的Entry对象取出来，放到一个Set集合中</span></span><br><span class="line"><span class="comment"> *      2.遍历Set集合，获取每一个Entry对象</span></span><br><span class="line"><span class="comment"> *      3.使用Entry对象中的getKey()和getValue()获取键与值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iter.next();</span><br><span class="line">            Integer key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">            Integer key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap集合存储自定义类型的键值"><a href="#HashMap集合存储自定义类型的键值" class="headerlink" title="HashMap集合存储自定义类型的键值"></a>HashMap集合存储自定义类型的键值</h2><p>Map集合保证key唯一</p>
<p>Map存放两个对象，也就是可以存放一个或两个自己写的类的对象</p>
<p>自己写的类的对象如果作为key，就必须重写hashCode方法和equals方法，以保证key唯一</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(p1,<span class="number">1</span>);</span><br><span class="line">        map.put(p2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet())&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LinkedHashMap集合"><a href="#LinkedHashMap集合" class="headerlink" title="LinkedHashMap集合"></a>LinkedHashMap集合</h2><p>HashMap的子类LinkedHashMap查询速度快，且有序</p>
<h2 id="Hashtable集合"><a href="#Hashtable集合" class="headerlink" title="Hashtable集合"></a>Hashtable集合</h2><p>java.util.Hashtable是Map接口的另一个实现类</p>
<p>Jdk 1.0就存在，是同步，单线程</p>
<p>键和值不可以为空null</p>
<p>Hashtable和Vector集合都在 Jdk 1.2版本之后被更先进的集合（HashMap，ArrayList）取代了</p>
<p>Hashtable的子类Properties依然活跃在历史舞台</p>
<p>Properties集合是一个唯一和IO流相结合的集合</p>
<h1 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h1><p>Debug调试程序：</p>
<p>可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug</p>
<p>使用方式：</p>
<p>在行号的右边，鼠标左键单击，添加断点（初学者：每个方法的第一行，熟练者：哪有有bug添加哪里）</p>
<p>右键，选择Debug执行程序</p>
<p>程序就会停留在添加的第一个断点处</p>
<p>执行程序：</p>
<p>​        f8：逐行执行程序</p>
<p>​        f7：进入到方法中</p>
<p>​        shift+f8：跳出方法</p>
<p>​        f9：跳到下一个断点，如果没有下一个断点，那么就结束程序</p>
<p>​        ctrl+f2：退出Debug模式，停止程序</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day19（数据结构、List集合、Set集合、可变参数、Collections集合工具类）</title>
    <url>/2021/10/05/StudyNotes_day19/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构-栈"><a href="#数据结构-栈" class="headerlink" title="数据结构_栈"></a>数据结构_栈</h2><p>先进后出</p>
<h2 id="数据结构-队列"><a href="#数据结构-队列" class="headerlink" title="数据结构_队列"></a>数据结构_队列</h2><p>先进先出</p>
<h2 id="数据结构-数组"><a href="#数据结构-数组" class="headerlink" title="数据结构_数组"></a>数据结构_数组</h2><p>查询快：数组的地址是连续的，我们通过数组的首地址，可以找到数组，通过数组的索引可以快速查找到某一个元素</p>
<p>增删慢：数组的长度是固定的，想要增加/删除一个元素，必须创建一个新数组，把源数组的数据复制过来</p>
<h2 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构_链表"></a>数据结构_链表</h2><p>查询慢，增删快</p>
<p>单向链表：链表中只有一条链子，不能保证元素的顺序（存取元素和取出元素的顺序有可能不一致）</p>
<p>双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合</p>
<h2 id="数据结构-红黑树"><a href="#数据结构-红黑树" class="headerlink" title="数据结构_红黑树"></a>数据结构_红黑树</h2><p>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</p>
<h1 id="List集合-介绍-amp-常用方法"><a href="#List集合-介绍-amp-常用方法" class="headerlink" title="List集合_介绍&amp;常用方法"></a>List集合_介绍&amp;常用方法</h1><p>List集合中带有索引的方法（特有）</p>
<ul>
<li><p>public void add( int index, E element )：将指定的元素，添加到该集合中的指定位置上</p>
</li>
<li><p>public E get( int index )：返回集合中指定位置的元素</p>
</li>
<li><p>public E remove( int index )：移除列表中指定位置的元素，返回的是被移除的元素</p>
</li>
<li><p>public E set( int index, E element )：用指定元素替换集合中指定位置的元素，返回值的更新前的元素</p>
</li>
</ul>
<p>注意：</p>
<p>​        操作索引的时候，一定要防止索引越界异常</p>
<p>List集合有3中遍历的方式：</p>
<p>前两种是Collection集合中共有的两种遍历方式：Iterator迭代器遍历和foreach遍历</p>
<p>第三种是通过E get( int index )和普通for循环组合进行遍历集合</p>
<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><p>当需求多为查询时用ArrayList</p>
<p>此实现不是同步的，多线程，速度快</p>
<h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p>需求增删多时用LinkedList</p>
<p>双向链表</p>
<p>多线程</p>
<p>有大量的操作首尾元素的方法</p>
<ul>
<li>public void addFirst( E e )：将指定的元素插入此列表的开头</li>
<li>public void addLast( E e )：元素添加到末尾，相当于add方法</li>
<li>public void push( E e )：将元素推入此列表所表示的堆栈，相当于addFirst方法</li>
<li>public E getFirst( )：返回此列表的第一个元素</li>
<li>public E getLast( )：返回最后一个元素</li>
<li>public E removeFirst( )：移除并返回第一个元素</li>
<li>public E removeLast( )：移除并返回最后一个元素</li>
<li>public E pop( )：从此列表所表示的堆栈处弹出一个元素，相当于removeFirst方法</li>
<li>public boolean isEmpty( )：如果列表不含元素，则返回true</li>
</ul>
<h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><p>Java 1.0版本出的，同步的，单线程，速度慢，1.2版本后被ArrayList集合取代</p>
<p>Collection集合1.2版本才出现的</p>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>与Collection接口中的方法基本一致</p>
<p>和Collection集合一样没有索引，不能用普通for循环遍历</p>
<p>用Iterator迭代器和foreach遍历</p>
<h3 id="Set集合存储元素不重复的原理"><a href="#Set集合存储元素不重复的原理" class="headerlink" title="Set集合存储元素不重复的原理"></a>Set集合存储元素不重复的原理</h3><p>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否重复</p>
<p>两个元素的哈希值相同，equals方法返回true，才认定元素相同</p>
<h2 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h2><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>是一个十进制的整数，由系统随机给出（就是对象的地址值，不过地址是十六进制的，是一个逻辑地址，是模拟出来得到的地址，不是数据实际的物理地址）</p>
<p>在Object类有一个方法，可以获取对象的哈希值</p>
<p>int hashCode( )：返回搞对象的哈希值</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>HashSet集合存储数据的结构（哈希表）</p>
<p>哈希表：</p>
<p>​    Jdk 1.8版本之前=数据+链表</p>
<p>​    Jdk 1.8版本之后=数组+红黑树（提高查询速度）</p>
<h3 id="HashSet集合存储自定义类型的元素"><a href="#HashSet集合存储自定义类型的元素" class="headerlink" title="HashSet集合存储自定义类型的元素"></a>HashSet集合存储自定义类型的元素</h3><p>在自定的类中添加重写的equals和hashCode方法实现存储元素唯一</p>
<h2 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h2><p>集合特点：</p>
<p>底层是一个哈希表（数组+链表）+链表；多了一条链表（记录元素的存储顺序，保证元素有序）</p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>Jdk 1.5之后出现的新特性</p>
<p>使用前提：</p>
<p>当方法的参数列表数据类型已经确定，但是参数参数个数不确定，可以使用可变参数</p>
<p>格式：</p>
<p>修饰符 返回值类型 方法名（ 数据类型…变量名 ）{ </p>
<p>​    //方法体</p>
<p> }</p>
<p>原理：</p>
<p>可变参数底层是一个数组，根据传递参数个数不同，会创建不同长度的数组</p>
<p>注意事项：</p>
<p>1.一个方法的参数列表，只能有一个可变参数</p>
<p>2.方法的参数有多个的时候，可变参数必须写在参数列表的末尾</p>
<p>可变参数的特殊（终极）写法</p>
<p>修饰符 返回值类型 方法名（ Object…obj ）{</p>
<p>​    //方法体</p>
<p>}</p>
<h1 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h1><p>java.util.Collections是集合工具类，用来对集合进行操作，部分方法：</p>
<ul>
<li>public static <T> boolean addAll( Collection<T> c, T…elements )：往集合中添加一些元素</li>
<li>public static void shuffle( List&lt;?&gt; list )：打乱顺序</li>
<li>public static <T> void sort( List<T> list )：将集合中元素按照默认规则排序（升序）</li>
<li>public static <T> void sort( List<T> list, Comparator&lt;? super T&gt; )：将集合中元素按照指定规则排序</li>
</ul>
<p>注意：</p>
<p>sort( List<T> list )使用前提：</p>
<p>自定义的类需要排序的时候，（被排序的集合里边存储的元素）必须实现Comparable接口，重写接口中的CompareTo定义排序的规则</p>
<p>Comparable接口排序规则：</p>
<p>​    自己（this）-参数：升序</p>
<p>sort( List<T> list, Comparator&lt;? super T&gt; )：</p>
<p>Comparator和Comparable的区别</p>
<p>​    Comparable：自己（this）和别（参数）比较，自己需要实现Comparable接口</p>
<p>​    Comparator：相当于找一个第三方的裁判，比较两个，使用时直接在参数中使用匿名内部类实现接口中的方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day21（异常、自定义异常）</title>
    <url>/2021/10/10/StudyNotes_day21/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><p>在java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象</p>
<h2 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h2><p>异常的根类是 java.lang.Throwable</p>
<p>其下有个子类： java.lang.Error与java.lang.Exception</p>
<p>平常所说的异常指: Exception</p>
<p>Throwable类中定义了一些查看的方法：</p>
<ul>
<li>public String getMessage( )：返回异常简短描述</li>
<li>public String toString( )：返回异常详细消息字符串，直接打印异常变量，就是调用此方法</li>
<li>public void printStackTrace( )：JVM打印异常对象，默认此方法，信息最全面</li>
</ul>
<h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Throwable：可抛出的意思，是所有异常的根类</p>
<p>错误：Error：内存溢出、系统崩溃</p>
<p>异常：Exception：其他的Exception（必须处理）、RuntimeException（一般不处理）</p>
<h1 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h1><p>java异常处理的五个关键字：try、catch、finally、throw、throws</p>
<h2 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h2><p>作用：</p>
<p>​    可以使用throw关键字在指定的方法中抛出指定的异常</p>
<p>使用格式：</p>
<p>​    throw new xxxException（“异常产生的原因”）；</p>
<p>注意：</p>
<p>​    1.throw关键字必须卸写在方法的内部</p>
<p>​    2.throw关键字后边new的对象必须是Exception或Exception的子类对象</p>
<p>​    3.throw关键字抛出指定的异常对象，要处理这个对象</p>
<p>​            throw关键字后边创建的是RuntimeException或其子类对象，可以不处理，默认交给JVM处理（打印异常对象，中断程序）</p>
<p>​            throw关键字后边创建的是编译异常，必须处理，要么throws,要么try…catch</p>
<h2 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h2><p>public static <T> requireNonNull(T obj)：查看指定引用对象是不是null</p>
<p>Objects.requireNonNull( T obj ,  “产生原因”);</p>
<h2 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h2><p>格式：</p>
<p>​    修饰符 返回值类型 方法名（参数列表） throws AAAException,BBBException…{</p>
<p>​    throw new AAAException(“产生原因”);</p>
<p>​    throw new BBBException(“产生原因”);</p>
<p>​    …</p>
<p>}</p>
<p>注意：</p>
<p>1.必须写在方法声明处</p>
<p>2.声明的异常必须是Exception或其子类</p>
<p>3.方法内部抛出了多个了多个异常，那么throws后面也声明多个异常</p>
<p>如果抛出的多个异常有子父类关系，那么直接声明父类异常</p>
<p>4.调用了一个声明抛出异常的方法，就必须处理，那么继续throws，那么try…catch自己处理异常</p>
<h2 id="捕获异常try…catch…finally"><a href="#捕获异常try…catch…finally" class="headerlink" title="捕获异常try…catch…finally"></a>捕获异常try…catch…finally</h2><p>格式：</p>
<p> try{</p>
<p>​            可能产生异常的代码</p>
<p> }catch( 定义一个异常的变量，用来接收try中抛出的异常对象 ) {</p>
<p>​            异常处理的逻辑</p>
<p>​            一般在工作中，会把异常的信息记录到一个日志中</p>
<p>}</p>
<p>…</p>
<p>catch（异常类名 变量名）{</p>
<p>}finally{</p>
<p>​    一般用于资源释放（finally里不要写return）</p>
<p>}</p>
<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="多异常的捕获处理："><a href="#多异常的捕获处理：" class="headerlink" title="多异常的捕获处理："></a>多异常的捕获处理：</h3><p>如果一定要写多个catch语句块，那么顺序应该是子类异常放到前面，父类放再后面</p>
<p>不严谨的就用Exception</p>
<h3 id="子父类的异常："><a href="#子父类的异常：" class="headerlink" title="子父类的异常："></a>子父类的异常：</h3><p>父类抛出什么异常，子类就抛出什么异常</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxException</span> <span class="keyword">extends</span> <span class="title">Expcetion</span>/<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">	<span class="comment">//添加一个无参构造</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">xxxException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">xxxException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h2><p>模拟用户注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; usernames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(usernames,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;输入要注册的用户名：&quot;</span>);</span><br><span class="line">        String username = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name = checkname(usernames, username);</span><br><span class="line">            usernames.add(name);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RegisterException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkname</span><span class="params">(ArrayList&lt;String&gt; usernames ,String name)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String username : usernames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(name))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day22（线程）</title>
    <url>/2021/10/16/StudyNotes_day22/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间段内发生（在多个事件快速来回切换执行）</p>
<p>并行：指两个或多个事件在同一时刻发生（同时发生）</p>
<p>并行的运行速度更快，但并发效率更高</p>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程：是指内存中一个在运行的应用程序。</p>
<p>线程：是进程中的一个执行单元。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<p>一些程序进程运行后，会调用其他进程，这样就组成了一个进程树</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>分时调度：所有线程轮流获得CPU，平均分配每个线程占用CPU的时间</p>
<p>抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的就是抢占式调度</p>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>main线程（主线程）：执行main（主）方法的线程</p>
<p>JVM执行main方法，main方法会进入到栈内存</p>
<p>JVM会找操作系统开辟一条main方法通向cpu的执行路径</p>
<p>cpu就可以通过这条路径来执行main方法</p>
<p>而这个路径就叫main（主）线程</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="创建多线程程序的第一种方式-创建Thread类的子类"><a href="#创建多线程程序的第一种方式-创建Thread类的子类" class="headerlink" title="创建多线程程序的第一种方式_创建Thread类的子类"></a>创建多线程程序的第一种方式_创建Thread类的子类</h2><p>步骤：</p>
<p>1.创建一个Thread类的子类</p>
<p>2.在Thread类的子类中重写Thread类中的run方法，设置线程任务</p>
<p>3.创建Thread类的子类对象</p>
<p>4.调用Thread类中的start()方法，开启新的线程，执行run方法</p>
<p>备注：    </p>
<p>void start( ) 使该线程开始执行；Java虚拟机调用该线程的run方法</p>
<p>结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>java.lang.Thread</p>
<p>extends Object</p>
<p>implements Runnable</p>
<p><strong>构造方法</strong>：</p>
<ul>
<li>public Thread( )：分配一个新的线程对象</li>
<li>public Thread( String name )：分配一个指定名字的新的线程对象</li>
<li>public Thread( Runnable target )：通过传递Runnable接口实现类对象来创建一个新线程</li>
<li>public Thread( Runnable target, String name )：通过传递Runnable接口实现类对象来创建一个指定名字的新线程</li>
</ul>
<p><strong>常用方法</strong>：</p>
<ul>
<li><p>public String getName( )：获取当前线程名称</p>
</li>
<li><p>public void start( )：导致此线程开始执行，Java虚拟机调用此线程的run方法</p>
</li>
<li><p>public void run( )：此线程要执行的任务在此处定义代码</p>
</li>
<li><p>pubic static void sleep( long millis )：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）</p>
</li>
<li><p>public static Thread currentThread( )：返回当前正在执行的线程对象的引用</p>
</li>
</ul>
<h3 id="Thread类的常用方法-获取线程的名称"><a href="#Thread类的常用方法-获取线程的名称" class="headerlink" title="Thread类的常用方法_获取线程的名称"></a>Thread类的常用方法_获取线程的名称</h3><p>使用Thread类中的getName（）方法 </p>
<p>或者 </p>
<p>先同过Thread类中的currentThread（）方法获取当前执行的线程，再使用线程中的getName（）方法</p>
<p>一步到位，链式编程方式：</p>
<p>Thread.currentThread( ).getName( )</p>
<h3 id="Thread类的常用方法-设置线程的名称"><a href="#Thread类的常用方法-设置线程的名称" class="headerlink" title="Thread类的常用方法_设置线程的名称"></a>Thread类的常用方法_设置线程的名称</h3><p>使用Thread类中的setName( 名字 )</p>
<p>void setName( String name )</p>
<p>或</p>
<p>使用Thread类的带参构造public Thread( String name )在创建线程的时候就设置线程名称</p>
<h3 id="Thread类的常用方法-sleep"><a href="#Thread类的常用方法-sleep" class="headerlink" title="Thread类的常用方法_sleep"></a>Thread类的常用方法_sleep</h3><p>Thread.sleep( long Millis );</p>
<h2 id="创建线程的第二种方式-实现Runnable接口"><a href="#创建线程的第二种方式-实现Runnable接口" class="headerlink" title="创建线程的第二种方式_实现Runnable接口"></a>创建线程的第二种方式_实现Runnable接口</h2><p>java.lang.Runnable</p>
<p>步骤：</p>
<p>1.创建一个Runable接口的实现类</p>
<p>2.在实现类中重写run方法，设置线程任务</p>
<p>3.创建一个Runnable接口的实现类对象</p>
<p>4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象</p>
<p>5.调用Thread类中的start方法，开启新的线程执行run方法</p>
<h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>即实现Runnable接口创建多线程的程序的好处：<br>1.避免了单继承的局限性</p>
<p>一个类只能继承一个类，类继承了Thread类就不能继承其他的类</p>
<p><strong>实现Runnable接口，还可以继承其他的类，实现其他的接口</strong></p>
<p>2.增强了程序的扩展性，降低了程序的耦合性（解耦）</p>
<p>实现Runnable接口的方式，把设置线程任务和开启线程进行了分离（解耦）</p>
<p>实现类中，重写了run方法：设置线程任务</p>
<p>创建Thread类对象，传递Runnable接口实现类对象，调用start方法：开启线程</p>
<p><strong>传递不同的实现类，实现不同任务</strong></p>
<h2 id="匿名内部类方式实现线程的创建"><a href="#匿名内部类方式实现线程的创建" class="headerlink" title="匿名内部类方式实现线程的创建"></a>匿名内部类方式实现线程的创建</h2><p>格式：</p>
<p>new 父类/接口（）{</p>
<p>​    重写父类/接口中的方法</p>
<p>}；</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程访问共享的资源可能会出现线程安全问题</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多</p>
<p>主要三种方式完成同步操作：</p>
<p>1.同步代码块</p>
<p>2.同步方法</p>
<p>3.锁机制</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>synchronized（ 同步锁 ）{</p>
<p>​    可能会出现线程安全问题的代码（访问了共享数据的代码）</p>
<p>}</p>
<p>同步锁（监视器对象）：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁</p>
<p>1.锁对象，可以是任意类型，锁对象要创建在run方法外面使得锁唯一</p>
<p>2.多个线程对象，需要使用同一把锁</p>
<blockquote>
<p>注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外面等着（BLOCKED）</p>
</blockquote>
<p>锁对象作用：</p>
<p>把同步代码锁住，只让一个线程在同步代码块中执行</p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>使用synchronized关键字修饰的方法，就叫做同步方法</p>
<p>保证A线程执行该方法的时候，其他线程只能在方法外面等着</p>
<p>格式：</p>
<p>public synchroized 返回值类型 方法名称（参数列表）{</p>
<p>​    可能会出现线程安全问题的代码（访问了共享数据的代码）</p>
<p>}</p>
<blockquote>
<p>同步锁是谁？</p>
<p>​    对于非static方法，同步锁就是this，即实现类对象，new RunnableImpl（）</p>
<p>​    对于static方法，是使用的当前方法所在类的字节码对象（类名.class）（class文件对象——&gt;反射）</p>
</blockquote>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>java.util.concurrent.locks.Lock接口</p>
<p>Lock接口中的方法：</p>
<p>​    void lock（）：获取锁</p>
<p>​    void unlock（）：释放锁</p>
<p>java.util.concurrent.locks.ReentrantLock    implements     Lock</p>
<p>使用步骤：</p>
<p>​    1.在成员位置创建一个ReentrantLack对象</p>
<p>​    2.可能会出现线程安全问题的代码前调用Lock接口中的方法lock（）获取锁</p>
<p>​    3.可能会出现线程安全问题的代码后调用Lock接口中的方法unlock（）释放锁</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><ul>
<li>NEW：新建状态</li>
<li>RUNNABLE：运行状态</li>
<li>TERMINATED：死亡状态</li>
<li>BLOCKED：阻塞状态</li>
<li>TIMED_WAITING：休眠（睡眠）状态，计时等待</li>
<li>WAITING：无限（永久）等待</li>
</ul>
<h2 id="Timed-Waiting（-计时等待-）"><a href="#Timed-Waiting（-计时等待-）" class="headerlink" title="Timed Waiting（ 计时等待 ）"></a>Timed Waiting（ 计时等待 ）</h2><p>调用sleep带参（时间）成为计时等待状态，</p>
<p>参数时间到达且获取到了锁将又成为运行状态</p>
<h2 id="BLOCKED（-锁阻塞-）"><a href="#BLOCKED（-锁阻塞-）" class="headerlink" title="BLOCKED（ 锁阻塞 ）"></a>BLOCKED（ 锁阻塞 ）</h2><p>没有争取到锁对象成为阻塞状态，</p>
<p>获取到了锁对象又成为可运行状态</p>
<h2 id="Waiting（-无限等待-）"><a href="#Waiting（-无限等待-）" class="headerlink" title="Waiting（ 无限等待 ）"></a>Waiting（ 无限等待 ）</h2><p>调用Object类中的wait方法进入无限等待状态，</p>
<p>直到调用了Object类中的notify方法且获取到了锁成为运行状态</p>
<h3 id="Object类中的wait方法和notify方法"><a href="#Object类中的wait方法和notify方法" class="headerlink" title="Object类中的wait方法和notify方法"></a>Object类中的wait方法和notify方法</h3><ul>
<li><p>wait（）：进入无限等待状态</p>
</li>
<li><p>wait（时间毫秒值）：带参的wait方法等效于Thread类中的sleep方法，到时间后自己醒来</p>
</li>
<li><p>notify：唤醒一个无限等待的线程（等待时间最久的优先唤醒）</p>
</li>
<li><p>notifyAll：唤醒所有的无限等待线程</p>
</li>
</ul>
<p><strong>wait方法和notify方法必须由同一个锁对象调用，且必须要写在同步代码块或同步方法中</strong></p>
<h2 id="线程间通信（等待唤醒机制）"><a href="#线程间通信（等待唤醒机制）" class="headerlink" title="线程间通信（等待唤醒机制）"></a>线程间通信（等待唤醒机制）</h2><p><strong>一、为什么要线程通信？</strong></p>
<p>1.多个线程并发执行时, 在默认情况下CPU是<strong>随机切换线程</strong>的，当我们需要多个线程来<strong>共同完成</strong>一件任务，</p>
<p>　　 并且我们希望他们<strong>有规律</strong>的执行, 那么多线程之间需要一些<strong>协调通信</strong>，以此来帮我们达到<strong>多线程共同操作一份数据</strong>。</p>
<p>2.当然如果我们没有使用线程通信来使用多线程共同操作同一份数据的话，虽然可以实现，</p>
<p>　　但是在很大程度会造成多线程之间对同一共享变量的争夺，那样的话势必为造成很多错误和损失！</p>
<p>3.所以，我们才引出了线程之间的通信，<code>多线程之间的通信能够避免对同一共享变量的争夺。</code></p>
<p><strong>二、什么是线程通信？</strong></p>
<p>　　多个线程在处理<strong>同一个资源</strong>，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的<strong>使用或操作</strong>。</p>
<p>　   就是<strong>多个线程在操作同一份数据时， 避免对同一共享变量的争夺</strong>。</p>
<p>　　于是我们引出了<strong>等待唤醒机制</strong>：（<strong>wait()**、</strong>notify()**）</p>
<p>　　就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify</strong>）</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h2><p>线程池：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源</p>
<p>线程池中有很多操作是与优化资源相关的</p>
<p>​    </p>
<p>线程池是Jdk 1.5之后提供的</p>
<p>​    </p>
<p>java里面线程池的顶级接口是java.util.concurrent.Executor,</p>
<p>但是严格意义上讲Executor并不是一个线程池，</p>
<p>而只是一个执行线程的工具，</p>
<p>真正的线程池接口是java.util.concurrent.ExecutorService</p>
<p>​    </p>
<p>要配置一个线程池是比较复杂的，尤其是对线程池的原理不是很清楚的情况下，很有可能配置的线程不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>java.util.concurrent.Exectors：线程池工厂类，用来生成线程池</p>
<p>Executors类中静态方法：</p>
<ul>
<li>static ExecutorService newFixedThreadPool（ int nThreads ）：创建一个可重复用固定线程数的线程池</li>
</ul>
<p>​    参数：</p>
<p>​            int nThreads：指定创建的线程池中的线程数量</p>
<p>​    返回值：</p>
<p>​            ExecutroService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）</p>
<p>​    </p>
<p>java.util.concurrent.ExecutorService：线程池接口，用来从线程池中获取线程，调用start方法，执行任务</p>
<p>ExecutorService接口中的方法：</p>
<ul>
<li>submit（ Runnable task ）：提交一个Runnable任务用于执行</li>
</ul>
<p>​    </p>
<p>线程池的使用步骤：</p>
<ol>
<li>使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
</ol>
<h1 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h1><h2 id="实现Runnable接口方式创建多线程程序的好处"><a href="#实现Runnable接口方式创建多线程程序的好处" class="headerlink" title="实现Runnable接口方式创建多线程程序的好处"></a>实现Runnable接口方式创建多线程程序的好处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondRunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;名字为：&quot;</span> + Thread.currentThread().getName() </span><br><span class="line">                                   + <span class="string">&quot;的线程算出了100以内的整数和为：&quot;</span> +sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        SecondRunnableImpl secondRunnable = <span class="keyword">new</span> SecondRunnableImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现Runnable接口方式创建线程的好处：传递不同的实现类实现不同的功能</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(secondRunnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类加匿名对象方式创建线程"><a href="#匿名内部类加匿名对象方式创建线程" class="headerlink" title="匿名内部类加匿名对象方式创建线程"></a>匿名内部类加匿名对象方式创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全——同步代码块"><a href="#线程安全——同步代码块" class="headerlink" title="线程安全——同步代码块"></a>线程安全——同步代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例"><a href="#线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例" class="headerlink" title="线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例"></a>线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi baoZi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    baoZi.pi=<span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    baoZi.xian=<span class="string">&quot;牛肉粉丝&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    baoZi.pi=<span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    baoZi.xian=<span class="string">&quot;水果草莓&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺正在生产：&quot;</span> + baoZi.pi+baoZi.xian+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺生产包子需要5秒&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子生产好了!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                baoZi.flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                baoZi.notify();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi baoZi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃：&quot;</span> + baoZi.pi + baoZi.xian +<span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;3秒吃完了&quot;</span>);</span><br><span class="line"></span><br><span class="line">                baoZi.flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                baoZi.notify();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaoZi baoZi = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(baoZi).start();</span><br><span class="line">        <span class="keyword">new</span> ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day23（Lambda表达式、File类、递归、File过滤器）</title>
    <url>/2021/10/19/StudyNotes_day23/</url>
    <content><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式属于函数式编程</p>
<p>Lambda表示式可以用来简化匿名内部类</p>
<h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><p>1.使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong></p>
<p>2.使用Lambda必须具有<strong>上下文推断</strong></p>
<p>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为接口的实例</p>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，成为“函数式接口”</p>
</blockquote>
<h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><p>格式：（ 参数列表 ）-&gt; { 一些重写的代码 }</p>
<p>解释说明格式：</p>
<ul>
<li>（）：接口中抽象方法的参数列表，没有参数就空着，多个参数使用逗号分隔</li>
<li> -&gt; ：传递的意思，把参数传递给方法体{ }</li>
<li> { }：重写接口的抽象方法的方法体</li>
</ul>
<h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><p>可以省略的内容：</p>
<p>1.（ 参数列表 ）：括号中参数列表的数据类型，可以省略不写</p>
<p>2.（ 参数列表 ）：括号中的参数如果只有一个，那么类型和（）都可以省略</p>
<p>3.{ 一些代码 } ：如果{ }中的代码只有一行，无论是否有返回值，可以省略且必须一起省略{ }，return，分号</p>
<h2 id="Lambda练习代码"><a href="#Lambda练习代码" class="headerlink" title="Lambda练习代码"></a>Lambda练习代码</h2><h3 id="Lambda标准格式-1"><a href="#Lambda标准格式-1" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h3><h4 id="Lambda表达式的无参无返回的练习"><a href="#Lambda表达式的无参无返回的练习" class="headerlink" title="Lambda表达式的无参无返回的练习"></a>Lambda表达式的无参无返回的练习</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invokeCooke(<span class="keyword">new</span> Cook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;厨子做饭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        invokeCooke(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;厨子做饭&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCooke</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda表达式有参数有返回值的练习"><a href="#Lambda表达式有参数有返回值的练习" class="headerlink" title="Lambda表达式有参数有返回值的练习"></a>Lambda表达式有参数有返回值的练习</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组存储多个Person对象</span></span><br><span class="line"><span class="comment"> * 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p : array) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person o1, Person o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p : array) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invokeCalc(<span class="number">100</span>, <span class="number">200</span>, <span class="keyword">new</span> Calculator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        invokeCalc(<span class="number">100</span>, <span class="number">200</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = c.calc(a, b);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda省略格式练习"><a href="#Lambda省略格式练习" class="headerlink" title="Lambda省略格式练习"></a>Lambda省略格式练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类的方式，实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;新线程创建了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda标准格式，实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;新线程创建了&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda省略格式，实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;新线程创建了&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>java.io.File 类主要用于文件和目录的创建，查找和删除等操作</p>
<p>重点：</p>
<p>file：文件</p>
<p>directory：文件夹（目录）</p>
<p>path：路径</p>
<p>路径：</p>
<p>绝对路径：是一个完整的路径</p>
<p>相对路径：是一个简化的路径</p>
<p>抽象路径</p>
<p>注意：</p>
<p>1.路径不区分大小写</p>
<p>2.Windows中路径的文件名称分隔符使用反斜杠\，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠</p>
<h2 id="File类的静态成员变量"><a href="#File类的静态成员变量" class="headerlink" title="File类的静态成员变量"></a>File类的静态成员变量</h2><p>路径分隔符    Windows多个路径直接分隔用分号；    Linux用冒号：</p>
<ul>
<li><p>Static String pathSeparator        = “ “ + pathSeparatorChar</p>
</li>
<li><p>Static char pathSeparatorChar</p>
</li>
</ul>
<p>文件名称分隔符    Windows：反斜杠\    Linux：正斜杠/</p>
<ul>
<li><p>Static String separator</p>
</li>
<li><p>Staitc char separatorChar</p>
</li>
</ul>
<p>例如：</p>
<p>C:\develop\a\a.txt        windows</p>
<p>C:/develop/a/a.txt        linux</p>
<p>“C:” + File.separator + “develop” + File.sparator + “a” + File.separator + “a.txt”</p>
<h2 id="File类的构造方法"><a href="#File类的构造方法" class="headerlink" title="File类的构造方法"></a>File类的构造方法</h2><ul>
<li>File（ String pathname ）：通过给定的路径名称字符串转换为抽象路径名来创建一个新File实例，不考虑路径真假情况</li>
<li>File（ String parent, String child ）：根据parent路径名字字符串和child路径名字字符串创建一个新File实例</li>
<li>File（ File parent, String child ）：根据parent抽象路径名和child路径名字符串创建一个新File实例</li>
<li>File（ URI uri ）：通过将给定的fie：URI转换为一个抽象路径名来创建一个新的File实例</li>
</ul>
<h2 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li>public String getAbsolutePath( )：返回此File的绝对路径名字符串。  获取构造方法中的传递的路径，无论路径是绝对还是现对，返回的都是绝对路径</li>
<li>public String getPath( )：将此File转换为路径名字符串。  File类里重写的toString方法就是调用的getPath方法</li>
<li>public String getName( )：返回由此File 表示的文件或目录的名称。  获取的是构造方法传递路径的结尾部分（文件名，文件夹没名）</li>
<li>public long length( )：返回由此File表示的文件的长度。  获取的是构造方法指导的文件大小，文件大小以字节为单位，文件夹没有大小概念，文件夹大小为0，如果构造方法中路径不存在返回0</li>
</ul>
<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li>public boolean exists( )：此File表示的文件或目录是否实际存在</li>
<li>pubic boolean isDirectory( )：此File表示的是否为目录</li>
<li>public boolean isFile( )：此File表示的是否为文件</li>
</ul>
<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li>public boolean mkdir( )：创建单级空文件夹</li>
<li>public boolean mkdirs( )：既可以创建单级空文件夹，也可以创建多级文件夹</li>
<li>public boolean createNewFile( )：创建一个新的空文件</li>
<li>public boolean delete( )：删除有此File表示的文件或目录</li>
</ul>
<h2 id="File类遍历（文件夹）目录功能"><a href="#File类遍历（文件夹）目录功能" class="headerlink" title="File类遍历（文件夹）目录功能"></a>File类遍历（文件夹）目录功能</h2><ul>
<li>public String[ ] list( )：返回一个String数组，表示该File目录中的所有子文件或目录</li>
<li>public File[ ] listFiles( )：返回一个File数组，表示该File目录中的所有的子文件或目录</li>
</ul>
<h2 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h2><h3 id="File类构造方法"><a href="#File类构造方法" class="headerlink" title="File类构造方法"></a>File类构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        show02(<span class="string">&quot;d://&quot;</span> , <span class="string">&quot;Downloads&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File parent = <span class="keyword">new</span> File(<span class="string">&quot;c://&quot;</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(parent, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">(String parent, String child)</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;c://&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;D:\\Downloads&quot;</span>;</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(str);</span><br><span class="line"></span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="File类常用方法创建、删除文件"><a href="#File类常用方法创建、删除文件" class="headerlink" title="File类常用方法创建、删除文件"></a>File类常用方法创建、删除文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在桌面上创建一个a.txt文件，3秒后删除，3秒后再创建，循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02FileMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            file.createNewFile();</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已创建&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                        file.delete();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已删除&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归：指当前方法内调用自己的这种现象</p>
<p>递归的分类：</p>
<p>1.直接递归：方法自身调用自己</p>
<p>2.间接递归：A方法调用B方法，B方法调用A方法</p>
<p>注意事项：</p>
<p>1.递归一定要有条件限定</p>
<p>2.在递归的次数不能过多</p>
<p>3.构造方法禁止递归</p>
<h2 id="练习代码-1"><a href="#练习代码-1" class="headerlink" title="练习代码"></a>练习代码</h2><h3 id="使用递归计算1到n之间的整数和"><a href="#使用递归计算1到n之间的整数和" class="headerlink" title="使用递归计算1到n之间的整数和"></a>使用递归计算1到n之间的整数和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionPlus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">        <span class="keyword">int</span> result = sum(n);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Downloads&quot;</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                File[] files = file.listFiles();</span><br><span class="line">                <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                        getAllFiles(f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归搜索文件"><a href="#递归搜索文件" class="headerlink" title="递归搜索文件"></a>递归搜索文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionSearchFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D://Downloads&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;.exe&quot;</span>;</span><br><span class="line">        getSearchFile(file, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSearchFile</span><span class="params">(File file,String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory())&#123;</span><br><span class="line">                    getSearchFile(f,str);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    String s = f.getName();</span><br><span class="line">                    <span class="keyword">if</span> (s.toLowerCase().endsWith(str))&#123;</span><br><span class="line">                        System.out.println(f);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;路径不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="File过滤器的使用"><a href="#File过滤器的使用" class="headerlink" title="File过滤器的使用"></a>File过滤器的使用</h1><p>文件搜索也可以使用过滤器来实现</p>
<p>在File类中有两个和listFiles（）重载的方法，方法的参数传递的就是过滤器</p>
<ul>
<li>File[ ] listFiles( FileFilter filter )：返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录</li>
</ul>
<p>​        java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器</p>
<p>​        作用：用来过滤文件（File对象）</p>
<p>​        抽象方法：用来过滤文件的方法</p>
<p>​                boolean accept( File pathname ) 测试指定抽象路径名是否应该包含某个路径名列表中</p>
<p>​        参数：File pathname：使用listFiles（）方法遍历目录，得到的每一个文件对象</p>
<ul>
<li><p>File[ ] listFiles( FilenameFilter filter )：返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录</p>
<p>java.io.FilenameFilter接口：实现此接口的类实例可以用于过滤文件名</p>
<p>作用：用于过滤文件名称</p>
<p>抽象方法：用来过滤文件的方法</p>
<p>​        boolean accept( File dir, String name ) 测试指定文件是否应该包含在某一个文件列表中</p>
<p>参数：File dir：构造方法中传递的被遍历的目录</p>
<p>​            String name：使用listFile（）方法遍历目录，获取的每一个文件/文件夹的名称</p>
</li>
</ul>
<p>注意：</p>
<p>​        两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤的规则</p>
<h2 id="FileFilter过滤器练习代码"><a href="#FileFilter过滤器练习代码" class="headerlink" title="FileFilter过滤器练习代码"></a>FileFilter过滤器练习代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterImpl</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果pathname是一个文件夹，返回true，继续遍历这个文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断File对象是否以.exe结尾，是返回true,不是返回false</span></span><br><span class="line">        <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FileFilter过滤器来查询以.exe结尾的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d://Downloads&quot;</span>);</span><br><span class="line">        getSearchFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSearchFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        File[] files = file.listFiles(<span class="keyword">new</span> FileFilterImpl());</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getSearchFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d://Downloads&quot;</span>);</span><br><span class="line">        getSearchFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSearchFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        优化：使用匿名内部类</span></span><br><span class="line"><span class="comment">//        File[] files = file.listFiles(new FileFilter() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean accept(File pathname) &#123;</span></span><br><span class="line"><span class="comment">//                return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(&quot;.exe&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line"><span class="comment">//        File[] files = file.listFiles((File pathname) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(&quot;.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        File[] files = file.listFiles(pathname -&gt; pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.exe&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getSearchFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FilenameFilter过滤器练习代码"><a href="#FilenameFilter过滤器练习代码" class="headerlink" title="FilenameFilter过滤器练习代码"></a>FilenameFilter过滤器练习代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FilenameFilter过滤器来查询以.exe结尾的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d://Downloads&quot;</span>);</span><br><span class="line">        getSearchFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSearchFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        传递过滤器对象，除了传递实现类对象。优化一：使用匿名内部类</span></span><br><span class="line"><span class="comment">//        File[] files = file.listFiles(new FilenameFilter() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean accept(File dir, String name) &#123;</span></span><br><span class="line"><span class="comment">//                return new File(dir, name).isDirectory() || name.toLowerCase().endsWith(&quot;.exe&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化二：使用Lambda表达式优化匿名内部类（接口中只有一个抽象方法）</span></span><br><span class="line"><span class="comment">//        File[] files = file.listFiles((File dir, String name) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            return new File(dir, name).isDirectory() || name.toLowerCase().endsWith(&quot;.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        File[] files = file.listFiles((dir, name) -&gt; <span class="keyword">new</span> File(dir, name).isDirectory() || name.toLowerCase().endsWith(<span class="string">&quot;.exe&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getSearchFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day24（IO流_字节流、字符流）</title>
    <url>/2021/10/22/StudyNotes_day24/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO概述（概念&amp;分类）</p>
<p>i:input 输入（读取）</p>
<p>o:output 输出（写入）</p>
<p>流：数据（字符，字节）1个字符char=2个字节Byte    1个字节Byte=8个二进制bit（位）</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">字节输入流<br/>InputStream</td>
<td align="center">字节输出流<br/>OutputStream</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">字符输入流<br/>Reader</td>
<td align="center">字符输出流<br/>Writer</td>
</tr>
</tbody></table>
<p>输入（读）：内存    《——    硬盘</p>
<p>输出（写）：内存    ——》    硬盘</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="字节输出流【OutputStream】"><a href="#字节输出流【OutputStream】" class="headerlink" title="字节输出流【OutputStream】"></a>字节输出流【OutputStream】</h3><p><code>java.io.OutputStream</code>：此抽象类是表示输出字节流的所有类的超类</p>
<p><strong>直接已知子类：</strong> </p>
<p>ByteArrayOutputStream，FileOutputStream，FilterOutputStream， ObjectOutputStream，OutputStream，PipedOutputStream </p>
<p><strong>定义了一些共性的成员方法：</strong></p>
<ul>
<li>public void close( )：关闭此输出流并释放此流相关的任何系统资源</li>
<li>public void flush( )：刷新此输出流并强制任何缓冲的输出字节被写出</li>
<li>public void write( byte[ ] b )：将b.length字节从指定的字节数组写入此输出流</li>
<li>public void write( byte[ ] b , int off , int len )：从指定的字节数组写入len（写几个）字节，从偏移量off（数组开始索引）开始输出到此输出流</li>
<li>public abstract void write( int b )：将指定的字节输出流</li>
</ul>
<h4 id="FileOutputSteam类"><a href="#FileOutputSteam类" class="headerlink" title="FileOutputSteam类"></a>FileOutputSteam类</h4><p>java.io.FileOutputStream extends OutputStream</p>
<p>FileOutputStream：文件字节输出流</p>
<p>作用：把内存中的数据写入到硬盘的文件中</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>FileOutputStream( String name )：创建一个向具有指定名称的文件中写入数据的输出文件流</li>
<li>FileOutputStream( File file)：创建一个向指定File对象表示的文件中写入数据的文件输出流</li>
</ul>
<p>参数：写入数据的目的：</p>
<p>​    String name：目的地是一个文件的路径</p>
<p>​    File file：目的地是一个文件</p>
<p>构造方法的作用：</p>
<p>1.创建一个FileOutputStream对象</p>
<p>2.会根据构造方法中传递的文件/文件路径，创建一个空的文件</p>
<p>3.会把FileOutputStream对象指向创建好的文件</p>
<h4 id="字节输出流写入数据到文件"><a href="#字节输出流写入数据到文件" class="headerlink" title="字节输出流写入数据到文件"></a>字节输出流写入数据到文件</h4><p>写入数据的原理（内存——》硬盘）</p>
<p>java程序——》JVM（java虚拟机）——》OS（操作系统）——》OS调用写数据的方法——》把数据写入到文件中</p>
<p>​    </p>
<p>字节输出流的使用步骤：</p>
<p>1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地</p>
<p>2.调用FileOutputStream对象中的方法write，把数据写入到文件中</p>
<p>3.释放资源</p>
<h4 id="字节输出流写多个字节的方法"><a href="#字节输出流写多个字节的方法" class="headerlink" title="字节输出流写多个字节的方法"></a>字节输出流写多个字节的方法</h4><p>用带字节数组byte[ ]参数的write方法</p>
<p>byte[ ]字节数组起到缓冲的作用，存储写、读到的多个数据</p>
<p>​    </p>
<p>可以使用String类中的方法把字符串，转换为字节数组</p>
<p>byte[ ] getBytes( ) 把字符串转换为字节数组</p>
<h4 id="字节输出流的续写和换行"><a href="#字节输出流的续写和换行" class="headerlink" title="字节输出流的续写和换行"></a>字节输出流的续写和换行</h4><ul>
<li>public FileOutputStream( File file, boolean append )：创建文件输出流以写入由指定的File对象表示的文件</li>
<li>public FileOutputStream( String name, boolean append )：创建文件输出流以指定的名称写入文件</li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，true表示追加数据，false表示清空原有的数据，这样创建的输出流对象，就可以指定是否追加续写</p>
<p>写换行：写换行符号</p>
<p>windows：\r\n</p>
<p>linux：/n</p>
<p>mac：/r</p>
<h3 id="文件字节输出流练习代码"><a href="#文件字节输出流练习代码" class="headerlink" title="文件字节输出流练习代码"></a>文件字节输出流练习代码</h3><h4 id="一次输出一个字节"><a href="#一次输出一个字节" class="headerlink" title="一次输出一个字节"></a>一次输出一个字节</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次输出多个字节"><a href="#一次输出多个字节" class="headerlink" title="一次输出多个字节"></a>一次输出多个字节</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        fos.write(bytes);</span><br><span class="line"></span><br><span class="line">        fos.write(bytes, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes1 = <span class="string">&quot;你好&quot;</span>.getBytes();</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出流的续写和换行"><a href="#输出流的续写和换行" class="headerlink" title="输出流的续写和换行"></a>输出流的续写和换行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\c.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        fos.write(<span class="string">&quot;Hello,world!!!&quot;</span>.getBytes());</span><br><span class="line">        fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        fos.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节输入流【InputStream】"><a href="#字节输入流【InputStream】" class="headerlink" title="字节输入流【InputStream】"></a>字节输入流【InputStream】</h3><p><code>java.io.InputStream</code>：此抽象类表示字节输入流的所有类的超类</p>
<p><strong>直接已知子类：</strong> </p>
<p>AudioInputStream，ByteArrayInputStream，FileInputStream，FilterInputStream， InputStream，ObjectInputStream，PipedInputStream，SequenceInputStream， StringBufferInputStream</p>
<p><strong>定义了所有子类共性的成员方法：</strong></p>
<ul>
<li>void cloes( )：关闭此输入流并释放资源</li>
<li>int read( )：从输入流中读取数据的下一个字节</li>
<li>int read( byte[ ] b )：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中</li>
</ul>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p>java.io.FileInputStream extends InputStream</p>
<p>FileInputStream：文件字节输入流</p>
<p>作用：把硬盘文件中的数据，读取到内存中使用</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>FileInputStream( String name )</li>
<li>FileInputStream( File file )</li>
</ul>
<p>参数：读取文件的数据源</p>
<p>​    String name：文件的路径</p>
<p>​    File file：文件</p>
<p>构造方法的作用：</p>
<p>1.会创建一个FileInputStream对象</p>
<p>2.会把FileInputStream对象指定构造方法中要读取的文件</p>
<h4 id="字节输入流读取字节数据"><a href="#字节输入流读取字节数据" class="headerlink" title="字节输入流读取字节数据"></a>字节输入流读取字节数据</h4><p>读取数据的原理（硬盘——》内存）</p>
<p>java程序——》JVM——》OS——》OS读取数据的方法——》读取文件</p>
<p>​    </p>
<p>字节输入流的使用步骤：</p>
<p>1.创建FileInputStream对象，构造方法中绑定要读取的数据源</p>
<p>2.使用FileInputStream对象中的方法read，读取文件</p>
<p>3.释放资源</p>
<h4 id="字节输入流一次读取一个字节"><a href="#字节输入流一次读取一个字节" class="headerlink" title="字节输入流一次读取一个字节"></a>字节输入流一次读取一个字节</h4><p>int read( )</p>
<p>读取文件中的一个字节并返回，读取到文件的末尾返回-1</p>
<h4 id="字节输入流一次读取多个字节"><a href="#字节输入流一次读取多个字节" class="headerlink" title="字节输入流一次读取多个字节"></a>字节输入流一次读取多个字节</h4><p>int read( byte[ ]  b )</p>
<p>明确两件事情：</p>
<p>1.方法的参数byte[ ]的作用？</p>
<p>​    起到缓冲作用，存储每次读取到的多个字节</p>
<p>​    数组长度一般定义为1024（1kb）或者1024的整数倍</p>
<p>2.方法的返回值int是什么？</p>
<p>​    每次读取的有效字节个数</p>
<p>​    </p>
<p>String 类的构造方法：</p>
<p>String( byte[ ] bytes )：把字节数组转换为字符串</p>
<p>String( byte[ ]  bytes , int offset , int length )：把字节数组的一部分转换为字符串</p>
<h3 id="文件字节输入流练习代码"><a href="#文件字节输入流练习代码" class="headerlink" title="文件字节输入流练习代码"></a>文件字节输入流练习代码</h3><h4 id="一次读取一个字节"><a href="#一次读取一个字节" class="headerlink" title="一次读取一个字节"></a>一次读取一个字节</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次读取多个个字节"><a href="#一次读取多个个字节" class="headerlink" title="一次读取多个个字节"></a>一次读取多个个字节</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><p>就是一读一写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Programming\\1.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        一次读取一个字节写入一个字节的方法（效率低）</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = fis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            fos.write(len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组缓冲读取多个字节，写入多个字节（效率高）</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>专门处理字符的流，读写字符更便捷</p>
<h3 id="字符输入流【Reader】"><a href="#字符输入流【Reader】" class="headerlink" title="字符输入流【Reader】"></a>字符输入流【Reader】</h3><p><code>java.io.Reader</code>：字符输入流，是字符输入流的最顶层父类，定义了一些共性的成员方法，是一个抽象类</p>
<p><strong>直接已知子类：</strong> </p>
<p>BufferedReader，CharArrayReader，FilterReader，InputStreamReader， PipedReader，StringReader</p>
<p><strong>共性的成员方法：</strong></p>
<ul>
<li>int read( )：读取单个字符并返回</li>
<li>int read( char[ ] cbuf )：一次读取多个字符，将字符读入数组</li>
<li>void close( )：关闭并释放资源</li>
</ul>
<h4 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h4><p>java.io.FileReader extends InputStreamReader extends Reader</p>
<p>FileReader：文件字符输入流</p>
<p>作用：把硬盘文件中的数据以字符的方式读取到内存中</p>
<p>​    </p>
<p>构造方法：</p>
<p>FileReader( String fileName )</p>
<p>FileReader( File file )</p>
<h3 id="文件字符输入流练习代码"><a href="#文件字符输入流练习代码" class="headerlink" title="文件字符输入流练习代码"></a>文件字符输入流练习代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFileReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        读取单个字符并返回</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = fr.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.print((char) len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符输出流【Writer】"><a href="#字符输出流【Writer】" class="headerlink" title="字符输出流【Writer】"></a>字符输出流【Writer】</h3><p><code>java.io.Writer</code>：字符输出流，是所有字符输出流的最顶层的父类，是一个抽象类</p>
<p><strong>直接已知子类：</strong> </p>
<p>BufferedWriter，CharArrayWriter， FilterWriter， OutputStreamWriter，PipedWriter，PrintWriter， StringWriter，</p>
<p><strong>共性的成员方法：</strong></p>
<ul>
<li>void write( int c )：写入单个字符</li>
<li>void write( char[ ] cbuf )：写入字符数组</li>
<li>abstract void write( char[ ] cbuf , int off , int len )：写入字符数组的某一部分，off数组的开始索引，len写的字符个数</li>
<li>void write( String str )：写入字符串</li>
<li>void write( String str , int off , int len )：写入字符串的某一部分，off字符串的开始索引，len写的字符个数</li>
<li>void flush( )：刷新该流的缓冲</li>
<li>void close( )：关闭此流，但要先刷新它</li>
</ul>
<h4 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h4><p>java.io.FileWriter extends OutputStreamWriter extends Writer</p>
<p>FileWriter：文件字符输出流</p>
<p>作用：把内存中字符数据写入到文件中</p>
<p>​    </p>
<p>构造方法：</p>
<p>FileWriter( String fileName )</p>
<p>FileWriter( File file )</p>
<h4 id="字符输出写入单个字符到文件中"><a href="#字符输出写入单个字符到文件中" class="headerlink" title="字符输出写入单个字符到文件中"></a>字符输出写入单个字符到文件中</h4><p>字符输出流和字节输出流最大的区别就是字符输出流不是直接把数据写入到文件中，是先写到内存中，通过刷新到文件中，所以多个flush步骤</p>
<p>字符输出流的使用步骤：</p>
<p>1.创建FileWriter对象，构造方法中绑定要写入数据的目的地</p>
<p>2.使用FileWriter对象中的Write，把数据写入到内存缓冲区（字符转换为字节的过程）</p>
<p>3.使用FileWriter对象中的flush，把内存缓冲区中的数据，刷新到文件中</p>
<p>4.释放资源（会先把内存缓冲区中的数据刷新到文件中再关闭）</p>
<h4 id="flush方法和close方法的区别"><a href="#flush方法和close方法的区别" class="headerlink" title="flush方法和close方法的区别"></a>flush方法和close方法的区别</h4><p>flush：刷新缓冲区，流对象可以继续使用</p>
<p>close：先刷新缓冲区，然后通知系统释放资源，该对象不可以再被使用</p>
<h4 id="字符输出流写数据的其他方法"><a href="#字符输出流写数据的其他方法" class="headerlink" title="字符输出流写数据的其他方法"></a>字符输出流写数据的其他方法</h4><p>使用带字符数组或字符串参数的write方法</p>
<h4 id="字符输出流的续写和换行"><a href="#字符输出流的续写和换行" class="headerlink" title="字符输出流的续写和换行"></a>字符输出流的续写和换行</h4><ul>
<li>FileWriter( String fileName , boolean append )</li>
<li>FileWriter( File file , boolean append )</li>
</ul>
<p>写换行：写换行符号</p>
<p>windows：\r\n</p>
<p>linux：/n</p>
<p>mac：/r</p>
<h3 id="文件字符输出流练习代码"><a href="#文件字符输出流练习代码" class="headerlink" title="文件字符输出流练习代码"></a>文件字符输出流练习代码</h3><h4 id="一次输出一个字符"><a href="#一次输出一个字符" class="headerlink" title="一次输出一个字符"></a>一次输出一个字符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01FileWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建FileWriter对象，构造方法中绑定要写入数据的目的地</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用FileWriter对象中的Write，把数据写入到内存缓冲区（字符转换为字节的过程）</span></span><br><span class="line">        fw.write(<span class="number">97</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用FileWriter对象中的flush，把内存缓冲区中的数据，刷新到文件中</span></span><br><span class="line">        <span class="comment">//fw.flush();</span></span><br><span class="line">        <span class="comment">//刷新完之后流还可以继续使用</span></span><br><span class="line">        <span class="comment">//fw.write(98);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源（会先把内存缓冲区中的数据刷新到文件中再关闭）</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次输出多个字符"><a href="#一次输出多个字符" class="headerlink" title="一次输出多个字符"></a>一次输出多个字符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02FileWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\admin\\Desktop\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;O&#x27;</span>&#125;;</span><br><span class="line">        fw.write(chars);</span><br><span class="line">        fw.write(chars, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;你好&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="续写和换行"><a href="#续写和换行" class="headerlink" title="续写和换行"></a>续写和换行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03FileWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\admin\\Desktop\\c.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fw.write(<span class="string">&quot;Hello,World&quot;</span> + i +<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day25（IO流_异常处理、属性集）</title>
    <url>/2021/10/25/StudyNotes_day25/</url>
    <content><![CDATA[<h1 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h1><h2 id="JDK7以前的处理"><a href="#JDK7以前的处理" class="headerlink" title="JDK7以前的处理"></a>JDK7以前的处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01TryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提高fos的作用域，让finally可以使用</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a:\\Users\\admin\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">            fos.write(<span class="string">&quot;Hello,World!&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//创建对象失败了，fos默认值就是null，null是不能调用方法的，会抛出NullPointerException,需要增加一个判断</span></span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK7的处理"><a href="#JDK7的处理" class="headerlink" title="JDK7的处理"></a>JDK7的处理</h2><p>JDK7的新特性</p>
<p>在try的后边可以增加一个（），在括号中可以定义流对象</p>
<p>那么这个流对象的作用域就在try中有效</p>
<p>try中的代码执行完毕，会自动把流对象释放，不用写finally</p>
<p>格式：</p>
<p>try( 定义流对象 ；定义流对象….){</p>
<p>​    可能会产出异常的代码</p>
<p>}catch( 异常类变量 变量名 ){</p>
<p>​    异常的处理逻辑</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02TryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Programming\\1.jpg&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\1.jpg&quot;</span>);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK9的处理"><a href="#JDK9的处理" class="headerlink" title="JDK9的处理"></a>JDK9的处理</h2><p>JDK9新特性</p>
<p>try的前边可以定义流对象</p>
<p>在try后边的（）中可以直接引入流对象的名称（变量名）</p>
<p>在try代码执行完毕之后，流对象也可以释放掉，不用写finally</p>
<p>格式：</p>
<p>​    A a = new A( );</p>
<p>​    B b = new B( );</p>
<p>​    try( a,b ){</p>
<p>​    可能会产生异常的代码</p>
<p>}catch( 异常类变量 变量名 ){</p>
<p>​    异常的处理逻辑</p>
<p>}</p>
<h1 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.util.Properties</code>,继承与<code>Hashtable</code>,来表示一个持久的属性集，它使用键值结构存储数据，每个键及其对应值都是一个字符串，该类也被许多java类使用，比如获取系统属性时，<code>System.getProperties</code>方法就是返回一个<code>Properties</code>对象</p>
<h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><p><code>java.util.Properties</code>集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;</p>
<p>Properties类表示了一个持久的属性集。Properties 可保存在流中或从流中加载</p>
<p>Properties集合是一个唯一和IO流结合的集合</p>
<p>​    可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储</p>
<p>​    可以使用Properties集合中的方法load，把硬盘中保持的文件（键值对），读取到集合中使用</p>
<h2 id="使用Propreties集合存储数据，遍历取出Properties集合中数据"><a href="#使用Propreties集合存储数据，遍历取出Properties集合中数据" class="headerlink" title="使用Propreties集合存储数据，遍历取出Properties集合中数据"></a>使用Propreties集合存储数据，遍历取出Properties集合中数据</h2><p>属性列表中每个键及其对应值都是一个字符串</p>
<p>​    Properties集合是一个双列集合，key和value默认都是字符串</p>
<p>Properties集合有一些操作字符串的特有方法</p>
<ul>
<li><p>Object setProperty( String key , String value )：调用Hashtable的put</p>
</li>
<li><p>String getProperty( String key )：通过key找到value值，此方法相当于Map集合中的get( key )方法</p>
</li>
<li><p>Set<String> stringPropertyNomes( )：返回此属性列表中的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的keySet方法</p>
<h2 id="Properties集合中的方法store"><a href="#Properties集合中的方法store" class="headerlink" title="Properties集合中的方法store"></a>Properties集合中的方法store</h2></li>
</ul>
<p>可以使用Properties集合中的store，把集合中的临时数据，持久化写入到硬盘中存储</p>
<ul>
<li>void store( OutputStream out , String comments )</li>
<li>void store( Writer writer , String comments )</li>
</ul>
<p>参数：</p>
<p>​    OutputStream out ：字节输出流，不能写入中文</p>
<p>​    Writer writer：字符输出流，可以写中文</p>
<p>​    String comments：注释，用来解释说明保存文件是做什么用的，不能使用中文，会产生乱码，默认是Unicode编码，一般使用“ ”空字符串</p>
<p>​    </p>
<p>使用步骤：</p>
<p>​    1.创建Properties集合对象，添加数据</p>
<p>​    2.创建字节输出流/字符输出流，构造方法中绑定要输出目的地</p>
<p>​    3.使用Properties集合中的方法Store，把集合中的临时数据，持久化写入硬盘中</p>
<p>​    4.释放资源</p>
<h2 id="Properties集合中的方法load"><a href="#Properties集合中的方法load" class="headerlink" title="Properties集合中的方法load"></a>Properties集合中的方法load</h2><p>可以使用Properties集合中的方法load，把硬盘中保持的文件（键值对），读取到集合中使用</p>
<ul>
<li>void load( InputStream inStream )</li>
<li>void load( Reader reader )</li>
</ul>
<p>参数：</p>
<p>​    InputStream inStream：字节输入流，不能读取含有中文的键值对</p>
<p>​    Reader reader：字符输入流，能读取含有中文的键值对</p>
<p>​    </p>
<p>使用步骤：</p>
<p>​    1.创建Properties集合对象</p>
<p>​    2.使用Properties集合对象中的方法load读取保存键值对的文件</p>
<p>​    3.遍历Properties集合</p>
<p>注意：</p>
<p>​    1.存储键值对的文件中，键与值默认的连接符号可以使用=，空格（其他符号）</p>
<p>​    2.存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取</p>
<p>​    3.存储键值对的文件中，键与值默认都是字符串，不用再加引号</p>
<h2 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h2><h3 id="Properties集合的基本使用（存储、取出数据）"><a href="#Properties集合的基本使用（存储、取出数据）" class="headerlink" title="Properties集合的基本使用（存储、取出数据）"></a>Properties集合的基本使用（存储、取出数据）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Properties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Properties集合对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用setProperty往集合中添加数据</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;小花&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;小芳&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; keys = prop.stringPropertyNames();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历Set集合，取出properties集合的每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">//使用getProperty通过key获取value</span></span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Properties集合中的方法store-1"><a href="#Properties集合中的方法store-1" class="headerlink" title="Properties集合中的方法store"></a>Properties集合中的方法store</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Properties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建Properties集合对象，添加数据</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;juhn&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节输出流/字符输出流，构造方法中绑定要输出目的地</span></span><br><span class="line">        <span class="comment">//FileOutputStream fos = new FileOutputStream(&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Properties集合中的方法Store，把集合中的临时数据，持久化写入硬盘中</span></span><br><span class="line">        <span class="comment">//prop.store(fos,&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//fos.close();</span></span><br><span class="line"></span><br><span class="line">        prop.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>), <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Properties集合中的方法load-1"><a href="#Properties集合中的方法load-1" class="headerlink" title="Properties集合中的方法load"></a>Properties集合中的方法load</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Properties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        prop.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day26（IO流_缓冲流、转换流）</title>
    <url>/2021/11/14/StudyNotes_day26/</url>
    <content><![CDATA[<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>缓冲流，也叫高效率，是对4个基本的<code>FileXxx</code>流的增强，所以也是4个流</p>
<p>原理：在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提供读写的效率</p>
<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><h3 id="字节缓冲输出流-BufferedOutputStream"><a href="#字节缓冲输出流-BufferedOutputStream" class="headerlink" title="字节缓冲输出流_BufferedOutputStream"></a>字节缓冲输出流_BufferedOutputStream</h3><p><code>java.io.BufferedOutputStream</code> extends FilterOutputStream extends OutputStream</p>
<p>继承父类OutputStream共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>BufferedOutputStream( OutputStream out )</li>
<li>BufferedOutputStream( OutputStream out , int size )</li>
</ul>
<p>参数：</p>
<p>​    OutputStream out：字节输出流</p>
<p>​    int size：指定缓冲区大小，不指定为默认大小</p>
<p>注意：BufferedOutputStream写入数据需要flush。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01BufferedOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        bos.write(<span class="string">&quot;Hello,World!!!&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02BufferedOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.tx&quot;</span>)) &#123;</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">            bos.write(<span class="string">&quot;Hello,World!!!&quot;</span>.getBytes());</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节缓冲流入流-BufferedInputStream"><a href="#字节缓冲流入流-BufferedInputStream" class="headerlink" title="字节缓冲流入流_BufferedInputStream"></a>字节缓冲流入流_BufferedInputStream</h3><p><code>java.io.BufferedInputStream</code> extends FilterInputStream extends InputStream</p>
<p>继承父类InputStream共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>BufferedInputStream( InputStream in )</li>
<li>BufferedInputStream( InputStream in , int size )</li>
</ul>
<p>参数：</p>
<p>​    InputStream in：字节输入流</p>
<p>​    int size：指定缓冲区大小，不指定为默认大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01BufferedInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02BufferedInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓冲流效率测试-复制文件"><a href="#缓冲流效率测试-复制文件" class="headerlink" title="缓冲流效率测试_复制文件"></a>缓冲流效率测试_复制文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MethodBuffered();</span></span><br><span class="line">        MethodNoBuffered();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不适用缓冲流复制文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodNoBuffered</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Downloads\\Music\\xxx.mp3&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\1.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用缓冲流复制文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodBuffered</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Downloads\\Music\\xxx.mp3&quot;</span>));</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\1.mp3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><h3 id="字符缓冲输出流-BufferedWriter"><a href="#字符缓冲输出流-BufferedWriter" class="headerlink" title="字符缓冲输出流_BufferedWriter"></a>字符缓冲输出流_BufferedWriter</h3><p><code>java.io.BufferedWriter</code> extends Writer</p>
<p>继承父类Writer共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>BufferedWriter( Writer out )</li>
<li>BufferedWriter( Writer out , int size )</li>
</ul>
<p>参数：</p>
<p>​    Writer out ：字符输出流</p>
<p>​    int size：指定缓冲区大小，不指定为默认大小</p>
<p>注意：写入数据需要flush。</p>
<p>​    </p>
<p>特有的成员方法：</p>
<ul>
<li>void newLine( ) ：写入一个行分隔符。会根据不同操作系统，获取不同的行分隔符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                bw.write(<span class="string">&quot;你好&quot;</span> + i);</span><br><span class="line">                bw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符缓冲输入流-BufferedReader"><a href="#字符缓冲输入流-BufferedReader" class="headerlink" title="字符缓冲输入流_BufferedReader"></a>字符缓冲输入流_BufferedReader</h3><p><code>java.io.BufferedReader</code> extends Reader</p>
<p>继承父类Reader共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>BufferedReader( Reader in )</li>
<li>BufferedReader( Reader in , int size )</li>
</ul>
<p>参数：</p>
<p>​    Reader in ：字符输入流</p>
<p>​    int size：指定缓冲区大小，不指定为默认大小</p>
<p>​    </p>
<p>特有的成员方法：</p>
<ul>
<li>String readLine( )：读取一个文本行。读取一行数据。达到末尾返回null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//MethodBuffered();</span></span><br><span class="line">        MethodNoBuffered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用特有的readLine方法读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodNoBuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用共有的read方法读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodBuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">final</span> FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\admin\\Desktop\\a.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = br.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><h2 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h2><p> <strong>字符编码</strong></p>
<p>按照某种规则，将字符<strong>存储</strong>到计算机中，称为<strong>编码</strong>。反之，将存储在计算机中的二进制数按照某种规则<strong>解析</strong>显示出来，成为<strong>解码</strong>。</p>
<p>A规则存储，A规则解析，能显示正确的文本符号。反之，A规则存储，B规则解析，就会导致乱码现象。</p>
<p>编码：字符（能看懂的）——》字节（看不懂的）</p>
<p>解码：字节（看不懂的）——》字符（能看懂的）</p>
<p>字符编码：就是一套自燃语言的字符与二进制数之间的对应规则。</p>
<p><strong>编码表</strong>：生活中文字和计算机中二进制的对应规则。</p>
<p><strong>字符集</strong>：也叫编码表。</p>
<p><strong>GBK字符集中一个汉字占用：2个字节，utf-8字符集中一个汉字占用：3个字节</strong></p>
<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p><code>java.io.OutputStreamWriter</code> extends Writer</p>
<p>OutputStreamWriter ：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码：把能看懂的变成看不懂的)</p>
<p>​    </p>
<p>继承父类Writer共性的成员方法</p>
<p>构造方法：</p>
<ul>
<li>OutputStreamWriter( OutputStream out ) ：创建使用默认字符编码的 OutputStreamWriter。</li>
<li>OutputStreamWriter( OutputStream out , String charsetName ) ：创建使用指定字符集的 OutputStreamWriter。</li>
</ul>
<p>参数：</p>
<p>​    OutputStream out：创建字节输出流</p>
<p>​    String charsetName：指定的编码表名称，不区分大小写，默认utf-8</p>
<p>注意事项：写入数据需要flush</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOutputStreamWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        writer_utf_8();</span><br><span class="line">        writer_GBK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer_GBK</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\GBK文件.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\utf-8文件.txt&quot;</span>));</span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><p><code>java.io.InputStreamReader</code> extends Reader</p>
<p>InputStreamReader ：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。（解码：把看不懂变成能看懂的）</p>
<p>​    </p>
<p>继承父类Reader共性的成员方法</p>
<p>构造方法：</p>
<ul>
<li>InputStreamReader( InputStream in ) ：创建一个使用默认字符集的 InputStreamReader。</li>
<li>InputStreamReader( InputStream in , String charsetName ) ：创建使用指定字符集的 InputStreamReader。</li>
</ul>
<p>参数：</p>
<p>​    InputStream in：创建字节输入流</p>
<p>​    String charsetName：指定的编码表名称，不区分大小写，默认utf-8</p>
<p>注意事项：构造方法中指定的编码表名称要和文件的编码表相同，否则会出现乱码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInputStreamReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read_utf_8();</span><br><span class="line">        read_GBK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_GBK</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\GBK文件.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\utf-8文件.txt&quot;</span>));</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换流练习-转换文件编码"><a href="#转换流练习-转换文件编码" class="headerlink" title="转换流练习_转换文件编码"></a>转换流练习_转换文件编码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将GBK编码的文本文件，转换为UTF-8编码的文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\GBK文件.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\utf-8文件.txt&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        isr.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day27（IO流_序列化和反序列化、打印流）</title>
    <url>/2021/11/28/StudyNotes_day27/</url>
    <content><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>序列化：对象转换为字节（ 内存——》硬盘 ）</p>
<p>反序列化：字节重构为对象（ 内存《——硬盘 ）</p>
<p><strong>只有类实现了Serializable接口，其对象才能进行序列化和反序列化</strong></p>
<h2 id="对象的序列化流-ObjectOutputStream"><a href="#对象的序列化流-ObjectOutputStream" class="headerlink" title="对象的序列化流_ObjectOutputStream"></a>对象的序列化流_ObjectOutputStream</h2><p><code>java.io.ObjectOutputStream</code> extends OutputStream</p>
<p>继承父类OutputStream共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>ObjectOutputStream( OutputStream out ) ：创建写入指定 OutputStream 的 ObjectOutputStream。</li>
</ul>
<p>参数：</p>
<p>​    OutputStream out ：创建字节输出流</p>
<p>特有的成员方法：</p>
<ul>
<li>void writeObject( Object obj ) ：将指定的对象写入 ObjectOutputStream。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.company.demo14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\person.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的反序列化流-ObjectInputStream"><a href="#对象的反序列化流-ObjectInputStream" class="headerlink" title="对象的反序列化流_ObjectInputStream"></a>对象的反序列化流_ObjectInputStream</h2><p><code>java.io.ObjectInputStream</code> extends InputStream</p>
<p>继承父类InputStream共性的成员方法</p>
<p>​    </p>
<p>构造方法：</p>
<ul>
<li>ObjectInputStream( InputStream in ) ：创建从指定 InputStream 读取的 ObjectInputStream。</li>
</ul>
<p>参数：</p>
<p>​     InputStream in ：创建字节输入流</p>
<p>特有的成员方法：</p>
<ul>
<li> Object readObject( )  ： 从 ObjectInputStream 读取对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\person.txt&quot;</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印反序列化得到的对象</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="transient关键字-瞬态关键字"><a href="#transient关键字-瞬态关键字" class="headerlink" title="transient关键字_瞬态关键字"></a>transient关键字_瞬态关键字</h2><p>如果类有某些属性不需要序列化，就用transient修饰该属性</p>
<h2 id="InvalidClassException异常及处理"><a href="#InvalidClassException异常及处理" class="headerlink" title="InvalidClassException异常及处理"></a>InvalidClassException异常及处理</h2><p>Serializable接口给需要序列化的类，提供了一个序列版本号（序列号）：serialVersionUID </p>
<p>在需要序列号的类中同时实现了Serializable接口，并手动加上序列号serialVersionUID，修改类中的属性后再反序列化就不会出现InvalidClassException异常</p>
<p>处理：</p>
<p>在实现类了Serializable接口的类中添加:</p>
<p>private static final long serialVersionUID = 1L</p>
<h2 id="练习-序列化集合"><a href="#练习-序列化集合" class="headerlink" title="练习_序列化集合"></a>练习_序列化集合</h2><p>当需要序列化多个对象时，可以先把对象存放到集合中，再讲集合进行序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.company.demo14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\list.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\admin\\Desktop\\list.txt&quot;</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Person&gt; list1 = (ArrayList&lt;Person&gt;) o;</span><br><span class="line">        <span class="keyword">for</span> (Person p : list) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p><code>java.io.PrintStream</code> extends FilterOutputStream extends OutputStream</p>
<p>平时在控制台打印输出，就是调用PrintStream类中的print（）方法和println（）方法</p>
<p>System.out中的out就是PrintStream类的对象</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day29（javaSE部分总结）</title>
    <url>/2021/12/31/StudyNotes_day29/</url>
    <content><![CDATA[<h1 id="javaSE部分总结"><a href="#javaSE部分总结" class="headerlink" title="javaSE部分总结"></a>javaSE部分总结</h1><table>
<thead>
<tr>
<th>知识点</th>
<th>对应的笔记</th>
</tr>
</thead>
<tbody><tr>
<td>Java 基础语法（数据类型、流程控制）</td>
<td>StudyNotes_day1、2、3、4、5</td>
</tr>
<tr>
<td>数组</td>
<td>StudyNotes_day7</td>
</tr>
<tr>
<td>面向对象（方法、重载、封装 、继承、多态）</td>
<td>StudyNotes_day6、8、9、13、15</td>
</tr>
<tr>
<td>抽象类</td>
<td>StudyNotes_day13</td>
</tr>
<tr>
<td>接口</td>
<td>StudyNotes_day14</td>
</tr>
<tr>
<td>修饰符（staic、final、(default)、protected、public）</td>
<td>StudyNotes_day12、16</td>
</tr>
<tr>
<td>内部类</td>
<td>StudyNotes_day16</td>
</tr>
<tr>
<td>常用类（String、Object、日期时间）</td>
<td>StudyNotes_day12、17</td>
</tr>
<tr>
<td>工具类（Scanner、Random、Arrays、Math、Objects、包装类、Collections）</td>
<td>StudyNotes_day12、17、19</td>
</tr>
<tr>
<td>集合类</td>
<td>StudyNotes_day11、18、19、20</td>
</tr>
<tr>
<td>泛型</td>
<td>StudyNotes_day18</td>
</tr>
<tr>
<td>异常处理</td>
<td>StudyNotes_day21</td>
</tr>
<tr>
<td>多线程</td>
<td>StudyNotes_day22</td>
</tr>
<tr>
<td>Lambda、递归</td>
<td>StudyNotes_day23</td>
</tr>
<tr>
<td>File类</td>
<td>StudyNotes_day23</td>
</tr>
<tr>
<td>IO 流</td>
<td>StudyNotes_day24、25、26、27</td>
</tr>
<tr>
<td>反射</td>
<td>StudyNotes_day28</td>
</tr>
<tr>
<td>junit、注解</td>
<td>StudyNotes_day28</td>
</tr>
</tbody></table>
<ul>
<li>Java 基础语法<ul>
<li>数据类型</li>
<li>流程控制</li>
</ul>
</li>
<li>数组</li>
<li>面向对象<ul>
<li>方法</li>
<li>重载</li>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
<li>抽象类</li>
<li>接口</li>
<li>内部类</li>
<li>常用类<ul>
<li>String</li>
<li>日期时间</li>
</ul>
</li>
<li>集合类</li>
<li>泛型</li>
<li>异常处理</li>
<li>File类</li>
<li>多线程</li>
<li>IO 流</li>
<li>反射</li>
<li>注解</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day28（junit、反射、注解）</title>
    <url>/2021/12/19/StudyNotes_day28/</url>
    <content><![CDATA[<h1 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h1><p>JUnit是一个Java语言的单元测试框架</p>
<h2 id="JUnit单元测试概述"><a href="#JUnit单元测试概述" class="headerlink" title="JUnit单元测试概述"></a>JUnit单元测试概述</h2><p>测试分类：</p>
<p>1.黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值</p>
<p>2.白盒测试：需要写代码。关注程序具体的执行流程</p>
<p>JUnit单元测试就属于白盒测试</p>
<h2 id="JUnit使用步骤"><a href="#JUnit使用步骤" class="headerlink" title="JUnit使用步骤"></a>JUnit使用步骤</h2><p>1.定义一个测试类（测试用例）</p>
<p>​    建议：</p>
<p>​        包名：xxx.xxx.xx.test</p>
<p>​        测试类名：被测试的类名+Test</p>
<p>2.定义测试方法：可以独立运行</p>
<p>​    建议：</p>
<p>​        返回值：void</p>
<p>​        方法名：test+测试的方法名</p>
<p>​        参数：空参</p>
<p>3.给方法加@Test</p>
<p>4.导入junit依赖</p>
<p>​    </p>
<p>判定结果：</p>
<p>​    红色：失败</p>
<p>​    绿色：成功</p>
<p>​    一般我们会使用断言操作来处理结果</p>
<p>​        Assert.assertEquals( 期望的结果，运算的结果 );</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.junit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> result = calc.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> result = calc.sub(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JUnit-Before-amp-After"><a href="#JUnit-Before-amp-After" class="headerlink" title="JUnit_@Before&amp;@After"></a>JUnit_@Before&amp;@After</h2><p>@Before：修饰的方法会在测试方法之前被自动执行</p>
<p>@After：修饰的方法会在测试方法执行之后自动被执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 用于资源申请，所有测试方法执行之前会先执行该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源方法</span></span><br><span class="line"><span class="comment">     * 在所有测试方法执行完后，都会判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> result = calc.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> result = calc.sub(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射-概述"><a href="#反射-概述" class="headerlink" title="反射_概述"></a>反射_概述</h2><p>涉及的类：</p>
<p><code>java.lang.Class&lt;T&gt;</code> extends Object</p>
<p><code>java.lang.ClassLoader</code> extends Object</p>
<p><code>java.lang.reflect.AccessibleObject</code> extends Object</p>
<p><code>java.lang.reflect.Field</code> extends AccessibleObject extends Object</p>
<p><code>java.lang.reflect.Constructor&lt;T&gt;</code> extends AccessibleObject extends Object</p>
<p><code>java.lang.reflect.Method</code> extends AccessibleObject extends Object</p>
<p>​    </p>
<p>反射：框架设计的灵魂</p>
<p>​    框架：半成品软件，可以在框架的基础上进行软件开发，简化代码</p>
<p>​    <strong>反射机制：将类的各个组成部分封装为其他对象</strong></p>
<p>​        好处：1.可以在程序运行过程中，操作这些对象</p>
<p>​                    2.可以解耦，提高程序的可扩展性</p>
<p>​    </p>
<p><img src="/screenshot/%E5%8F%8D%E5%B0%84%E3%80%81java%E4%BB%A3%E7%A0%81%E7%9A%843%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="图片"></p>
<p><strong>java代码经历的三阶段：</strong></p>
<p><strong>Source源代码阶段——&gt;Class类对象阶段——&gt;Runtime运行时阶段</strong></p>
<h2 id="反射-获取Class对象的三种方式"><a href="#反射-获取Class对象的三种方式" class="headerlink" title="反射_获取Class对象的三种方式"></a>反射_获取Class对象的三种方式</h2><p><strong>Source源代码阶段：</strong></p>
<blockquote>
<p>Class.forName( “全类名” )：将字节码文件加载到内存，返回class对象</p>
<p>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p>
</blockquote>
<p><strong>Class类对象阶段：</strong></p>
<blockquote>
<p>类名.class：通过类名的属性class获取</p>
<p>多用于参数的传递</p>
</blockquote>
<p><strong>Runtime运行时阶段：</strong></p>
<blockquote>
<p>对象.getClass( )：getClass( ) 方法在Object类中定义</p>
<p>多用于对象的获取字节码的方式</p>
</blockquote>
<p>结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个</p>
<h2 id="反射-Class对象功能概述（api）"><a href="#反射-Class对象功能概述（api）" class="headerlink" title="反射_Class对象功能概述（api）"></a>反射_Class对象功能概述（api）</h2><ol>
<li><p>获取成员变量</p>
<ul>
<li> Field[ ] getFields( ) ：获取所有public修饰的成员变量</li>
<li> Field getField( String name ) ：获取指定名字的public修饰的成员变量</li>
<li> Field[ ] getDeclaredFields( ) ：获取所有的成员变量，不考虑修饰符，但访问私有的成员变量需要忽略权限修饰符的安全检查</li>
<li> Field getDeclaredField( String name ) ：获取指定名字的成员变量，不考虑修饰符，但访问私有的成员变量需要忽略权限修饰符的安全检查</li>
</ul>
</li>
<li><p>获取构造方法</p>
<ul>
<li>Constructor&lt;?&gt;[ ] getConstructors( ) </li>
<li>Constructor<T> getConstructor( Class&lt;?&gt;… parameterTypes ) </li>
<li>Constructor&lt;?&gt;[ ] getDeclaredConstructors( ) </li>
<li>Constructor<T> getDeclaredConstructor( Class&lt;?&gt;… parameterTypes ) </li>
</ul>
</li>
<li><p>获取成员方法</p>
<ul>
<li>Method[ ] getMethods( ) </li>
<li>Method getMethod( String name, Class&lt;?&gt;… parameterTypes ) </li>
<li>Method[ ] getDeclaredMethods( ) </li>
<li>Method getDeclaredMethod( String name, Class&lt;?&gt;… parameterTypes ) </li>
</ul>
</li>
<li><p>获取类名</p>
<ul>
<li>String getName( ) ：全类名，包名+类名</li>
</ul>
</li>
<li><p>获取类加载器</p>
<ul>
<li>ClassLoader getClassLoader( ) ：返回该类的类加载器</li>
</ul>
</li>
</ol>
<p>​    </p>
<p>方法名中带Declared的不考虑修饰符，不带只获取public修饰的</p>
<p>Class&lt;?&gt;… parameterTypes：参数类型的Class对象，如String.class，int.class。已知类名称，用获取Class对象的第二种方式。</p>
<h2 id="反射-Class对象功能——获取Field对象及使用Field类的api"><a href="#反射-Class对象功能——获取Field对象及使用Field类的api" class="headerlink" title="反射_Class对象功能——获取Field对象及使用Field类的api"></a>反射_Class对象功能——获取Field对象及使用Field类的api</h2><ol>
<li><p>设置值</p>
<ul>
<li>void set( Object obj, Object value )  </li>
</ul>
</li>
<li><p>获取值</p>
<ul>
<li>Object get ( Object obj ) </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查（暴力反射）</p>
<ul>
<li>void setAccessible(boolean flag) ：继承自AccessibleObject类里的方法</li>
</ul>
</li>
</ol>
<h2 id="反射-Class对象功能——获取Constructor对象及使用Constructor类的api"><a href="#反射-Class对象功能——获取Constructor对象及使用Constructor类的api" class="headerlink" title="反射_Class对象功能——获取Constructor对象及使用Constructor类的api"></a>反射_Class对象功能——获取Constructor对象及使用Constructor类的api</h2><ol>
<li><p>创建对象</p>
<ul>
<li>T newInstance( Object… initargs )</li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查（暴力反射）</p>
<ul>
<li>void setAccessible(boolean flag) ：继承自AccessibleObject类里的方法</li>
</ul>
</li>
</ol>
<p>​    </p>
<p>如果使用空参数构造方法创建对象,操作可以简化：Class对象的newInstance( )方法  </p>
<h2 id="反射-Class对象功能——获取Method对象及使用Method类的api"><a href="#反射-Class对象功能——获取Method对象及使用Method类的api" class="headerlink" title="反射_Class对象功能——获取Method对象及使用Method类的api"></a>反射_Class对象功能——获取Method对象及使用Method类的api</h2><ol>
<li><p>执行方法</p>
<ul>
<li>Object invoke(Object obj, Object… args)  </li>
</ul>
</li>
<li><p>获取方法名称</p>
<ul>
<li>String getName()  </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查（暴力反射）</p>
<ul>
<li>void setAccessible(boolean flag) ：继承自AccessibleObject类里的方法</li>
</ul>
</li>
</ol>
<h2 id="反射-案例"><a href="#反射-案例" class="headerlink" title="反射_案例"></a>反射_案例</h2><p>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中的任意方法</p>
<p>实现：</p>
<p>1.配置文件</p>
<p>2.反射</p>
<p>步骤：</p>
<p>1.将需要创建的对象全类名和需要执行的方法定义在配置文件中</p>
<p>2.在程序中加载读取配置文件</p>
<p>3.使用反射技术来加载类文件进内存</p>
<p>4.创建对象</p>
<p>5.执行方法</p>
<h2 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h2><p>0.被反射操作的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    String b;</span><br><span class="line">    <span class="keyword">protected</span> String c;</span><br><span class="line">    <span class="keyword">private</span> String d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, a=&#x27;&quot;</span> + a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, b=&#x27;&quot;</span> + b + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, c=&#x27;&quot;</span> + c + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, d=&#x27;&quot;</span> + d + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃.....&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.获取Class对象的三种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象的三种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoReflectGetClassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.Class.forName( &quot;全类名&quot; )</span></span><br><span class="line">        Class cls1 = Class.forName(<span class="string">&quot;com.company.reflect.DemoReflectGetClassOcject&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.类名.class</span></span><br><span class="line">        Class cls2 = DemoReflectGetClassObject.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.对象.getClass()</span></span><br><span class="line">        DemoReflectGetClassObject drglo = <span class="keyword">new</span> DemoReflectGetClassObject();</span><br><span class="line">        Class cls3 = drglo.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个</span></span><br><span class="line">        System.out.println(cls1 == cls2);</span><br><span class="line">        System.out.println(cls1 == cls3);</span><br><span class="line">        System.out.println(cls2 == cls3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.获取Field对象及使用Field类的api</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.pojo.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFieldsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一件事，获取Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field[] getFields() ：获取所有public修饰的成员变量</span></span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFieldTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field getField(String name) ：获取指定名字的public修饰的成员变量</span></span><br><span class="line">        Field a = personClass.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到变量的对象后可以做两件事：1.获取值2.设置值</span></span><br><span class="line">        <span class="comment">//Object get (Object obj) ：获取值</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Object o = a.get(p);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//void set( Object obj, Object value ) ：设置值</span></span><br><span class="line">        a.set(p, <span class="string">&quot;一&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDeclaredFieldsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field[] getDeclaredFields() ：获取所有的成员变量，不考虑修饰符</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDeclaredFieldTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field getDeclaredField(String name) ：获取指定名字的成员变量，不考虑修饰符</span></span><br><span class="line">        Field d = personClass.getDeclaredField(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//忽略访问权限修饰符的安全检查</span></span><br><span class="line">        d.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Object o = d.get(p);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        d.set(p,<span class="string">&quot;四&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.获取Constructor对象及使用Constructor类的api</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.pojo.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定参数的构造器</span></span><br><span class="line">        Constructor&lt;Person&gt; cons1 = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        Person p1 = cons1.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参构造器</span></span><br><span class="line">        Constructor&lt;Person&gt; cons2 = personClass.getConstructor();</span><br><span class="line">        Person p2 = cons2.newInstance();</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果使用空参数构造方法创建对象,操作可以简化：Class对象的newInstance()方法</span></span><br><span class="line">        Person p3 = personClass.newInstance();</span><br><span class="line">        System.out.println(p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.获取Method对象及使用Method类的api</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.pojo.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        Person p = personClass.newInstance();</span><br><span class="line"></span><br><span class="line">        Method eat = personClass.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat.invoke(p, <span class="string">&quot;饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        personClass.getMethod(<span class="string">&quot;eat&quot;</span>).invoke(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.案例实现</p>
<p>在src下新建一个文件，名为：pro.propertie，该文件作为配置文件，内容：</p>
<p>className=com.company.pojo.Person<br>methodName=eat</p>
<p>再写一个”框架”，实现不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中的任意方法，想创建什么对象就在配置文件中修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//classLoader类加载器能找到该类的位置，也就能找到同一个model里的配置文件pro.properties的位置</span></span><br><span class="line">        ClassLoader classLoader = FrameworkTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        prop.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取配置文件中定义的数据</span></span><br><span class="line">        String className = prop.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodName = prop.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Class&lt;?&gt; cls = Class.forName(className);</span></span><br><span class="line"><span class="comment">//        cls.getMethod(methodName).invoke(cls.newInstance());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解：说明程序的。给计算机看的</p>
<p>注释：用文字描述程序的。给程序员看的</p>
<p>概念：从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署</p>
<p>概念描述：</p>
<p>1.JDK1.5之后的新特性</p>
<p>2.说明程序的</p>
<p>3.使用注解：@注解名称</p>
<p>作用分类：</p>
<ol>
<li>编写文档：通过代码里标识的元数据生成文档【生成doc文档】</li>
<li>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override等】</li>
<li>代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</li>
</ol>
<h2 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h2><p>java提供了5个基本的注解，分别是</p>
<p><strong>1.@Override</strong></p>
<p><strong>2.@Deprecated</strong></p>
<p><strong>3.@SuppressWarnings</strong></p>
<p><strong>4.@SafeVarargs</strong></p>
<p><strong>5.@FunctionalInterface</strong></p>
<p><strong>1.限定父类重写方法:@Override：</strong></p>
<p>当子类重写父类方法时，子类可以加上这个注解，那这有什么什么用？这可以确保子类确实重写了父类的方法，避免出现低级错误</p>
<p><strong>2.标示已过时:@Deprecated：</strong></p>
<p>这个注解用于表示某个程序元素类，方法等已过时，当其他程序使用已过时的类，方法时编译器会给出警告（删除线，这个见了不少了吧）。</p>
<p><strong>3.抑制编译器警告:@SuppressWarnings：</strong></p>
<p>被该注解修饰的元素以及该元素的所有子元素取消显示编译器警告，例如修饰一个类，那他的字段，方法都是显示警告（在类上加@SuppressWarnings(“all”)）</p>
<p><strong>4.“堆污染”警告与@SafeVarargs：</strong></p>
<p>想理解这个就要明白什么是堆污染，堆污染是什么？</p>
<p>其实很好理解，就是把不带泛型的对象赋给一个带泛型的对象，为什么不行？很简单，因为不带泛型的话，默认会给泛型设定为object，意思就是什么类型都可以往里面塞，那你一个不带泛型的怎么可能给一个带泛型塞呢。</p>
<p>例如运行如下代码：</p>
<p>List list = new ArrayList(); </p>
<p>list.add(20); </p>
<p>List<String> ls = list; </p>
<p>System.out.println(ls.get(0));</p>
<p>则会抛出堆污染异常Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Test.Test1.main(Test1.java:29)</p>
<p>注意：可变参数更容易引发堆污染异常，因为java不允许创建泛型数组，可变参数恰恰是数组。</p>
<p>抑制这个警告的方法有三个:</p>
<p>1.@SafeVarargs修饰引发该警告的方法或构造器</p>
<p>2.使用@suppressWarnings(“unchecked”)</p>
<p>3.编译时使用-Xlint:varargs</p>
<p><strong>5.函数式接口与@Functionallnterface：</strong></p>
<p>什么是函数式？如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法）</p>
<p>接口体内只能声明常量字段和抽象方法，并且被隐式声明为public，static，final。</p>
<p>接口里面不能有私有的方法或变量。</p>
<p>这个注解有什么用？这个注解保证这个接口只有一个抽象方法，注意这个只能修饰接口</p>
<h2 id="自定义注解-格式-amp-本质"><a href="#自定义注解-格式-amp-本质" class="headerlink" title="自定义注解_格式&amp;本质"></a>自定义注解_格式&amp;本质</h2><p>格式：</p>
<p>元注解</p>
<p>public @interface 注解名称{ </p>
<p>​    属性列表；（抽象方法）</p>
<p>}</p>
<p>​    </p>
<p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<p>public interface MyAnnotation extends java.lang.annotation.Annotation {<br>}</p>
<h2 id="自定义注解-属性定义"><a href="#自定义注解-属性定义" class="headerlink" title="自定义注解_属性定义"></a>自定义注解_属性定义</h2><p>属性：接口中的抽象方法</p>
<p>要求：</p>
<ol>
<li><p>属性的返回值类型有下列取值</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要给属性赋值</p>
<ul>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</li>
<li><strong>如果只有一个属性需要赋值，并且属性的名称是value，则vaule可以省略，直接定义值即可</strong></li>
<li><strong>数组赋值时，值使用{ }包裹。如果数组中只有一个值，则{ }省略</strong></li>
</ul>
</li>
</ol>
<h2 id="自定义注解-元注解"><a href="#自定义注解-元注解" class="headerlink" title="自定义注解_元注解"></a>自定义注解_元注解</h2><p>元注解：用于描述注解的注解</p>
<ol>
<li><p>@Target：描述注解能够作用的位置</p>
<ul>
<li>ElementType取值：<ul>
<li>TYPE：作用于类或者接口上</li>
<li>METHOD：作用于方法上</li>
<li>FIELD：作用于成员变量上</li>
<li>ANNOTATION_TYPE：可用于注解类型上（被@interface修饰的类型）</li>
<li>CONSTRUCTOR：可用于构造方法上</li>
<li>LOCAL_VARIABLE：可用于局部变量上</li>
<li>PACKAGE：用于记录java文件的package信息</li>
<li>PARAMETER：可用于参数上</li>
</ul>
</li>
</ul>
</li>
<li><p>@Retention：描述注解被保留的阶段</p>
<ul>
<li>@Retention(RetentinPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVN读取到</li>
</ul>
</li>
<li><p>@Documenten：描述注解是否被抽取到api文档中</p>
</li>
<li><p>@Inherited：描述注解是否被子类继承</p>
</li>
</ol>
<h2 id="使用（解析）注解"><a href="#使用（解析）注解" class="headerlink" title="使用（解析）注解"></a>使用（解析）注解</h2><p>使用（解析）注解：获取注解中定义的属性值</p>
<ol>
<li>获取注解定义的位置的对象    (获取Class对象)</li>
<li>通过Class对象的getAnnotation获取到注解的对象。如：cls.getAnnotation(Anno.class)</li>
<li>通过注解的对象去调用注解中的抽象方法获取配置的属性值</li>
</ol>
<h2 id="案例-简单的测试框架"><a href="#案例-简单的测试框架" class="headerlink" title="案例_简单的测试框架"></a>案例_简单的测试框架</h2><p>当主方法执行后，会自动自行被检测的所有方法（加了Check注解的方法），判断方法是否有异常，记录到文件中</p>
<h2 id="练习代码-1"><a href="#练习代码-1" class="headerlink" title="练习代码"></a>练习代码</h2><p>自定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="comment">//@Target(value = &#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">EnumPerson <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MyAnno2 <span class="title">anno</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] strs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno1(value = 1,age=19,name = &quot;tom&quot;,p= EnumPerson.p1,anno = @MyAnno2,strs = &#123;&quot;tom&quot;,&quot;jack&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotataionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将上面反射的案例中使用配置文件的方式改为使用注解的方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> pro &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pro(className = &quot;com.company.pojo.Person&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotaitonFrameworkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;AnnotaitonFrameworkTest&gt; cls = AnnotaitonFrameworkTest.class;</span><br><span class="line">        pro an = cls.getAnnotation(pro.class);<span class="comment">//原理：其实就是在内存中生成了一个注解接口的子类实现类对象</span></span><br><span class="line">        String className = an.className();</span><br><span class="line">        String methodName = an.methodName();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        aClass.getMethod(methodName).invoke(aClass.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 别人写的计算器类，测试该类有无bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 0 =&quot;</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 - 0 =&quot;</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 * 0 =&quot;</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 / 0 =&quot;</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的测试框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当主方法执行后，会自动自行被检测的所有方法（加了Check注解的方法），判断方法是否有异常，记录到文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Class cls = calc.getClass();</span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//判断方法上是否有Check注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Check.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//有Check注解执行</span></span><br><span class="line">                    method.invoke(calc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//捕获异常，记录到日志中</span></span><br><span class="line">                    num++;</span><br><span class="line">                    bw.write(method.getName() + <span class="string">&quot;方法出异常了&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;异常名称：&quot;</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;异常原因：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.write(<span class="string">&quot;本次测试一共出现&quot;</span> + num + <span class="string">&quot;次异常&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day3（运算符）</title>
    <url>/2021/04/05/StudyNotes_day3/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>算数运算符、赋值运算符、比较运算符、逻辑运算符、三元运算符</p>
<h1 id="算数运算符-加号的多种用法"><a href="#算数运算符-加号的多种用法" class="headerlink" title="算数运算符_加号的多种用法"></a>算数运算符_加号的多种用法</h1><p>四则运算当中的加号“+”有常见的三种用法：</p>
<ol>
<li>对于数值来说，那就是加法</li>
<li>对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算<br>char类型字符，int类型数字，之间的对照关系表：ASCII、Unicode</li>
<li>对于字符串String（首字母大写，不是关键字）来说，加号代表字符串拼接（连接）操作<br> 任何数据类型和字符串进行连接时，结果都会变成字符串</li>
</ol>
<h1 id="算数运算符-自增自减运算符"><a href="#算数运算符-自增自减运算符" class="headerlink" title="算数运算符_自增自减运算符"></a>算数运算符_自增自减运算符</h1><p>自增运算符： ++<br>自减运算符： –</p>
<p>基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1使用格式：写在变量名称之前，或者写在变量名称之后，例如：++num，也可以num++<br>使用方法：<br>      1.单独使用：不和其他操作混合，自己独立成为一个步骤<br>      2.混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等<br>使用区别：<br>      1.在单独使用的时候，前++和后++没有任何区别，也就是 ++num 和 num++ 是完全一样的<br>     2.在混合使用的时候，有【重大区别】<br>          A、如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用      【先加后用】<br>        B、如果是【后++】，难么首先使用变量本来的数值，【然后再让变量+1】    【先用后加】<br>        总计：[先加减，后使用]，[先使用，后加减]</p>
<p>注意事项：<br>     只有变量才能使用自增、自减运算符，常量不可发生改变，所以不能用</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day30(Mysql)</title>
    <url>/2022/01/03/StudyNotes_day30/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><p><strong>关系型数据库：底层是以二维表的及其之间的关系所组成的数据库</strong></p>
<p><strong>非关系(NoSQL)型数据库：键值对数据库，例如：MongoDB、Redis</strong></p>
<p>横：记录。竖：字段</p>
<h2 id="MySQL数据类型及字段约束"><a href="#MySQL数据类型及字段约束" class="headerlink" title="MySQL数据类型及字段约束"></a>MySQL数据类型及字段约束</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL中支持多种整型，其实很大程度上是相同的，只是存储值的大小范围不同而已</p>
<p><strong>tinyint</strong>：占用1个字节，相对于java中的byte</p>
<p><strong>smallint</strong>：占用2个字节，相对于java中的short</p>
<p><strong>int</strong>：占用4个字节，相对于java中的int</p>
<p><strong>bigint</strong>：占用8个字节，相对于java中的long</p>
<p>其次是浮点类型即：float和double类型</p>
<p><strong>float</strong>：4字节单精度浮点类型，相对于java中的float</p>
<p><strong>double</strong>：8字节双精度浮点类型，相对于java中的double</p>
<p><strong>decimal</strong>：对SQL Server而言，Decimal可用来保存具有小数点而且数值确定的数值，精度更高</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>1、char(n)定长字符串，最长255个字符。n表示字符数，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建user表, 指定用户名为char类型，字符长度不超过10</span><br><span class="line">create table user(</span><br><span class="line">	username char(10),</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>所谓的定长，是当插入的值长度小于指定的长度<strong>10</strong>（上面指定的）时, 剩余的空间会用空格填充。（这样会浪费空间）</p>
<p>2、varchar(n) 变长字符串，最长不超过 65535个字节，n表示字符数，一般超过255个字节，会使用text类型，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建user表, 指定用户名为varchar类型，长度不超过10</span><br><span class="line">create table user(</span><br><span class="line">	username varchar(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>3、大文本（长文本）类型</p>
<p>最长65535个字节，一般超过255个字符列的会使用text</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建user表, </span><br><span class="line">create table user(</span><br><span class="line"></span><br><span class="line">	resume text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>另，text也分多种，其中bigtext存储数据的长度约为4GB</p>
<p>总结：char(n)、varchar(n)、text都可以表示字符串类型，其区别在于：</p>
<ol>
<li>char(n)在保存数据时, 如果存入的字符串长度小于指定的长度n，后面会用空格补全，因此可能会造成空间浪费，但是char类型的存储速度较varchar和text快。因此char类型适合存储长度固定的数据，这样就不会有空间浪费，存储效率比后两者还快！</li>
<li>varchar(n)保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用，因此varchar不会浪费空间。<br>因此varchar适合存储长度不固定的数据，这样不会有空间的浪费。</li>
<li>text是大文本类型，一般文本长度超过255个字符，就会使用text类型存储。</li>
</ol>
<h3 id="时间-日期类型"><a href="#时间-日期类型" class="headerlink" title="时间/日期类型"></a>时间/日期类型</h3><ol>
<li>date：年月日</li>
<li>time：时分秒</li>
<li>datetime：年月日 时分秒</li>
<li>timestamp：时间戳(实际存储的是一个时间毫秒值)，与datetime存储日期格式相同。<br>timestamp最大表示2038年，而datetime范围是1000~9999<br>timestamp在插入数、修改数据时，可以自动更新成系统当前时间(后面用到时再做讲解)</li>
</ol>
<h3 id="字段-列-约束"><a href="#字段-列-约束" class="headerlink" title="字段(列)约束"></a>字段(列)约束</h3><p>创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。</p>
<p>1、主键(primary key)</p>
<p>主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号, 例如:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--创建user表,指定id为主键, 作为用户的唯一标识</span><br><span class="line">create table stu(</span><br><span class="line">	id int primary key,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主键的特点： 唯一且不能为空！！！</p>
<p>当主键为数值时，为了方便维护，可以设置主键为自增（auto_increment）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--示例：创建user表,指定id为主键, 并指定主键自增</span><br><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increament,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2、唯一(unique)</p>
<p>保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--示例：创建user表, 指定用户名不能重复</span><br><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increament,</span><br><span class="line">	username varchar(50) unique,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>唯一约束特点是不能重复！！(允许为空)</p>
<p>3、非空(not null)</p>
<p>保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--创建user表, 指定密码不能为空</span><br><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increament,</span><br><span class="line">	username varchar(50) unique,</span><br><span class="line">	password varchar(50) not null,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>非空约束的特点是： 不能为空值， 即插入数据时该列必须得有值！！</p>
<p>4、外键约束</p>
<p>外键是用于表和表之间关系的列，后面在表关系中说明</p>
<h2 id="MySQL建库、建表"><a href="#MySQL建库、建表" class="headerlink" title="MySQL建库、建表"></a>MySQL建库、建表</h2><h3 id="查看数据库、查看数据表"><a href="#查看数据库、查看数据表" class="headerlink" title="查看数据库、查看数据表"></a>查看数据库、查看数据表</h3><p>1、查看mysql服务器中所有数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<p>2、进入某一数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
<p>提示，查看已进入的库：select database();</p>
<p>3、查看当前库中的所有表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<p>提示：mysql数据库不区分大小写</p>
<h3 id="创建数据库、创建数据表"><a href="#创建数据库、创建数据表" class="headerlink" title="创建数据库、创建数据表"></a>创建数据库、创建数据表</h3><p>1、创建数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 删除mydb1库(如果存在)</span><br><span class="line">drop database <span class="keyword">if</span> exists mydb1;</span><br><span class="line">-- 重新创建mydb1库</span><br><span class="line">create database mydb1 charset utf8;</span><br><span class="line">-- 查看、进入mydb1库</span><br><span class="line">show databases;</span><br><span class="line">use mydb1;</span><br></pre></td></tr></table></figure>
<p>提示：创建库时，要记得指定编码</p>
<p>2、创建数据表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 删除stu学生表(如果存在)</span><br><span class="line">drop table <span class="keyword">if</span> exists stu;</span><br><span class="line">-- 创建stu学生表</span><br><span class="line">create table stu(</span><br><span class="line">	id int,				-- 学生编号</span><br><span class="line">	name varchar(20),	-- 学生姓名</span><br><span class="line">	gender char(1),	-- 学生性别</span><br><span class="line">	birthday date,		-- 出生年月</span><br><span class="line">	score double		-- 考试成绩</span><br><span class="line">);</span><br><span class="line">-- 查看表结构</span><br><span class="line">desc stu;</span><br></pre></td></tr></table></figure>
<p>提示：# 和 – 是sql语句的注释符号</p>
<h3 id="更新表记录（insert-update-delete）"><a href="#更新表记录（insert-update-delete）" class="headerlink" title="更新表记录（insert/update/delete）"></a>更新表记录（insert/update/delete）</h3><p>1、insert–插入表记录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">insert into 表名(列1,列2...)  values(值1, 值2...);</span><br><span class="line">-- insert用于向指定的表中插入哪些列, 以及给予哪些值</span><br><span class="line">-- 如果要为所有的列插入值, 可以省略表名后面的列列表，例如：</span><br><span class="line">insert into 表名 values(值1, 值2...);</span><br></pre></td></tr></table></figure>
<p>注意: (1)只能在给所有列插入值时, 才可以省略列列表, 否则会报错</p>
<p>​         (2)在插入值时, 如果没有省略列列表, 那么列列表和值列表要一一对应</p>
<p>​         (3)在插入值时, 如果省略了列列表, 那么值列表中值的顺序要和声明列的顺序一致</p>
<p>​         (4)在插入字符串和日期时, 字符串和日期要用单引号引起来。</p>
<p>解决中文的乱码：在通过CMD访问数据库时，最好一登录就设置 “set names gbk”，即可避免在插入数据时或者查询数据时数据乱码</p>
<p>2、update–修改表记录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 修改stu表中王的成绩，加10分特长分。</span><br><span class="line">update stu <span class="built_in">set</span> score=score+10 <span class="built_in">where</span> name=<span class="string">&#x27;王&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>注意: null值和任何值计算结果还是null, 因此, 可以通过ifnull函数将null置为零对待</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">update stu <span class="built_in">set</span> score=ifnull(score, 0)+10;</span><br></pre></td></tr></table></figure>
<p>3、delete–删除表记录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 删除stu表中的王信息</span><br><span class="line">delete from stu <span class="built_in">where</span> name=<span class="string">&#x27;王&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>若没有where子句, 则默认删除所有记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除emp表中的所有信息</span><br><span class="line">delete from stu;</span><br></pre></td></tr></table></figure>
<h3 id="查询表记录（select）"><a href="#查询表记录（select）" class="headerlink" title="查询表记录（select）"></a>查询表记录（select）</h3><p><strong>查询的五种语法where、group by、having、order by、limit</strong></p>
<p>多条结果用union拼接</p>
<p>1、基础查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询emp表中的所有员工，显示员工姓名、薪资、奖金</span><br><span class="line">select name,sal,bonus from emp;</span><br><span class="line">-- 查询emp表中的所有员工，显示所有列。</span><br><span class="line">select * from emp;</span><br></pre></td></tr></table></figure>
<p>提示： distinct关键字，用于剔除指定列中的重复值，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询emp表中的所有部门，剔除重复的部门</span><br><span class="line">select distinct dept from emp; </span><br></pre></td></tr></table></figure>
<p>2、where子句查询</p>
<p>where和having的区别：但要查询的条件是表中存在的字段时，where和having都可以使用，当使用聚合函数avg（）等，表中没有avg字段，只能用having。</p>
<p>总结：where 后面要跟的是数据表里的字段，where针对数据库文件的发挥作用。而having只是根据前面查询出来的结果集再次进行查询，因此having是针对结果集发挥作用。where在group by前面，having在group by后面。先where再orderby 再limit。</p>
<p>Group By 和 Having, Where ,Order by这些关键字是按照如下顺序进行执行的：Where, Group By, Having, Order by</p>
<p>对表中的所有记录进行筛选、过滤使用where子句</p>
<p>下面的运算符可以在 WHERE 子句中使用：</p>
<p><img src="/screenshot/where%E5%AD%90%E5%8F%A5%E6%9F%A5%E8%AF%A2.png" alt="图片"></p>
<p>SQL练习：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询emp表中薪资大于3000的所有员工，显示员工姓名、薪资</span><br><span class="line">select name,sal from emp <span class="built_in">where</span> sal&gt;3000; </span><br><span class="line">-- 查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资</span><br><span class="line">select name, sal+bonus from emp <span class="built_in">where</span> (sal+bonus)&gt;3000; </span><br><span class="line">-- 或</span><br><span class="line">select name, sal+bonus as 总薪资 from emp <span class="built_in">where</span> (sal+bonus)&gt;3000;</span><br></pre></td></tr></table></figure>
<p>提示：(1)as用于定义别名(仅在查询的结果中作为列的表头显示)，也可以省略as<br>            (2)where子句中不能使用列别名（但是可以使用表别名）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资</span><br><span class="line">select name,sal from emp <span class="built_in">where</span> sal between 3000 and 4500; </span><br><span class="line">-- 查询emp表中姓名中以<span class="string">&quot;刘&quot;</span>开头的员工，显示员工姓名。</span><br><span class="line">select name,sal from emp <span class="built_in">where</span> name like <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line">-- 查询emp表中姓名以<span class="string">&quot;刘&quot;</span>开头，字数为两个字的员工，显示员工姓名。</span><br><span class="line">select * from emp <span class="built_in">where</span> name like <span class="string">&#x27;刘_&#x27;</span>;</span><br><span class="line">-- 查询emp表中姓名中包含<span class="string">&quot;涛&quot;</span>字的员工，显示员工姓名。</span><br><span class="line">select * from emp <span class="built_in">where</span> name like <span class="string">&#x27;%涛%&#x27;</span>;</span><br><span class="line">-- 提示：<span class="string">&quot;%&quot;</span> 表示任意0或多个字符。<span class="string">&quot;_&quot;</span> 表示任意一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询emp表中薪资为1400、1600、1800的员工，显示员工姓名和薪资</span><br><span class="line">select name,sal from emp <span class="built_in">where</span> sal <span class="keyword">in</span>(1400,1600,1800);</span><br><span class="line">-- 查询emp表中薪资小于2000和薪资大于4000的员工，显示员工姓名、薪资。</span><br><span class="line">select name,sal from emp <span class="built_in">where</span> sal&lt;2000 or sal &gt;4000;</span><br><span class="line">-- 查询emp表中薪资大于3000并且奖金小于600的员工，显示姓名、薪资、奖金。</span><br><span class="line">select name,sal,bonus from emp <span class="built_in">where</span> sal&gt;3000 and bonus&lt;600;</span><br></pre></td></tr></table></figure>
<p>3、排序查询</p>
<p>对查询的结果进行排序使用 order by关键字。<br>order by 排序的列 asc    升序 ↑<br>order by 排序的列 desc    降序 ↓</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 对emp表中所有员工的薪资进行升序(从低到高)排序，显示姓名、薪资。</span><br><span class="line">select name,sal from emp order by sal asc;</span><br><span class="line">-- 对emp表中所有员工的总薪资进行降序(从高到低)排序，显示姓名、总薪资。</span><br><span class="line">select name, sal+bonus as 总薪资 from emp order by (sal+bonus) desc;</span><br></pre></td></tr></table></figure>
<p>4、分组查询</p>
<p>对所查询的记录可以根据某一列进行分组, 分组使用group by。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 将员工按照部门进行分组</span><br><span class="line">select * from emp group by dept;</span><br><span class="line">-- 对emp表按照部门进行分组, 并统计每个部门的人数, 显示部门和对应人数</span><br><span class="line">select dept 部门名称, count(*) 部门人数 from emp group by dept;</span><br><span class="line">-- 对emp表按照部门进行分组, 求每个部门的最高薪资(不包含奖金)</span><br><span class="line">select max(sal) 总薪资 from emp group by dept;</span><br></pre></td></tr></table></figure>
<p>注意：分组之前使用聚合函数表示对查询的所有记录进行统计计算</p>
<p>分组之后使用聚合函数表示对每一个组中的所有记录进行统计计算。</p>
<p>5、聚合函数查询</p>
<p>1、max()或min() – 返回某列的最大值或最小值<br>2、count() – 返回某列的行数<br>3、sum() – 返回某列值之和<br>4、avg() – 返回某列的平均值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询emp表中最高薪资</span><br><span class="line">select max(sal) as 最高薪资 from emp;</span><br><span class="line">-- 查询emp表中最高总薪资(薪资加奖金)</span><br><span class="line">select max(sal+bonus) as 最高薪资 from emp;</span><br><span class="line">-- 统计emp表中薪资大于3000的员工人数</span><br><span class="line">select count(*) from emp <span class="built_in">where</span> sal&gt;3000;</span><br><span class="line">-- 统计emp表中所有员工的总薪资(不包含奖金)</span><br><span class="line">select sum(sal) as 员工总薪资 from emp;</span><br><span class="line">-- 统计emp表员工的平均薪资(不包含奖金)</span><br><span class="line">select avg(sal) as 员工总薪资 from emp;</span><br></pre></td></tr></table></figure>
<p><strong>!!重要提示：</strong></p>
<p>a) 可以使用count(*)统计记录行数<br>b) 多个聚合函数可以一起查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 例如:根据部门进行分组，统计每个部门员工人数和平均薪资</span><br><span class="line">select dept, count(*) 员工人数, avg(sal) 平均薪资 from emp group by dept; </span><br></pre></td></tr></table></figure>
<p>c) 聚合函数不能用在where子句中<br>d) 在没有分组的情况下，聚合函数不能和其他普通字段一起查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 例如: 查询emp表中薪资最高的员工姓名, 下面的写法是错的:</span><br><span class="line">select name, max(sal) from emp;--结果是错的</span><br><span class="line">-- 正确的查询：</span><br><span class="line">select name, sal from emp <span class="built_in">where</span> sal=(</span><br><span class="line">	select max(sal) from emp</span><br><span class="line">);-- 子查询</span><br></pre></td></tr></table></figure>
<p>6、其他函数</p>
<p>1、数值函数<br>(1)ceil(数值) – 向上取整<br>(2)floor(数值) – 向下取整<br>(3)round(数值) – 向下取整<br>(4)rand(数值) – 随机数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- emp表中所有员工薪资上涨15.47%, 向上取整。</span><br><span class="line">select name,sal, ceil(sal*1.1547) from emp;</span><br></pre></td></tr></table></figure>
<p>2、日期函数<br>(1)curdate() – 返回当前日期(年月日)<br>(2)curtime() – 返回当前时间(时分秒)<br>(3)now() – 返回当前日期+时间(年月日 时分秒)<br>(4)date_add()、date_sub() – 增加/减少日期<br>(5)year()、month()、day()、hour()、minute()、second()，分别用来获取日期中的年、月、日、时、分、秒</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询系统当前时间</span><br><span class="line">select now();</span><br><span class="line">-- 查询emp表中所有员工的年龄，显示姓名、年龄</span><br><span class="line">select name,year(curdate()) - year(birthday) 年龄 from emp;</span><br><span class="line">-- 查询emp表中所有在1993和1995年出生的，显示姓名、出生日期。</span><br><span class="line">select name,birthday from emp <span class="built_in">where</span> year(birthday) between 1993 and 1995;</span><br></pre></td></tr></table></figure>
<h2 id="外键和表关系"><a href="#外键和表关系" class="headerlink" title="外键和表关系"></a>外键和表关系</h2><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键：唯一标识其他表中的一条记录，用来通知数据库两张表列与列之间的对应关系, 并让数据库帮我们维护这样关系的键就叫做外键。</p>
<p><img src="/screenshot/%E5%A4%96%E9%94%AE.png" alt="图片"></p>
<p>例如：员工表的部门id列（dept_id）和部门表的id列具有一 一对应的关系, 其中dept_id就是外键。</p>
<p>​    外键作用: 确保数据库数据的完整性和一致性</p>
<p>​    添加外键: 例如：foreign key(dept_id) references dept(id)</p>
<h3 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h3><p>1、一对多</p>
<p>一对多，反过来就是多对一，以班级和学生为例：</p>
<p>(1)一个班级中可能会有多个学生(1~*)</p>
<p>(2)一个学生只能属于一个班级(1<del>1)，两者合并结果还是1</del>*</p>
<p>因此，班级表和学生表是一对多的关系</p>
<p>对于一对多的两张表，可以在多的一方添加列，保存一的一方的主键，从而保存两张表之间的关系</p>
<p><img src="/screenshot/%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="图片"></p>
<p>2、一对一</p>
<p>以班级和教室为例：</p>
<p>(1)一个班级对应一个教室(1~1)</p>
<p>(2)一个教室也只对应一个班级(1<del>1)，两者合并结果还是1</del>1</p>
<p>因此，班级表和教室表是一对一的关系</p>
<p>对于一对一关系的两张表，可以在任意一张表中添加列，保存另一张表的主键，从而保存两张表之间的关系</p>
<p><img src="/screenshot/%E4%B8%80%E5%AF%B9%E4%B8%80.png" alt="图片"></p>
<p>3、多对多</p>
<p>以学生和老师为例：</p>
<p>(1)一个学生对应多个老师(1~*)</p>
<p>(2)一个老师也对应多个学生(1<del><em>)，两者合并结果是</em></del>*</p>
<p>因此，学生表和老师表是多对多的关系</p>
<p>对于多对多的关系，可以拆分成两张一对多的关系，无法在两张表中添加列保存关系，但我们可以添加一张第三方的表（专门保存两张表的关系），保存两张表的主键，从而保存两张表的关系。</p>
<p><img src="/screenshot/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png" alt="图片"></p>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">多张表查询的语法：</span><br><span class="line">select... </span><br><span class="line">from A, B... </span><br><span class="line"><span class="built_in">where</span>...</span><br><span class="line"></span><br><span class="line">如果表名过长，可以为表添加别名以方便书写</span><br><span class="line">select... </span><br><span class="line">from A a, B b...</span><br><span class="line"><span class="built_in">where</span>...</span><br><span class="line">上面小写的a和b就是A和B表的别名:</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询部门和部门下的员工。</span><br><span class="line">select * </span><br><span class="line">from dept d,emp e </span><br><span class="line"><span class="built_in">where</span> d.id=e.dept_id;</span><br><span class="line">或</span><br><span class="line">select * </span><br><span class="line">from dept d inner join emp e on d.id=e.dept_id;</span><br><span class="line">上面的查询(inner join...on...)方式也叫做内连接查询</span><br></pre></td></tr></table></figure>
<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>1、左外连接查询</p>
<p>显示左侧表中的所有记录，如果在右侧表中没有对应的记录，则显示为null</p>
<p>语法：</p>
<p>select …</p>
<p>from a <strong>left</strong> <strong>join</strong> b <strong>on</strong> (a.id=b.xid)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询所有部门和部门下的员工，如果部门下没有员工，显示null</span><br><span class="line">select * </span><br><span class="line">from dept d left join emp e on d.id=e.dept_id;</span><br></pre></td></tr></table></figure>
<p>以上结果会显示（左侧表）所有部门，如果某部门下没有员工，（右侧表）则显示为null</p>
<p>2、右外连接查询</p>
<p>显示右侧表中的所有记录，如果在左侧表中没有对应的记录，则显示为null</p>
<p>语法：</p>
<p>select …<br>from a right join b on (a.id=b.xid)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询部门和所有员工，如果员工没有所属部门，显示null</span><br><span class="line">select * </span><br><span class="line">from dept d right join emp e on d.id=e.dept_id;</span><br></pre></td></tr></table></figure>
<p>以上结果会显示（右侧表）所有员工，如果员工没有所属部门，（左侧表）则显示为null</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>所谓的子查询，其实就是将一个查询得出的结果，作为另外一个查询的条件。<br>格式：</p>
<p>select…<br>from…<br>where…(select…from…)</p>
<p>1、列出薪资比’王海涛’高的所有员工，显示姓名、薪资</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先查询出<span class="string">&#x27;王&#x27;</span>的薪资</span><br><span class="line">select sal from emp <span class="built_in">where</span> name=<span class="string">&#x27;王&#x27;</span>;</span><br><span class="line">-- 再查询比王薪资高的员工</span><br><span class="line">select name, sal </span><br><span class="line">from emp </span><br><span class="line"><span class="built_in">where</span> sal&gt;( select sal from emp <span class="built_in">where</span> name=<span class="string">&#x27;王&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>2、列出与’刘’从事相同职位的所有员工，显示姓名、职位、部门。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先关联, 查询员工及员工对应的部门</span><br><span class="line">select e.name, e.job, d.name from emp e, dept d <span class="built_in">where</span> e.dept_id=d.id;</span><br><span class="line">-- 再查询<span class="string">&#x27;刘&#x27;</span>的职位</span><br><span class="line">select name, job from emp <span class="built_in">where</span> name=<span class="string">&#x27;刘&#x27;</span>;</span><br><span class="line">-- 最后筛选, 筛选出和<span class="string">&#x27;刘&#x27;</span>相同职位的员工</span><br><span class="line">select e.name, e.job, d.name from emp e, dept d <span class="built_in">where</span> e.dept_id=d.id and job=(select job from emp <span class="built_in">where</span> name=<span class="string">&#x27;刘&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>3、列出薪资高于在’大数据部’(已知部门编号为30)就职的所有员工的薪资的员工姓名和薪资、部门名称。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 查询出<span class="string">&#x27;大数据部&#x27;</span>的最高薪资</span><br><span class="line">select max(sal) from emp <span class="built_in">where</span> dept_id=30;</span><br><span class="line">-- 关联查询, 查询员工的姓名,薪资, 部门名称</span><br><span class="line">select e.name, e.sal, d.name from emp e, dept d <span class="built_in">where</span> e.dept_id=d.id and sal&gt;(select max(sal) from emp <span class="built_in">where</span> dept_id=30);</span><br></pre></td></tr></table></figure>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>1、（左外连接）列出所有部门和部门下的员工，如果部门下没有员工, 显示为null。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">select d.id, d.name, e.name, e.dept_id </span><br><span class="line">from dept d left join emp e on e.dept_id=d.id;</span><br></pre></td></tr></table></figure>
<p>2、（关联查询）列出在’培优部’任职的员工，假定不知道’培优部’的部门编号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先查询员工及员工所属部门</span><br><span class="line">select e.name, e.dept_id, d.id, d.name </span><br><span class="line">from emp e, dept d </span><br><span class="line"><span class="built_in">where</span> e.dept_id=d.id;</span><br><span class="line">-- 再筛选过滤，查询部门名称为<span class="string">&#x27;培优部&#x27;</span>的员工</span><br><span class="line">select e.name, d.id, d.name </span><br><span class="line">from emp e, dept d </span><br><span class="line"><span class="built_in">where</span> e.dept_id=d.id and d.name=<span class="string">&#x27;培优部&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>3、（自连接查询）列出所有员工及其直接上级，显示员工姓名、上级编号，上级姓名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先查询员工表（emp e1）</span><br><span class="line">select name, topid from emp e1;</span><br><span class="line">-- 再查询上级表（还是员工表，emp e2）</span><br><span class="line">select id, name from emp e2;</span><br><span class="line">-- 最后查询员工及其员工的直接上级</span><br><span class="line">select e1.name,e1.topid, e2.id, e2.name </span><br><span class="line">from emp e1, emp e2 </span><br><span class="line"><span class="built_in">where</span> e1.topid = e2.id;</span><br></pre></td></tr></table></figure>
<p>4、（分组、聚合函数）列出最低薪资大于1500的各种职位，显示职位和该职位最低薪资</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先查询出各种职位的最低薪资</span><br><span class="line">select job, min(sal) 最低薪资 </span><br><span class="line">from emp group by job;</span><br><span class="line">提示：对分组后的记录筛选过滤请使用having替换<span class="built_in">where</span>，并且having书写在最后</span><br><span class="line">-- 再查询出最低薪资&gt;1500的职位</span><br><span class="line">select job, min(sal) 最低薪资 </span><br><span class="line">from emp group by job </span><br><span class="line">having min(sal)&gt;1500;</span><br></pre></td></tr></table></figure>
<p>5、（分组、聚合函数查询）列出在每个部门就职的员工数量、平均工资。显示部门编号、员工数量，平均薪资。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">select dept_id, count(*) 员工数量, avg(sal) 平均薪资 </span><br><span class="line">from emp group by dept_id;</span><br></pre></td></tr></table></figure>
<p>6、（分组、关联、聚合函数查询）查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 先关联查询, 查询出员工和员工对应的部门</span><br><span class="line">select d.id, d.name, d.loc, e.name</span><br><span class="line">from emp e, dept d </span><br><span class="line"><span class="built_in">where</span> e.dept_id=d.id;</span><br><span class="line">-- 再根据部门进行分组, 统计每个部门的员工数量</span><br><span class="line">select d.id, d.name, d.loc, count(*) 员工数量 </span><br><span class="line">from emp e, dept d </span><br><span class="line"><span class="built_in">where</span> e.dept_id=d.id group by e.dept_id;</span><br></pre></td></tr></table></figure>
<p>7、（自连接查询）列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 关联查询</span><br><span class="line">select e1.id, e1.name, d.name </span><br><span class="line">from emp e1, emp e2, dept d </span><br><span class="line"><span class="built_in">where</span> e1.dept_id=d.id and e1.topid=e2.id and e1.hdate &lt; e2.hdate;</span><br></pre></td></tr></table></figure>
<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><h3 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h3><p>1、打开CMD窗口(不要登录)，通过命令备份mydb1数据库<br>    备份命令: mysqldump -u用户名 -p 数据库名字 &gt; 数据文件的位置<br>    例如: mysqldump -uroot -p mydb1 &gt; d:/mydb1.sql</p>
<p>​    输入密码, 如果没有提示错误, 即备份成功, 查询d盘的mydb1.sql文件<br>​    提示: (1)备份数据库的命令后面不要添加分号(;)<br>​    (2)备份数据库只是备份数据库中的表, 不会备份数据库本身</p>
<p>2、登录到MySQL客户端，删除mydb1库<br>    – 删除mydb1库<br>    drop database mydb1;<br>    – 查询所有库, 是否还存在mydb1库<br>    show databases;</p>
<p>​    由于备份时, 没有备份数据库本身, 所以在恢复库中的数据前, 需要先创建好要恢复的库<br>​    – 创建mydb1数据库<br>​    create database mydb1 charset utf8;<br>​    提示: 此时的mydb1库是空的, 没有任何表</p>
<p>3、在CMD窗口中(不要登录)，通过命令恢复mydb1数据库<br>    – 在CMD窗口中(不要登录)<br>    恢复命令: mysql -u用户名 -p 数据库名字 &lt; 数据文件的位置<br>    例如: mysql -uroot -p mydb1 &lt; d:/mydb1.sql</p>
<p>​    输入密码, 如果没有提示错误, 即恢复成功, 下面进行验证</p>
<p>​    – 在登录状态下, 选择mydb1库, 查询其中的表是否恢复了回来<br>​    use mydb1;<br>​    show tables;</p>
<h3 id="取消SQL语句的执行—-c"><a href="#取消SQL语句的执行—-c" class="headerlink" title="取消SQL语句的执行—\c"></a>取消SQL语句的执行—\c</h3><p>当在cmd中书写了SQL语句，又想取消执行，在SQL语句的后面添加一个 \c 可以取消当前SQL语句的执行!!</p>
<h3 id="修改表操作"><a href="#修改表操作" class="headerlink" title="修改表操作"></a>修改表操作</h3><p>现创建学生表：</p>
<p>use test; – 进入test库</p>
<p>drop table if exists stu; – 删除学生表(如果存在)</p>
<p>create table stu( – 创建学生表</p>
<p>​    id int,             – 学生id</p>
<p>​    name varchar(20),    – 学生姓名</p>
<p>​    gender char(1),    – 学生性别</p>
<p>​    birthday date        – 出生年月</p>
<p>);</p>
<p>1、新增列</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 往stu表中添加score列，double类型</span><br><span class="line">alter table stu add score double;</span><br></pre></td></tr></table></figure>
<p>2、修改列</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 修改id列，将id设置为主键</span><br><span class="line">alter table stu modify id int primary key;</span><br><span class="line">-- 修改id列，将id主键设置为自动增长</span><br><span class="line">alter table stu modify id int auto_increment;</span><br></pre></td></tr></table></figure>
<p>3、删除列</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 删除stu表中的score列</span><br><span class="line">alter table stu drop score;</span><br></pre></td></tr></table></figure>
<h3 id="添加或删除主键及自增长"><a href="#添加或删除主键及自增长" class="headerlink" title="添加或删除主键及自增长"></a>添加或删除主键及自增长</h3><p>a) 在建表时，如何为id指定主键约束和自增?<br>b) 建好的表，如何通过修改添加主键约束和自增?<br>c) 如何删除表中的主键约束和自增?</p>
<p>1、创建stu学生表, 不添加主键自增, 查看表结果</p>
<p>use mydb1; – 切换到mydb1库<br>drop table if exists stu; – 删除stu学生表(如果存在)<br>create table stu( – 重建stu学生表, 没有主键自增<br>    id int,<br>    name varchar(20),<br>    gender char(1),<br>    birthday date<br>);<br>desc stu; – 查看表结构</p>
<p>表结构如下: 没有主键约束和自增</p>
<p><img src="/screenshot/%E6%B2%A1%E6%9C%89%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%87%AA%E5%A2%9E.png" alt="图片"></p>
<p>​    </p>
<p>2、如果表没有创建, 或者要删除重建, 在创建时可以指定主键或主键自增</p>
<p>drop table if exists stu; – 删除stu表<br>create table stu( – 重新创建stu表时, 指定主键自增<br>    id int primary key auto_increment,<br>    name varchar(20),<br>    gender char(1),<br>    birthday date<br>);<br>desc stu; – 查看表结构</p>
<p>表结构如下: 已经添加了主键约束和自增</p>
<p><img src="/screenshot/%E5%B7%B2%E7%BB%8F%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%87%AA%E5%A2%9E.png" alt="图片"></p>
<p>​    </p>
<p>3、如果不想删除重建表，也可以通过修改表添加主键或主键自增 </p>
<p>再次执行第1步, 创建stu学生表, 不添加主键自增, 查看表结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 例如: 将stu学生表中的id设置为主键和自动增长</span><br><span class="line">alter table stu modify id int primary key auto_increment;</span><br><span class="line">desc stu; -- 查看表结构</span><br></pre></td></tr></table></figure>
<p><img src="/screenshot/%E5%B7%B2%E7%BB%8F%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%87%AA%E5%A2%9E.png" alt="图片"></p>
<p>如果只添加主键约束, 不设置自增</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">alter table stu modify id int primary key;</span><br></pre></td></tr></table></figure>
<p>如果已经添加主键约束, 仅仅设置自增，但需注意:</p>
<p>(1)如果没有设置主键, 不可添加自增</p>
<p>(2)只有当主键是数值时, 才可以添加自增</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">alter table stu modify id int auto_increment;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>4、如果想删除主键自增</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 删除主键自增时, 要先删除自增</span><br><span class="line">alter table stu modify id int;</span><br><span class="line">-- 再删除主键约束</span><br><span class="line">alter table stu drop primary key;</span><br><span class="line">desc stu; -- 查看表结构</span><br></pre></td></tr></table></figure>
<p><img src="/screenshot/%E6%B2%A1%E6%9C%89%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%87%AA%E5%A2%9E.png" alt="图片"></p>
<h3 id="添加或删除外键约束"><a href="#添加或删除外键约束" class="headerlink" title="添加或删除外键约束"></a>添加或删除外键约束</h3><p>添加外键方式一：建表时添加外键</p>
<p>现有部门表如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建部门表</span><br><span class="line">create table dept(</span><br><span class="line">	id int primary key auto_increment,	-- 部门编号</span><br><span class="line">	name varchar(20)					-- 部门名称</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>要求创建员工表，并在员工表中添加外键关联部门主键</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建员工表</span><br><span class="line">create table emp(</span><br><span class="line">	id int primary key auto_increment,	-- 员工编号</span><br><span class="line">	name varchar(20),					-- 员工姓名</span><br><span class="line">	dept_id int,						-- 部门编号</span><br><span class="line">	foreign key(dept_id) references dept(id) -- 指定dept_id为外键</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>添加外键方式二：建表后添加外键</p>
<p>现有部门表和员工表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建部门表</span><br><span class="line">create table dept(</span><br><span class="line">	id int primary key auto_increment,	-- 部门编号</span><br><span class="line">	name varchar(20)					-- 部门名称</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 创建员工表</span><br><span class="line">create table emp(</span><br><span class="line">	id int primary key auto_increment,	-- 员工编号</span><br><span class="line">	name varchar(20),					-- 员工姓名</span><br><span class="line">	dept_id int							-- 部门编号</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果表已存在，可以使用下面这种方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">alter table emp add constraint fk_dept_id foreign key(dept_id) references dept(id);</span><br></pre></td></tr></table></figure>
<p>其中 add constraint fk_dept_id 表示新增列，列名为fk_dept_id (名字由自己定义)</p>
<p>foreign key(dept_id)中的dept_id为外键</p>
<p>​    </p>
<p>删除外键</p>
<p>首先通过 “show create table 表名”语法，查询含有外键表的建表语句，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">show create table emp;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<p><img src="/screenshot/%E6%9F%A5%E8%AF%A2%E5%90%AB%E6%9C%89%E5%A4%96%E9%94%AE%E8%A1%A8%E7%9A%84%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.png" alt="图片"></p>
<p>其中，emp_ibfk_1是在创建表时，数据库为外键指定的一个名字，删除这个名字即可删除外键关系，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">alter table emp drop foreign key emp_ibfk_1;</span><br></pre></td></tr></table></figure>
<p><img src="/screenshot/%E5%A4%96%E9%94%AE%E5%88%A0%E9%99%A4.png" alt="图片"></p>
<p>外键删除成功！</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一个最小的不可分割的工作单元，事务能够保证一个业务的完整性</p>
<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p>
<p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为<strong>ACID特性</strong>。</p>
<p>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。</p>
<p>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p>
<p>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<p>事务开启：</p>
<p>1.set autocommit = 0;</p>
<p>2.begin;</p>
<p>3.start transction;</p>
<p>事务手动提交：</p>
<p>commit;</p>
<p>事务手动回滚：</p>
<p>rollback;</p>
<p>查询默认提交状态：</p>
<p>select @@autocommit;</p>
<p>0为手动提交，1为自动提交（默认）</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<p>1、<strong>READ UNCOMMITTED</strong>（读未提交数据）</p>
<p>安全级别最低, 可能出现任何事务并发问题(比如脏读、不可以重复读、幻读等)</p>
<p>性能最好（不使用!!）</p>
<p>2、<strong>READ COMMITTED</strong>（读已提交数据）（Oracle默认）</p>
<p>防止<strong>脏读</strong>，没有处理不可重复读，也没有处理幻读；</p>
<p>性能比REPEATABLE READ好</p>
<p>3、<strong>REPEATABLE READ</strong>（可重复读）（MySQL默认）</p>
<p>防止<strong>脏读</strong>和<strong>不可重复读</strong>，不能处理幻读问题；</p>
<p>性能比SERIALIZABLE好</p>
<p>4、<strong>SERIALIZABLE</strong>（串行化）</p>
<p>不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；</p>
<p>性能最差；</p>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。</span><br><span class="line">+--------------------------------+</span><br><span class="line"></span><br><span class="line">-- MySQL 5.x</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;</span><br><span class="line">SELECT @@TX_ISOLATION;</span><br></pre></td></tr></table></figure>
<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">-- 查询系统隔离级别，发现已经被修改。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-UNCOMMITTED               |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>


<p>(1)<strong>脏读</strong>（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据；</p>
<p>例如：A给B转账100元但未提交事务，在B查询后，A做了回滚操作，那么B查询到了A未提交的数据，就称之为脏读。</p>
<p>(2)<strong>不可重复读</strong>（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改（是针对修改操作）</p>
<p>例如：在事务1中，前后两次查询A账户的金额，在两次查询之间，另一事物2对A账户的金额做了修改，此种情况可能会导致事务1中，前后两次查询的结果不一致。这就是不可重复度</p>
<p>(3)<strong>幻读（虚读）</strong>（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录(是针对插入或删除操作)；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) set tx_isolation&#x3D;&#39;read-uncommitted&#39;;　</span><br><span class="line"></span><br><span class="line">安全性最差，容易出现脏读、不可重复读、幻觉读，但性能最高</span><br><span class="line"></span><br><span class="line">(2) set tx_isolation&#x3D;&#39;read-committed&#39;;</span><br><span class="line"></span><br><span class="line">安全性一般，可防止脏读，但容易出现不可重复读、幻读</span><br><span class="line"></span><br><span class="line">(3) set tx_isolation&#x3D;&#39;repeatable-read&#39;;</span><br><span class="line"></span><br><span class="line">安全性较好，可防止脏读、不可重复读，但是容易出现幻读</span><br><span class="line"></span><br><span class="line">(4) set tx_isolation&#x3D;&#39;serialiable&#39;;</span><br><span class="line"></span><br><span class="line">安全性最好，可以防止一切事务并发问题，但是性能最差。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaEE</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>StudyNotes_day32(Git)</title>
    <url>/2022/01/20/StudyNotes_day32/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般来说，团队合作开发的话，每个人都需要在自己的功能分支 feat/XXX 上开发，最后一起合并到总的开发分支 dev 上，然后将开发分支 dev 合并到测试分支上，最后将测试分支合并到正式发布分支上。</p>
<p>其中总的开发分支一般叫做 dev 分支，正式发布分支一般是叫 main/master/release 分支。</p>
<p><img src="/screenshot/image-20220118141526543.png" alt="图片"></p>
<p>比如说有 A、B、C 三个人协助进行功能开发：</p>
<ol>
<li>首先 A、B、C 三位小伙伴从总开发分支 Dev 上开辟自己的功能分支，分别是 feat/AXXX、feat/BXXX、feat/CXXX，也就是图中 feat/AXXX、feat/BXXX、feat/CXXX 的三条线；</li>
<li>然后在自己的开发机上进行开发，这里的开发机可以是本地环境也可以是一些云端的开发机。开发完毕后，再分别合到总开发分支 dev 上，也就是图中蓝色的三条线，在这个过程中可能会产生一些代码冲突，挨个 solve 即可；</li>
<li>接着在 dev 分支上确认所有功能开发完毕，进行简单自测，fix 一些 bug 后再向测试分支上进行合并；</li>
<li>这个时候就可以艾特测试组的同学来进行测试，测试通过后再合到 master 分支进行发布。</li>
</ol>
<p>一般来说，基本的流程就是这样的，不同公司或许其中流程有些出入，不过问题不大，大致方向是如此的。</p>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p><img src="/screenshot/image-20220118142757623.png" alt="图片"></p>
<p>命令如下：</p>
<p>clone（克隆）: 从远程仓库中克隆代码到本地仓库<br>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订<br>add（添加）: 在提交前先将代码提交到暂存区<br>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本<br>fetch (抓取) ： 从远程库抓取到本地仓库，不进行任何的合并动作，一般操作比较少。<br>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge<br>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</p>
<h2 id="Git安装与环境配置"><a href="#Git安装与环境配置" class="headerlink" title="Git安装与环境配置"></a>Git安装与环境配置</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>去 <a href="https://git-scm.com/">Git官网</a> 下载 64-bit Git for Windows Setup</p>
<p>检验是否安装成功：回到电脑桌面，鼠标右击如果看到Git GUI Here和Git Bash Here则安装成功</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><ul>
<li><p>设置用户信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;XXX&quot;</span> 		<span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;XXXX&quot;</span> 		<span class="comment"># 设置邮箱</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看配置信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>
<h4 id="为常用指令配置别名"><a href="#为常用指令配置别名" class="headerlink" title="为常用指令配置别名"></a>为常用指令配置别名</h4></li>
</ul>
<p>有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。</p>
<ol>
<li><p>打开用户目录，创建 .bashrc 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>在<code> .bashrc</code>文件中输入如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于输出git提交日志 </span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span> </span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息 </span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开gitBash，执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库：</p>
<ol>
<li>在电脑的任意位置创建一个空目录作为我们的本地Git仓库</li>
<li>进入这个目录中，点击右键打开Git bash窗口</li>
<li>执行命令git init</li>
<li>如果创建成功后可在文件夹下看到<strong>隐藏的.git</strong>目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git的命令而发生变化。</p>
<p><img src="/screenshot/image-20220118144908667.png" alt="图片"></p>
<p>本章节主要讲解如何使用命令来控制这些状态之间的转换：</p>
<ol>
<li>git add (工作区 —&gt; 暂存区)</li>
<li>git commit (暂存区 —&gt; 本地仓库)</li>
</ol>
<h3 id="status查看修改的状态"><a href="#status查看修改的状态" class="headerlink" title="status查看修改的状态"></a>status查看修改的状态</h3><ul>
<li><p>作用：查看修改的状态（暂存区、工作区）</p>
</li>
<li><p>命令形式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h3 id="add添加工作区到暂存区"><a href="#add添加工作区到暂存区" class="headerlink" title="add添加工作区到暂存区"></a>add添加工作区到暂存区</h3></li>
<li><p>作用：添加工作区一个或多个文件的修改到暂存区</p>
</li>
<li><p>命令形式：git add 单个文件名（或通配符）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add file.txt 	<span class="comment"># 添加单个文件</span></span><br><span class="line">git add . 		<span class="comment"># 将所有修改加入暂存区</span></span><br></pre></td></tr></table></figure>
<h3 id="commit提交暂存区到本地仓库"><a href="#commit提交暂存区到本地仓库" class="headerlink" title="commit提交暂存区到本地仓库"></a>commit提交暂存区到本地仓库</h3></li>
<li><p>作用：提交暂存区内容到本地仓库的当前分支</p>
</li>
<li><p>命令形式：git commit -m ‘注释内容’</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;XXX update&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="log查看提交日志"><a href="#log查看提交日志" class="headerlink" title="log查看提交日志"></a>log查看提交日志</h3></li>
</ul>
<p>配置的别名<code>git-log</code>就包含了这些参数，所以后续可以直接使用指令 <code>git-log</code></p>
<ul>
<li>作用:查看提交记录</li>
<li>命令形式：git log [option] 或者 git-log<ul>
<li>–all 显示所有分支</li>
<li>–pretty=oneline 将提交信息显示为一行</li>
<li>–abbrev-commit 使得输出的commitId更简短</li>
<li>–graph 以图的形式显示</li>
</ul>
</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li><p>作用：版本切换</p>
</li>
<li><p>命令形式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard commitID	<span class="comment"># commitID 版本号可以使用 git-log 或 git log 指令查看</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何查看已经删除的记录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reflog	<span class="comment">#这个指令可以看到已经删除的提交记录</span></span><br></pre></td></tr></table></figure>
<h3 id="添加文件至忽略列表"><a href="#添加文件至忽略列表" class="headerlink" title="添加文件至忽略列表"></a>添加文件至忽略列表</h3></li>
</ul>
<p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <code>.gitignore</code> 的文件（文件名称固定），列出要忽略的文件模式。</p>
<p><code>.gitignore</code>内容：</p>
<p>*.txt<br>*.iml</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h3 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>
<p>我们还可以直接切换到一个不存在的分支（创建并切换）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>一个分支上的提交可以合并到另一个分支，默认把其他分支合并到master</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>不能删除当前分支，只能删除其他分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名 			<span class="comment"># 删除分支时，需要做各种检查</span></span><br><span class="line">git branch -D 分支名 			<span class="comment"># 不做任何检查，强制删除</span></span><br></pre></td></tr></table></figure>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p>
<ol>
<li>处理文件中冲突的地方</li>
<li>将解决完冲突的文件加入暂存区(add)</li>
<li>提交到仓库(commit)</li>
</ol>
<h3 id="开发中分支使用原则与流程"><a href="#开发中分支使用原则与流程" class="headerlink" title="开发中分支使用原则与流程"></a>开发中分支使用原则与流程</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<p>在开发中，一般有如下分支使用原则与流程：</p>
<ul>
<li>master （生产） 分支：线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</li>
<li>develop（开发）分支：是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支，准备上线。</li>
<li>feature/xxxx分支：从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支，之后该分支可以删除。</li>
<li>hotfix/xxxx分支：从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支。</li>
</ul>
<p>还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。</p>
<p><img src="/screenshot/image-20220118170619389.png" alt="图片"></p>
<h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><h3 id="常用的托管服务（远程仓库）"><a href="#常用的托管服务（远程仓库）" class="headerlink" title="常用的托管服务（远程仓库）"></a>常用的托管服务（远程仓库）</h3><p>前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<ul>
<li><p>GitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHub</p>
</li>
<li><p>码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p>
</li>
<li><p>GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，一般用于在企业、学校等内部网络搭建git私服。</p>
</li>
</ul>
<h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>在gitee官网注册账号，并新建一个仓库</p>
<h3 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h3><p>不是随便什么都可以推送到自己建的远程参数，要么输入账号和密码，要么配置SSH公钥</p>
<ul>
<li><p>生成SSH公钥（可以使用github的SSH公钥）</p>
<ul>
<li>ssh-keygen -t rsa</li>
<li>不断回车<ul>
<li>如果公钥已经存在，则自动覆盖</li>
</ul>
</li>
</ul>
</li>
<li><p>Gitee设置账户共公钥</p>
<ul>
<li>获取公钥<ul>
<li>cat ~/.ssh/id_rsa.pub</li>
</ul>
</li>
<li><img src="/screenshot/100904.png" alt="图片"></li>
<li>验证是否配置成功<ul>
<li>ssh -T <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x65;&#x65;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x65;&#x65;&#46;&#99;&#111;&#x6d;</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h3><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><ul>
<li><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远端名称&gt; &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>远端名称：默认是<code>origin</code>，取决于远端服务器设置</li>
<li>仓库地址：从远端服务器获取此url</li>
<li>例如：git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;</a>:czbk_zhang_meng/git_test.git</li>
</ul>
</li>
</ul>
<p><img src="/screenshot/image-20220119170243218.png" alt="图片"></p>
<h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><ul>
<li><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4></li>
<li><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push [-f] [--set-upstream] [远端名称] [本地分支名][:远端分支名]</span><br></pre></td></tr></table></figure>
<ul>
<li>如果远程分支名和本地分支名相同，则可以只写本地分支名<ul>
<li>git push origin master</li>
</ul>
</li>
<li><code>-f</code>  表示强制推送，<strong>一般在公司内没有这个的使用权限</strong>，否则容易冲掉远程仓库的所有代码</li>
<li><code>--set-upstream</code> 推送到远端的同时，建立起和远端分支的关联关系。用于第一次推送时。<ul>
<li>git push –set-upstream origin master</li>
</ul>
</li>
<li>如果当前分支已经和远端分支关联，则可以省略分支名和远端名<ul>
<li>git push 将master分支推送到已关联的远端分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/screenshot/103656.png" alt="图片"></p>
<h4 id="查看本地分支与远程分支的绑定关系"><a href="#查看本地分支与远程分支的绑定关系" class="headerlink" title="查看本地分支与远程分支的绑定关系"></a>查看本地分支与远程分支的绑定关系</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<p><img src="/screenshot/image-20220119171618826.png" alt="图片"></p>
<p>此时尚未有绑定关系</p>
<p>将本地分支master和远程分支master绑定关系</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master:master</span><br></pre></td></tr></table></figure>
<p><img src="/screenshot/image-20220119171841320.png" alt="图片"></p>
<p>发现本地分支master已经和远程分支master绑定成功</p>
<p>此时本地分支master若要推送到远程分支master上，则可直接使用命令：<code>git push</code></p>
<h4 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接clone到本地。</p>
<ul>
<li><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库地址&gt; [本地目录]</span><br></pre></td></tr></table></figure>
<p>本地目录可以省略，会自动生成一个目录</p>
</li>
</ul>
<h4 id="从远程仓库中抓取和拉取"><a href="#从远程仓库中抓取和拉取" class="headerlink" title="从远程仓库中抓取和拉取"></a>从远程仓库中抓取和拉取</h4><p>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。</p>
<ul>
<li>抓取命令：<ul>
<li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li>
<li>如果不指定远端名称和分支名，则抓取所有分支。</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch [remote name] [branch name]</span><br></pre></td></tr></table></figure>
<ul>
<li>拉取命令：<ul>
<li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，<strong>等同于fetch+merge</strong></li>
<li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull [remote name] [branch name]</span><br></pre></td></tr></table></figure>
<h4 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h4><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。</p>
<p>A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支，如下图所示。</p>
<p><img src="/screenshot/image-20220119174403295.png" alt="图片"></p>
<p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。</p>
<p><strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong>，在此不再赘述。</p>
<h2 id="IDEA中的Git使用"><a href="#IDEA中的Git使用" class="headerlink" title="IDEA中的Git使用"></a>IDEA中的Git使用</h2><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p><img src="/screenshot/%E9%85%8D%E7%BD%AEGit.png" alt="图片"></p>
<h3 id="在IDEA中操作Git"><a href="#在IDEA中操作Git" class="headerlink" title="在IDEA中操作Git"></a>在IDEA中操作Git</h3><p>场景：本地已经有一个项目，但是并不是git项目，我们需要将这个放到码云的仓库里，和其他开发人员继续一起协作开发。</p>
<h4 id="创建项目的远程仓库"><a href="#创建项目的远程仓库" class="headerlink" title="创建项目的远程仓库"></a>创建项目的远程仓库</h4><p>略</p>
<h4 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h4><p><img src="/screenshot/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="图片"></p>
<h4 id="设置远程仓库"><a href="#设置远程仓库" class="headerlink" title="设置远程仓库"></a>设置远程仓库</h4><p><img src="/screenshot/%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png" alt="图片"></p>
<h4 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h4><p><img src="/screenshot/%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="图片"></p>
<h4 id="推送到远程仓库-1"><a href="#推送到远程仓库-1" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p><img src="/screenshot/%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png" alt="图片"></p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><ul>
<li><p>方法一：最常规的方式</p>
<p><img src="/screenshot/image-20220119190427959.png" alt="图片"></p>
</li>
<li><p>方法2：最强大的方式</p>
<p><img src="/screenshot/image-20220119190603175.png" alt="图片"></p>
</li>
</ul>
<h3 id="IDEA常用GIT操作入口"><a href="#IDEA常用GIT操作入口" class="headerlink" title="IDEA常用GIT操作入口"></a>IDEA常用GIT操作入口</h3><p>1.第一张图上的快捷入口可以基本满足开发的需求</p>
<p><img src="/screenshot/GIT%E6%93%8D%E4%BD%9C%E5%85%A5%E5%8F%A31.png" alt="图片"></p>
<p>2.第二张图是更多在IDEA操作git的入口</p>
<p><img src="/screenshot/GIT%E6%93%8D%E4%BD%9C%E5%85%A5%E5%8F%A32.png" alt="图片"></p>
<h3 id="IDEA集成GitBash代替Terminal"><a href="#IDEA集成GitBash代替Terminal" class="headerlink" title="IDEA集成GitBash代替Terminal"></a>IDEA集成GitBash代替Terminal</h3><p><img src="/screenshot/idea%E9%9B%86%E6%88%90GitBash%E4%BB%A3%E6%9B%BFTerminal.png" alt="图片"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在IDEA的终端中可使用git命令来完成以上所有功能</li>
<li><strong>先拉取pull，提示合并失败就解决合并冲突，再推送push</strong></li>
</ul>
]]></content>
      <categories>
        <category>javaEE</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>StudyNotes_day31(Linux)</title>
    <url>/2022/01/18/StudyNotes_day31/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>常见的执行Linux命令的格式是下面这样的</p>
<blockquote>
<p><strong>命令名称   [命令参数]   [命令对象]</strong></p>
</blockquote>
<p>命令参数为缩写字母用：—</p>
<p>命令参数为完整的单词：— —</p>
<h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><ul>
<li>pwd；当前位置的绝对路径</li>
<li>uname -a：查看内核</li>
<li>echo：打印，类似于java中的syso打印语句</li>
<li>clear：清屏</li>
<li>history：历史命令</li>
</ul>
<h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h2><h3 id="2-1-关机和重启"><a href="#2-1-关机和重启" class="headerlink" title="2.1 关机和重启"></a>2.1 关机和重启</h3><p>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p>
<h3 id="2-2-帮助命令"><a href="#2-2-帮助命令" class="headerlink" title="2.2 帮助命令"></a>2.2 帮助命令</h3><p>–help命令<br>shutdown –help：<br>ifconfig  –help：查看网卡信息</p>
<p>man命令（命令说明书）<br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p>
<h2 id="三、目录操作命令"><a href="#三、目录操作命令" class="headerlink" title="三、目录操作命令"></a>三、目录操作命令</h2><h3 id="3-1-目录切换-cd"><a href="#3-1-目录切换-cd" class="headerlink" title="3.1 目录切换 cd"></a>3.1 目录切换 cd</h3><p>命令：cd 目录</p>
<p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p>
<h3 id="3-2-目录查看-ls-al"><a href="#3-2-目录查看-ls-al" class="headerlink" title="3.2 目录查看 ls [-al]"></a>3.2 目录查看 ls [-al]</h3><p>命令：ls [-al]</p>
<p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p>
<h3 id="3-3-目录操作【增，删，改，查】"><a href="#3-3-目录操作【增，删，改，查】" class="headerlink" title="3.3 目录操作【增，删，改，查】"></a>3.3 目录操作【增，删，改，查】</h3><h4 id="3-3-1-创建目录【增】-mkdir"><a href="#3-3-1-创建目录【增】-mkdir" class="headerlink" title="3.3.1 创建目录【增】 mkdir"></a>3.3.1 创建目录【增】 mkdir</h4><p>命令：mkdir 目录</p>
<p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p>
<p>mkdir -p c/cc/ccc    在当前目录下创建一个c目录，在c目录里创建一个cc目录，在cc目录里创建一个ccc目录</p>
<h4 id="3-3-2-删除目录或文件【删】rm"><a href="#3-3-2-删除目录或文件【删】rm" class="headerlink" title="3.3.2 删除目录或文件【删】rm"></a>3.3.2 删除目录或文件【删】rm</h4><p>命令：rm [-rf] 目录</p>
<p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p>
<p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p>
<p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p>
<h4 id="3-3-3-目录修改【改】mv-和-cp"><a href="#3-3-3-目录修改【改】mv-和-cp" class="headerlink" title="3.3.3 目录修改【改】mv 和 cp"></a>3.3.3 目录修改【改】mv 和 cp</h4><p>一、重命名目录<br>    命令：mv 当前目录  新目录<br>    例如：mv aaa bbb    将目录aaa改为bbb<br>    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p>
<p>二、剪切目录<br>    命令：mv 目录名称 目录的新位置<br>    示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr<br>    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<p>三、拷贝目录<br>    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归<br>    示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr<br>    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p>
<h4 id="3-3-4-搜索目录【查】find"><a href="#3-3-4-搜索目录【查】find" class="headerlink" title="3.3.4 搜索目录【查】find"></a>3.3.4 搜索目录【查】find</h4><p>命令：find 目录 参数 文件名称<br>示例：find /usr/tmp -name ‘a*’    查找/usr/tmp目录下的所有以a开头的目录或文件</p>
<h2 id="四、文件操作命令"><a href="#四、文件操作命令" class="headerlink" title="四、文件操作命令"></a>四、文件操作命令</h2><h3 id="4-1-文件操作【增，删，改，查】"><a href="#4-1-文件操作【增，删，改，查】" class="headerlink" title="4.1 文件操作【增，删，改，查】"></a>4.1 文件操作【增，删，改，查】</h3><h4 id="4-1-1-新建文件【增】touch"><a href="#4-1-1-新建文件【增】touch" class="headerlink" title="4.1.1 新建文件【增】touch"></a>4.1.1 新建文件【增】touch</h4><p>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p>
<h4 id="4-1-2-删除文件-【删】-rm"><a href="#4-1-2-删除文件-【删】-rm" class="headerlink" title="4.1.2 删除文件 【删】 rm"></a>4.1.2 删除文件 【删】 rm</h4><p>命令：rm -rf 文件名</p>
<h4 id="4-1-3-修改文件【改】-vi或vim"><a href="#4-1-3-修改文件【改】-vi或vim" class="headerlink" title="4.1.3 修改文件【改】 vi或vim"></a>4.1.3 修改文件【改】 vi或vim</h4><p>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>
<ol>
<li>命令行模式command mode）<br>   控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>   命令行模式下的常用命令：<br>   【1】控制光标移动：↑，↓，j<br>   【2】删除当前行：dd<br>   【3】查找：/字符<br>   【4】进入编辑模式：i o a<br>   【5】进入底行模式：:</li>
<li>编辑模式（Insert mode）<br>   只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>   编辑模式下常用命令：<br>   【1】ESC 退出编辑模式到命令行模式；</li>
<li>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：<br>  【1】退出编辑：   :q<br>  【2】强制退出：   :q!<br>  【3】保存并退出：  :wq</li>
</ol>
<p>打开文件</p>
<p>命令：vi 文件名<br>示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</p>
<p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p>
<p>编辑文件</p>
<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p>
<p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>
<p>保存或者取消编辑</p>
<p>保存文件：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p>
<p>取消编辑：</p>
<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>
<h4 id="4-1-4-文件的查看【查】"><a href="#4-1-4-文件的查看【查】" class="headerlink" title="4.1.4 文件的查看【查】"></a>4.1.4 文件的查看【查】</h4><p>文件的查看命令：cat/more/less/tail</p>
<p>cat：看最后一屏</p>
<p>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf</p>
<p>more：百分比显示</p>
<p>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p>
<p>less：翻页查看</p>
<p>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p>
<p>tail：指定行数或者动态查看</p>
<p>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>
<h3 id="4-2-权限修改"><a href="#4-2-权限修改" class="headerlink" title="4.2 权限修改"></a>4.2 权限修改</h3><p>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>
<p>示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是- rw- — —</p>
<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限四、压缩文件操作</p>
<h2 id="五、压缩文件操作"><a href="#五、压缩文件操作" class="headerlink" title="五、压缩文件操作"></a>五、压缩文件操作</h2><h3 id="5-1-打包和压缩"><a href="#5-1-打包和压缩" class="headerlink" title="5.1 打包和压缩"></a>5.1 打包和压缩</h3><p>linux中的打包文件：aa.tar<br>linux中的压缩文件：bb.gz<br>linux中打包并压缩的文件：.tar.gz</p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p>
<p>示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar<br>tar -zcvf ab.tar aa.txt bb.txt<br>或：tar -zcvf ab.tar  *</p>
<h3 id="5-2-解压"><a href="#5-2-解压" class="headerlink" title="5.2 解压"></a>5.2 解压</h3><p>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压</p>
<h2 id="六、查找命令"><a href="#六、查找命令" class="headerlink" title="六、查找命令"></a>六、查找命令</h2><h3 id="6-1-grep"><a href="#6-1-grep" class="headerlink" title="6.1 grep"></a>6.1 grep</h3><p>grep命令是一种强大的文本搜索工具</p>
<p>使用实例：</p>
<p>grep root  /etc/passwd  在文件中查找关键字root</p>
<p>grep root  /etc/passwd  –-color     高亮显示</p>
<p>grep root  /etc/passwd  –A5 –B5     高亮显示，A后5行，B前5行</p>
<p>grep -n root /etc/passwd  查找并显示行数</p>
<p>grep -v root /etc/passwd  取反，查出不含root的数据</p>
<h3 id="6-2-find"><a href="#6-2-find" class="headerlink" title="6.2 find"></a>6.2 find</h3><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p>
<p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>
<p>使用实例：</p>
<p>find . -name “*.log” -ls  在当前目录查找以.log结尾的文件，并显示详细信息。<br>find . -size +100M  查找当前目录大于100M的文件</p>
<h3 id="6-3-whereis"><a href="#6-3-whereis" class="headerlink" title="6.3 whereis"></a>6.3 whereis</h3><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p>
<p>使用实例：</p>
<p>whereis ls    将和ls文件相关的文件都查找出来</p>
<h3 id="6-4-which"><a href="#6-4-which" class="headerlink" title="6.4 which"></a>6.4 which</h3><p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。查看安装位置</p>
<p>使用实例：</p>
<p>which pwd  查找pwd命令所在路径 </p>
<p>which java  查找path中java的路径</p>
<h2 id="七、其他命令"><a href="#七、其他命令" class="headerlink" title="七、其他命令"></a>七、其他命令</h2><ul>
<li><p>shh：连接远程服务器</p>
</li>
<li><p>git clone：拉取项目代码</p>
</li>
<li><p>ps -ef   查看所有正在运行的进程</p>
</li>
<li><p>ps -ef | grep java  查找java服务进程（|为管道符）</p>
</li>
<li><p>kill pid 或者 kill -9 pid(强制杀死进程)      pid:进程号</p>
</li>
<li><p>nohup  程序 &amp;：后台启动程序</p>
</li>
<li><p>jobs：查看后台程序</p>
</li>
<li><p>du -sh *：查看项目占用空间</p>
</li>
<li><p>netstat：查看端口</p>
</li>
<li><p>curl url：获取该网址的文本信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javaEE</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>StudyNotes_day5（流程控制）</title>
    <url>/2021/05/31/StudyNotes_day5/</url>
    <content><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ol>
<li><p><strong>什么是流程控制</strong></p>
<p>流程控制是指“程序代码执行的顺序”，即这些代码哪行先执行，哪行后执行，某行执行完了之后再执行哪行</p>
</li>
<li><p><strong>流程控制的结构</strong></p>
<blockquote>
<p>顺序: 从上到下执行代码<br>选择: 有选择的执行代码<br>循环: 循环执行某一段代码</p>
</blockquote>
<p>由图灵提出，图灵认为世界上任何复杂的问题，总可以用上面三种流程控制进行编程实现.(这个可以证明的)</p>
</li>
</ol>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h5 id="判断语句：if语句"><a href="#判断语句：if语句" class="headerlink" title="判断语句：if语句"></a>判断语句：if语句</h5><ul>
<li>if语句第一种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句第二种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句第三种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">	执行语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择语句：switch语句"><a href="#选择语句：switch语句" class="headerlink" title="选择语句：switch语句"></a>选择语句：switch语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul>
<li>for</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①;布尔表达式②;步进表达式④)&#123;</span><br><span class="line">	循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">	循环体③</span><br><span class="line">	步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do-while</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	循环体③</span><br><span class="line">	步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②)</span><br></pre></td></tr></table></figure>
<p>break</p>
<p>continue</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day6（方法）</title>
    <url>/2021/09/08/StudyNotes_day6/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h2><p>定义方法的完整格式：</p>
<p>​    </p>
<p>修饰符     返回值类型      方法名称      (参数类型     参数名称）{<br>            方法体；<br>            return 返回值；<br>}</p>
<p>​    </p>
<p>修饰符：public    static</p>
<p>返回值类型：也就是方法最终产生的数据是什么类型</p>
<p>方法名称：方法的名字，规则和变量一样，小驼峰</p>
<p>参数类型：进入方法的数据是什么类型</p>
<p>参数名称：进入方法的数据对应的变量名称</p>
<p>ps:参数如果有多个，使用逗号进行分隔</p>
<p>方法体：方法需要做的事情，若干行代码</p>
<p>return:两个作用，第一停止当前方法，第二讲后面的返回值还给调用处</p>
<p>返回值：也就是方法执行后最终产生的数据结果</p>
<p>注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”保持对应。</p>
<p>​    </p>
<p>方法三要素：</p>
<p>返回值类型</p>
<p>方法名</p>
<p>参数列表</p>
<p>​    </p>
<p>方法调用的三种格式：</p>
<p>1.单独调用：方法名称(参数);</p>
<p>2.打印调用：System.out.println(方法名称（参数）);</p>
<p>3.赋值调用：数据类型    变量名称    =    方法名称(参数)；</p>
<p>​        </p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>方法重载（overload）:多个方法的名称一样，但是参数列表不一样</p>
<p>好处：只需要记住唯一一个方法名，就可以实现类似的多个功能</p>
<p>​    </p>
<p>方法重载与下列因素相关：</p>
<p>1.参数个数不同</p>
<p>2.参数类型不同</p>
<p>3.参数的多类型顺序不同</p>
<p>​    </p>
<p>方法重载与下列因素无关：</p>
<p>1.与参数的名称无关</p>
<p>2.与方法的返回值类型无关</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day4（运算符）</title>
    <url>/2021/05/05/StudyNotes_day4/</url>
    <content><![CDATA[<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>与（并且）    &amp;&amp;    全都是true,才是true；否则就是false</p>
<p>或（或者）    ||    至少一个是true,就是true；全都是false，才是false</p>
<p>非（取反）    ！    本来是true,变成false；本来是false,变成true</p>
<p>与”&amp;&amp;”，或”||”，具有短路效果；如果根据左边已经判断得到最终结果，那么右边的代码将不再执行，从而节省一定性能。</p>
<p>注意事项：</p>
<p>1.逻辑运算符只能用于boolean值</p>
<p>2.与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可</p>
<p>3.与、或两种运算符，如果有多个条件，可以连续写</p>
<p>两个条件：条件A    &amp;&amp;    条件B</p>
<p>多个条件：条件A    &amp;&amp;    条件B    &amp;&amp;    条件C</p>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反！、自增++、自减–</p>
<p>二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=</p>
<p>三元运算符：需要三个数据才可以进行操作的运算符。</p>
<p>格式：</p>
<p>数据类型    变量名称    =    条件判断    ？    表达式A    ：    表达式B;</p>
<p>流程：</p>
<p>首先判断条件是否成立：</p>
<p>​        如果成立为true，那么将表达式A的值赋值给左侧的变量；</p>
<p>​        如果成立为false，那么将表达式B的值赋值给左侧的变量；</p>
<p>二者选其一。</p>
<p>注意事项：</p>
<p>1.必须同时保证表达式A和表达式B都符合左侧数据类型的要求</p>
<p>2.三元运算符的结果必须被使用</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day8（面向对象）</title>
    <url>/2021/09/12/StudyNotes_day8/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象思想的概述"><a href="#面向对象思想的概述" class="headerlink" title="面向对象思想的概述"></a>面向对象思想的概述</h2><p>面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节</p>
<p>面向对象：但需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事</p>
<p>​    </p>
<p>面向过程：强调步骤</p>
<p>面向对象：强调对象</p>
<p>​    </p>
<p>特点：</p>
<p>面向对象思想是一种更符合我们思考习惯的思想，他可以将复杂的事情简单化，并将我们从执行者变成了指挥者</p>
<p>​    </p>
<p>面向对象三大基本特征：封装、继承、多态</p>
<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul>
<li><p>类：是一组相关属性和行为的集合，可以看成是一类事物的模板，使用事物的属性特征和行为来描述该类事物</p>
</li>
<li><p>属性：就是该事物的状态信息</p>
</li>
<li><p>行为：就是该事物能够做什么</p>
</li>
</ul>
<p>举例：小猫</p>
<p>​        属性：名字、体重、年龄、颜色</p>
<p>​        行为：走、跑、叫</p>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li>对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为</li>
</ul>
<p>现实中，一类事物的一个实例：一只小猫</p>
<p>举例：一只小猫</p>
<p>​        属性：tom、5kg、2years、yellow</p>
<p>​        行为：溜墙根走、蹦跶的跑、喵喵叫</p>
<h3 id="类和对象的关系-1"><a href="#类和对象的关系-1" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul>
<li><p>类是对一类事物的描述，是<strong>抽象的</strong></p>
</li>
<li><p>对象是一类事物的实例，是<strong>具体的</strong></p>
</li>
<li><p><strong>类是对象的模板，对象是类的实例</strong></p>
</li>
</ul>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h3><p>现实世界的一类事物：</p>
<p>​        <strong>属性</strong>：事物的状态信息</p>
<p>​        <strong>行为</strong>：事物能够做什么</p>
<p>java中class描述事物也是如此：</p>
<p>​        <strong>成员变量</strong>：对应事物的<strong>属性</strong></p>
<p>​        <strong>成员方法</strong>：对象事物的<strong>行为</strong></p>
<h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>1.成员变量是直接定义在类当中的，在方法外边</p>
<p>2.成员方法不要写static</p>
<h2 id="对象的创建及其使用"><a href="#对象的创建及其使用" class="headerlink" title="对象的创建及其使用"></a>对象的创建及其使用</h2><p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用</p>
<p>1.导包：也就是指出需要使用的类，在什么位置</p>
<p>import 包名称.类名称</p>
<p>import com.company.demo.Student;</p>
<p>对于和当前类属于同一个包的情况，可以省略导包语句</p>
<p>​    </p>
<p>2.创建，格式：</p>
<p>类名称    对象名称    =    new    类名称（）；</p>
<p>Student    stu    =    new    Student();</p>
<p>​    </p>
<p>3.使用，分为两种情况</p>
<p>使用成员变量：对象名.成员变量</p>
<p>使用成员方法：对象名.成员方法（参数）</p>
<p>（也就是，想用谁，就用对象名点儿谁。）</p>
<h2 id="使用对象类型作为方法的参数"><a href="#使用对象类型作为方法的参数" class="headerlink" title="使用对象类型作为方法的参数"></a>使用对象类型作为方法的参数</h2><p>当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象地址值</p>
<h2 id="使用对象类型作为方法的返回值"><a href="#使用对象类型作为方法的返回值" class="headerlink" title="使用对象类型作为方法的返回值"></a>使用对象类型作为方法的返回值</h2><p>当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值</p>
<h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>1.定义的位置不一样</p>
<p>局部变量：在方法的内部</p>
<p>成员变量：在方法的外边，直接写在类当中</p>
<p>​    </p>
<p>2.作用范围不一样</p>
<p>局部变量：只有方法当中才可以使用，出了方法就不能再用</p>
<p>成员变量：整个类都可以通用</p>
<p>​    </p>
<p>3.默认值不一样</p>
<p>局部变量：没有默认值，如果要想使用，必须手动进行赋值</p>
<p>成员变量：如果没有赋值，会有默认值，规则和数组一样</p>
<p>​    </p>
<p>4.内存的位置不一样</p>
<p>局部变量：位于栈内存</p>
<p>成员变量：位于堆内存</p>
<p>​    </p>
<p>5.生命周期不一样</p>
<p>局部变量：随着方法进栈而诞生，随着方法出栈而消失</p>
<p>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day7（数组）</title>
    <url>/2021/09/11/StudyNotes_day7/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的概念：是一种容器，可以同时存放多个数据值</p>
<p>​    </p>
<p>数组的特点：</p>
<p>1.数组是一种引用类型</p>
<p>2.数组当中的多个数据，类型必须统一</p>
<p>3.数组的长度在程序运行期间不可改变</p>
<p>​    </p>
<p>动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数</p>
<p>静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定</p>
<p>​    </p>
<h2 id="数组的定义格式-动态初始化"><a href="#数组的定义格式-动态初始化" class="headerlink" title="数组的定义格式_动态初始化"></a>数组的定义格式_动态初始化</h2><p>数据类型[]    数组名称    =    new    数据类型[数组长度];</p>
<p>​    </p>
<p>解析含义:</p>
<p>左侧数据类型：也就是数组当中存放的数据，全都是统一的什么类型</p>
<p>左侧的中括号：代表是一个数组</p>
<p>左侧数组名称：给数组取一个名字</p>
<p>右侧的new：代表创建数组的动作</p>
<p>右侧数据类型：必须和左边的数据类型保持一致</p>
<p>右侧中括号的长度：也就是数组中，到底可以保存多少个数据，是一个int数字</p>
<p>​    </p>
<h2 id="数组的定义格式-静态初始化"><a href="#数组的定义格式-静态初始化" class="headerlink" title="数组的定义格式_静态初始化"></a>数组的定义格式_静态初始化</h2><p>数据类型[]    数组名称    =    new    数据类型[]{ 元素1, 元素2, …};</p>
<p>​    </p>
<p>注意事项：</p>
<p>虽然静态初始化没有直接告诉长度，但是根据大括号里面的具体内容，也可以算出长度</p>
<p>​    </p>
<h2 id="数组的定义格式-省略的静态初始化"><a href="#数组的定义格式-省略的静态初始化" class="headerlink" title="数组的定义格式_省略的静态初始化"></a>数组的定义格式_省略的静态初始化</h2><p>数据类型[]    数组名称    =    { 元素1, 元素2, …};</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.动态初始化和静态初始化标准格式可以拆分成两个步骤</p>
<p>2.静态初始化一旦使用省略格式，就不能拆分成两个步骤</p>
<p>​    </p>
<h2 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h2><p>格式：数组名称[索引值]</p>
<p>索引值从0开始，一直到“数组长度-1”为止</p>
<h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>格式：数组名称.length</p>
<p>​    </p>
<h2 id="数组的遍历输出"><a href="#数组的遍历输出" class="headerlink" title="数组的遍历输出"></a>数组的遍历输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">	System.out.println(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array.fori</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="数组作为方法参数-传递地址"><a href="#数组作为方法参数-传递地址" class="headerlink" title="数组作为方法参数_传递地址"></a>数组作为方法参数_传递地址</h2><p>数组可以作为方法的参数</p>
<p>当调用方法时候，向方法的小括号进行传参，传递进去的其实是数组的地址值</p>
<p>​    </p>
<h2 id="数组作为方法返回值-返回地址"><a href="#数组作为方法返回值-返回地址" class="headerlink" title="数组作为方法返回值_返回地址"></a>数组作为方法返回值_返回地址</h2><p>任何数据类型都能作为方法的参数类型，或者返回值类型</p>
<p>数组作为方法的参数，传递进去的其实是数组的地址值</p>
<p>数组作为方法的返回值，返回的其实也是数组的地址值</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day9（封装）</title>
    <url>/2021/09/12/StudyNotes_day9/</url>
    <content><![CDATA[<h1 id="面向对象三大特征之封装性"><a href="#面向对象三大特征之封装性" class="headerlink" title="面向对象三大特征之封装性"></a>面向对象三大特征之封装性</h1><p>面向对象三大特征：封装、继承、多态</p>
<p>​    </p>
<p>封装性在Java当中的体现：</p>
<p>1.方法就是一种封装</p>
<p>2.关键字private也是一种封装</p>
<p>​    </p>
<p>封装就是将一些细节信息隐藏起来，对于外界不可见</p>
<h2 id="private关键字的作用及使用"><a href="#private关键字的作用及使用" class="headerlink" title="private关键字的作用及使用"></a>private关键字的作用及使用</h2><p>一旦使用了private进行修饰，那么本类当中仍然可以随意访问</p>
<p>但是超出了本类范围之外就不能直接访问</p>
<p>private关键字提高代码的安全性</p>
<p>​    </p>
<p>间接访问private成员变量，就是定义一对Getter/Setter方法</p>
<p>必须叫setXxx或getXxx命名规则</p>
<p>对于Getter，不能有参数，返回值类型和成员变量对应</p>
<p>对于Setter，不能有返回值，参数类型和成员变量对应</p>
<h2 id="this关键字的作用"><a href="#this关键字的作用" class="headerlink" title="this关键字的作用"></a>this关键字的作用</h2><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量</p>
<p>如果需要访问本类当中的成员变量，需要使用格式：</p>
<p>this.成员变量名</p>
<p>​    </p>
<p>“通过谁调用的方法，谁就是this”</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是专门用来创建对象的方法，当通过关键字new来创建对象时，其实就是在调用构造方法</p>
<p>格式：</p>
<p>public 类名称（参数类型    参数名称）{</p>
<p>​    方法体</p>
<p>}</p>
<h2 id="定义一个标准的类"><a href="#定义一个标准的类" class="headerlink" title="定义一个标准的类"></a>定义一个标准的类</h2><p>一个标准的类通常要拥有下面四个组成部分：</p>
<p>​    </p>
<p>1.所有的成员变量都要使用private关键字来修饰</p>
<p>2.为每一个成员变量编写一对儿Getter/Setter方法</p>
<p>3.编写一个无参数的构造方法</p>
<p>4.编写一个全参数的构造方法</p>
<p>​    </p>
<p>这样标准的类也叫做Java Bean</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Windows容易忘记但好用的快捷键</title>
    <url>/2021/02/14/Windows%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Windows容易忘记但好用的快捷键"><a href="#Windows容易忘记但好用的快捷键" class="headerlink" title="Windows容易忘记但好用的快捷键"></a>Windows容易忘记但好用的快捷键</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win+Shift+S				Windows自带截图</span><br><span class="line">Win+PrintScreen				截取当前屏幕到剪贴板，并保存截屏图片文件到“图片”文件夹中</span><br><span class="line">win+v					粘贴板</span><br><span class="line">Win+D					显示桌面</span><br><span class="line">Win+E					打开文件管理器</span><br><span class="line">Win+I					打开Windows10设置</span><br><span class="line">Win+S					搜索</span><br><span class="line">Win+T					快速切换任务栏程序</span><br><span class="line">Win+Ctrl+D				创建一个新的虚拟桌面</span><br><span class="line">Win+Ctrl+左&#x2F;右	   	   		切换虚拟桌面</span><br><span class="line">Win+Ctrl+F4			  	关闭虚拟桌面</span><br><span class="line">Ctrl+Shift+Esc				开任务管理</span><br><span class="line">Ctrl+Shift+N				新建文件夹</span><br><span class="line">shift+del				彻底删除</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一篇博文</title>
    <url>/2021/02/11/%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h2 id="建站（折腾）历程"><a href="#建站（折腾）历程" class="headerlink" title="建站（折腾）历程"></a>建站（折腾）历程</h2><p>​    建这个博客的起因是想记录和总结学到的知识点，其实自己并没有记录和总结的习惯，一个教训就是之前学习java没有及时总结到后期忘记前面的知识点复习起来很痛苦，这次我在边复习java和学习新的知识时边在自己的博客上做些总结。</p>
<p>​    这个博客是用hexo博客框架搭建的，并部署到了自己的Github上，第一个使用的主题是diaspora，很好看的一个主题，修改后搭建了一个自己的ACG主题博客。博客的搭建和部署过程还是比较的顺利，但主题是真的折腾了好久，还是有部分配置不会弄。下一篇博客会总结下hexo+github方式搭建博客。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>java</tag>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的Dos命令</title>
    <url>/2021/02/13/%E5%9F%BA%E6%9C%AC%E7%9A%84Dos%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h1><h2 id="盘符切换"><a href="#盘符切换" class="headerlink" title="盘符切换"></a>盘符切换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d:			#格式 &quot;需要切换的盘符：&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir 			#查看当前目录下的所有文件</span><br></pre></td></tr></table></figure>
<h2 id="切换目录-change-directory"><a href="#切换目录-change-directory" class="headerlink" title="切换目录(change directory)"></a>切换目录(change directory)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">cd &#x2F;d f:		#切换到f盘 &#x2F;d 是参数		   </span><br><span class="line">cd..			#返回上一级</span><br><span class="line">cd\ 			#返回根目录</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md		创建目录   ( mkdir )</span><br><span class="line">rd		删除空目录  ( rmdir )</span><br><span class="line">	</span><br><span class="line">rd&#x2F;s&#x2F;q 盘符:\某个文件夹  （强制删除文件文件夹和文件夹内所有文件）</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd&gt;		创建文件 （ cd&gt;a.txt ）	</span><br><span class="line">del		删除文件 （ del a.txt ）	</span><br><span class="line">	</span><br><span class="line">del&#x2F;f&#x2F;s&#x2F;q 盘符:\文件名  （强制删除文件，文件名必须加文件后缀名）</span><br></pre></td></tr></table></figure>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy 源文件 新文件位置</span><br><span class="line"></span><br><span class="line">	将当前目录下的 1.txt 文件复制到 bak 目录下，</span><br><span class="line">	就输入 copy 1.txt bak\</span><br><span class="line">	</span><br><span class="line">	将当前目录下的 1.txt 这个文件复制到 bak 目录下，</span><br><span class="line">	并且更名为 a.txt，就输入 copy 1.txt bak\a.txt</span><br></pre></td></tr></table></figure>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move D:\a.txt F:\</span><br></pre></td></tr></table></figure>
<h2 id="清屏（clear-screen-）"><a href="#清屏（clear-screen-）" class="headerlink" title="清屏（clear screen ）"></a>清屏（clear screen ）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure>
<h2 id="退出终端"><a href="#退出终端" class="headerlink" title="退出终端"></a>退出终端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="查看电脑的ip"><a href="#查看电脑的ip" class="headerlink" title="查看电脑的ip"></a>查看电脑的ip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<h2 id="打开应用"><a href="#打开应用" class="headerlink" title="打开应用"></a>打开应用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc			计算器</span><br><span class="line">mspaint			画板</span><br><span class="line">notepad			记事本</span><br><span class="line">control			控制面板</span><br><span class="line">dxdiag			DirectX诊断工具</span><br></pre></td></tr></table></figure>
<h2 id="shutdown-命令"><a href="#shutdown-命令" class="headerlink" title="shutdown 命令"></a>shutdown 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown -s -t 0		#-s参数：关机	-t参数：执行时间</span><br><span class="line">shutdown -r -t 0		#重启</span><br><span class="line">shutdown -l			#注销</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Dos</category>
      </categories>
  </entry>
</search>
