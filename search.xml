<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo搭建博客+部署Github</title>
    <url>/2021/02/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E9%83%A8%E7%BD%B2Github/</url>
    <content><![CDATA[<h1 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>去 <a href="https://git-scm.com/">Git官网</a> 下载 64-bit Git for Windows Setup</p>
<p>检验是否安装成功：回到电脑桌面，鼠标右击如果看到Git GUI Here和Git Bash Here则安装成功</p>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><strong>Git安装之后需要进行一些基本信息设置</strong>     <strong>打开Git Bash</strong> </p>
<ul>
<li>设置用户名：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  config --global  user.name  &#39;github的用户名&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置用户邮箱：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  config --global  user.email  &#39;注册时候的邮箱&#39;</span><br></pre></td></tr></table></figure>
<p>注意：该配置会在github主页上显示谁提交了该文件</p>
<ul>
<li>配置ok之后，我们用如下命令来看看是否配置成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>注意：git  config –global 参数，有了这个参数表示这台机器上所有的git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和邮箱</p>
<p><strong>配置SSH key</strong></p>
<p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。如果使用SSH，就可以记住用户名，并创建属于自己的密码来保证安全操作，还有神奇的一招可以“不用输入密码”</p>
<ol>
<li>检查本机已存在的ssh密钥</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建一对新的SSH密钥(keys)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>
<p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa</p>
<p>接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码)</p>
<p>最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key:将刚复制的内容粘贴到key那里，title随便填，保存</p>
<ol start="3">
<li>测试是否成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，如果看到下面信息，就说明成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>去 <a href="https://nodejs.org/en/">Node.js官网</a> 下载 Windows (x64) 长期支持版 Long Term Support (LTS) schedule</p>
<p>安装完成后打开 Git Bash 查看版本号验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">v14.15.5</span><br></pre></td></tr></table></figure>
<p>Node.js 中自带了 npm 包管理工具，在 Git Bash 中查看 npm 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line">6.14.11</span><br></pre></td></tr></table></figure>
<p>由于 npm 代码仓库的服务器在国外，为了下载速度快使用淘宝的 npm 代码仓库，通过 npm 安装 cnpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>查看版本验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>打开 Git Bash，使用 cnpm 安装 Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>Hexo 安装完成后,在本地磁盘新建Blog目录，如：D:\Programming\Blog ，这个目录存放的东西就是以后操作博客的东西</p>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>进入Blog目录，右键 Git Bash Here ,初始化命令只用一次，后面不会再用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure>
<p>此时，会在 Blogs 目录下生成相应的项目文件</p>
<p>需要记住的几个常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  #清理缓存文件</span><br><span class="line">hexo  g     #生成博客静态文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d     #上传到服务器</span><br></pre></td></tr></table></figure>
<h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo  s</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:4000/">http://localhost:4000</a> </p>
<p>这样就可以在本地4000端口查看自己的博客了，初始自带默认主体。</p>
<p>至此完成了 Hexo 搭建博客，接下来部署到 Github 上，就可以通过外网访问自己的博客了。</p>
<h1 id="部署Github"><a href="#部署Github" class="headerlink" title="部署Github"></a>部署Github</h1><p>首先登录 GitHub，创建新 public 仓库，仓库名称一定要是自己昵称+github.io</p>
<p>接下来在Blog目录下安装一个hexo部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>找到Blog文件中的  _config.yml  文件,使用编译器打开,拉到最下面找到并修改deploy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>更改以后进行保存</p>
<p>将本地文件部署到github新建的仓库中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo  d</span><br></pre></td></tr></table></figure>
<p>通过访问  自己的仓库名  就可以访问部署到github上的blog了</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Learn-Markdown</title>
    <url>/2021/02/11/Learn-Markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+空格+一级标题</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##+空格+二级标题</span><br></pre></td></tr></table></figure>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>Hello,World</em>       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体：两边加*</span><br></pre></td></tr></table></figure>
<p><strong>Hello,World</strong>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">粗体：两边加**</span><br></pre></td></tr></table></figure>
<p><strong><em>Hello,World</em></strong>      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体加粗：两边加***</span><br></pre></td></tr></table></figure>
<p><del>Hello,World</del>       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">废弃：两边加~~</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>test    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用 </span><br></pre></td></tr></table></figure>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---或***</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="www.baidu.com">百度</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[名称]+（地址）</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="http://i1.hdslb.com/bfs/archive/27783c10b1cd234cee180a34a88903a2dabc24eb.jpg@380w_240h_100Q_1c.webp" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![名称]+（本地地址或虚拟地址）</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.+空格</span><br></pre></td></tr></table></figure>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-+空格</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th>名字</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>java</td>
<td>26</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 名字 | 年龄 |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">| java | 26 |</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···+java : tab上面的 ·</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Markdowm</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day1</title>
    <url>/2021/02/15/StudyNotes_day1/</url>
    <content><![CDATA[<h1 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h1><p>位（bit）：一个数字0或1，代表一位，数据存储的最小单位</p>
<p>字节（Byte）：每逢8位是一个字节</p>
<p>1 Byte = 8 bit</p>
<p>1 KB = 1024 Byte</p>
<p>1 MB = 1024 KB</p>
<h1 id="字节与字符的区别"><a href="#字节与字符的区别" class="headerlink" title="字节与字符的区别"></a>字节与字符的区别</h1><p>字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。</p>
<p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
<p>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</p>
<p>数字和字符的对照关系表（编码表）</p>
<h1 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h1><p>关键字：是电脑语言里事先定义的，有特别意义的标识符</p>
<p>关键字特征：完全小写的字母，在编辑器中有颜色</p>
<p>String不是关键字，是数据类型中的引用类型，是java中的一个类</p>
<p>标识符：自定义内容，比如类的名字、方法的名字和变量的名字等</p>
<p>标识符的命名规则：（硬性要求）</p>
<ul>
<li>标识符可以包含26个英文字母（区分大小写）、0-9数字、$(美元符号)和 _（下划线）</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字</li>
</ul>
<p>标识符的命名规范：（软性建议）</p>
<ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式），HelloWorld</li>
<li>变量名规范：首字母小写，后面每个单词首字母小写（小驼峰式），helloWorld</li>
<li>方法名规范：同变量名</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java的数据类型分为两大类</p>
<ul>
<li>基本类型：整数、浮点数、字符、布尔</li>
<li>引用类型：类、接口、数组、字符串(String)、Lambda</li>
</ul>
<p>数据类型转换</p>
<p>​    低——————————————————————&gt;高</p>
<p>​    byte,short,char——&gt;int——&gt;long——&gt;float——&gt;double</p>
<p>自动转换：低到高</p>
<p>强制转换：高到低    （类型）变量名</p>
<p>注意点：</p>
<ul>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换成不相干的类型</li>
<li>在把高容量转到低容量的时候，强制转换</li>
<li>转换的时候可能存在内存溢出，或者精度问题</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day10</title>
    <url>/2021/09/13/StudyNotes_day10/</url>
    <content><![CDATA[<h2 id="标识符的命名规范"><a href="#标识符的命名规范" class="headerlink" title="标识符的命名规范"></a>标识符的命名规范</h2><ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式），HelloWorld</li>
<li>变量名规范：首字母小写，后面每个单词首字母小写（小驼峰式），helloWorld</li>
<li>方法名规范：同变量名</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li><p>变量创建格式：</p>
<p>数据类型 变量名称 = 数据值；</p>
</li>
<li><p>数组创建格式：</p>
<p>数据类型[] 数组名称 = new 数据类型[数组长度];</p>
<p>数据类型[] 数组名称 = new 数据类型[]{ 元素1, 元素2, …};</p>
<p>数据类型[] 数组名称 = { 元素1, 元素2, …};</p>
</li>
<li><p>对象创建格式：</p>
<p>类名称 对象名称 = new 类名称（）；</p>
</li>
<li><p>集合:</p>
</li>
</ul>
<p>new一个对象就是new一个类的构造方法</p>
<p>new     调用的是构造方法</p>
<p>对象名.（点）    掉用的是成员方法</p>
<p>非静态方法使用，要先创建此方法所在类的对象，通过对象名称去调用</p>
<p>静态方法直接用类名去调用，不用创建对象</p>
<p>​    </p>
<p>需要特殊方式获取实现类：</p>
<ul>
<li><p>Calendar为抽象类。调用其中的静态方法，返回子类对象</p>
<p>static Calendar getInstance():使用默认时区和语言环境获得一个日历</p>
</li>
<li><p>Iterator            Collection接口中的    iterator( )    获取迭代器实现类对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day11</title>
    <url>/2021/09/14/StudyNotes_day11/</url>
    <content><![CDATA[<h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><h2 id="ArrayList集合概述和基本使用"><a href="#ArrayList集合概述和基本使用" class="headerlink" title="ArrayList集合概述和基本使用"></a>ArrayList集合概述和基本使用</h2><p>数组的长度不可发生改变</p>
<p>但是ArrayList集合的长度是可以随意变化的</p>
<p>对于ArrayList来说，有一个尖括号<E>代表泛型</p>
<p>泛型：也就是装在集合当中的所有元素，全都是统一的类型</p>
<p>注意：泛型只能是引用类型，不能是基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放字符串类型数据</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//存放int类型数据</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容</p>
<p>如果内容是空，得到的是空的中括号：[ ]</p>
<h2 id="ArrayList集合的常用方法和遍历"><a href="#ArrayList集合的常用方法和遍历" class="headerlink" title="ArrayList集合的常用方法和遍历"></a>ArrayList集合的常用方法和遍历</h2><p>ArrayList当中的常用方法有：</p>
<p>​    </p>
<p>public boolean add(E e)向集合当中添加元素，参数的类型和泛型一致，返回值代表添加是否成功</p>
<p>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可以不用</p>
<p>但对于其他集合来说，add添加动作就不一定成功</p>
<p>public E get(int index)从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</p>
<p>public E remove(int index)从集合当中删除元素，参数是索引编号，返回值就是删除掉的元素</p>
<p>public int size()获取集合尺寸长度，返回值是集合中包含的元素个数</p>
<h2 id="ArrayList集合存储基本数据类型"><a href="#ArrayList集合存储基本数据类型" class="headerlink" title="ArrayList集合存储基本数据类型"></a>ArrayList集合存储基本数据类型</h2><p>如果要向集合ArrayList当中存储基本类型的数据，必须使用基本类型对应的“包装类”</p>
<p>​    </p>
<p>基本类型        包装类型（引用类型，包装类都位于java.lang包下）</p>
<p>byte                  Byte</p>
<p>short                Short</p>
<p>int                     Integer    【特殊】</p>
<p>long                  Long</p>
<p>floot                 Floot</p>
<p>double             Double</p>
<p>char                 Character    【特殊】</p>
<p>boolean           Boolean</p>
<p>​    </p>
<p>从JDK1.5+开始，支持自动装箱、自动拆箱</p>
<p>自动装箱：基本类型    ——&gt;    包装类型</p>
<p>自动拆箱：包装类型    ——&gt;    基本类型</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day12</title>
    <url>/2021/09/15/StudyNotes_day12/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串概述和特点"><a href="#字符串概述和特点" class="headerlink" title="字符串概述和特点"></a>字符串概述和特点</h2><p>java.lang.String类代表字符串</p>
<p>API当中说：Java程序中的所有字符串字母值（如“abc”）都作为此类的实例实现</p>
<p>其实就是说：程序当中所有的双引号字符串，都是String类的对象（就算没有new,也照样是）</p>
<p>​    </p>
<p>字符串的特点：</p>
<p>1.字符串的内容永不可变【重点】</p>
<p>2.正因为字符串不可改变，所以字符串是可以共享的</p>
<p>3.字符串效果上相当于char[ ]字符数组，但是底层原理是byte[ ]字节数组</p>
<h2 id="字符串的构造方法和直接创建"><a href="#字符串的构造方法和直接创建" class="headerlink" title="字符串的构造方法和直接创建"></a>字符串的构造方法和直接创建</h2><p>创建字符串的常见3+1种方式：</p>
<p>三种构造方法：</p>
<p>public String()：创建一个空白字符串，不含任何内容</p>
<p>public String(char[ ] array)：根据字符数组的内容，来创建对应的字符串</p>
<p>public String(byte[ ] array)：根据字节数组的内容，来创建对应的字符串</p>
<p>一种直接创建：</p>
<p>String str = “Hello”; //右边直接用双引号</p>
<p>注意：直接写上双引号，就是字符串对象</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>1.对于引用类型来说，==进行的是地址值的比较</p>
<p>2.双引号直接写的字符串在常量池当中，new的不在池当中</p>
<h2 id="字符串的比较方法"><a href="#字符串的比较方法" class="headerlink" title="字符串的比较方法"></a>字符串的比较方法</h2><p>==是进行对象的地址值的比较，如果确实需要字符串的内容比较，可以使用两个方法：</p>
<p>public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串且内容相同的才会给true，否则返回false</p>
<p>注意事项：</p>
<p><strong>1.任何对象都能用Object进行接收</strong></p>
<p>2.equals方法具有对称性，也就是a.equals(b)和b.equals(a)等效</p>
<p>3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面</p>
<p>推荐：“abc”.equals(str)    不推荐：str.equals(“abc”)当str=null时出现空指针异常</p>
<p>​    </p>
<p>public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较</p>
<h2 id="字符串的获取相关方法"><a href="#字符串的获取相关方法" class="headerlink" title="字符串的获取相关方法"></a>字符串的获取相关方法</h2><p>public int length()：获取字符串当中含有的字符个数，拿到字符串长度</p>
<p>public String concat(String str)：将当前字符串和参数字符串拼接，返回值新的字符串</p>
<p>public char charAt(int index)：获取指定索引位置的单个字符（索引从0开始）</p>
<p>public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的位置，如果没有返回-1值</p>
<h2 id="字符串的截取方法"><a href="#字符串的截取方法" class="headerlink" title="字符串的截取方法"></a>字符串的截取方法</h2><p>public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串</p>
<p>public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串</p>
<p>备注：[begin, end )，包含左边，不包含右边</p>
<h2 id="字符串的转换相关方法"><a href="#字符串的转换相关方法" class="headerlink" title="字符串的转换相关方法"></a>字符串的转换相关方法</h2><p>public char[ ] toCharArray()：将当前字符串拆分成为字符数组作为返回值</p>
<p>public byte[ ] getBytes()：获得当前字符串底层的字节数组</p>
<p>public String replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串</p>
<h2 id="字符串的分割方法"><a href="#字符串的分割方法" class="headerlink" title="字符串的分割方法"></a>字符串的分割方法</h2><p>public String[ ] split(String regex)：按照参数的规则，将字符串切分成为若干部分</p>
<p>注意事项：</p>
<p>split方法的参数是一个正则表达式</p>
<h1 id="静态static关键字"><a href="#静态static关键字" class="headerlink" title="静态static关键字"></a>静态static关键字</h1><p>概述：一旦用了static 关键字，那么这样的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份</p>
<p>无论是成员变量，还是成员方法，如果有了static，都推荐使用类名称进行调用</p>
<p>静态变量：类名称. 静态变量</p>
<p>静态方法：类名称. 静态方法（）</p>
<p>注意事项：</p>
<p>1.静态不能直接访问非静态</p>
<p>原因：在内存当中时【先】有的静态内容，【后】有的非静态内容</p>
<p>“先人不知道后人，但是后人知道先人”</p>
<p>2.静态方法当中不能用this</p>
<p>原因：this代表当前对象，通过谁调用的方法，谁就是当前对象</p>
<p>静态代码块：</p>
<p>格式：</p>
<p>public class 类名称{</p>
<p>​    static {</p>
<p>​        //静态代码的内容</p>
<p>​    }</p>
<p>}</p>
<p>特点：当第一次用到本类时，静态代码块执行唯一的一次</p>
<p>静态内容总是优先于非静态，所以静态代码比构造方法先执行</p>
<p>​    </p>
<p>静态代码块的典型用途：</p>
<p>用来一次性地对静态成员变量进行赋值</p>
<h1 id="数组工具类Arrays"><a href="#数组工具类Arrays" class="headerlink" title="数组工具类Arrays"></a>数组工具类Arrays</h1><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作</p>
<p>​    </p>
<p>public static String toString(数组)：将参赛数组变成字符串，按照默认格式：[元素1， 元素2， 元素3 … ]</p>
<p>public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序</p>
<p>备注：</p>
<p>1.如果是数值，sort默认按照数值升序</p>
<p>2.如果是字符串，sort默认按照字母升序</p>
<p>3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持</p>
<h1 id="数学工具类Math"><a href="#数学工具类Math" class="headerlink" title="数学工具类Math"></a>数学工具类Math</h1><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作</p>
<p>public static double abs(double num)：获取绝对值</p>
<p>public static double ceil(double num)：向上取整</p>
<p>public static double floor(double num)：向下取整</p>
<p>public static long round(double num)：四舍五入</p>
<p>Math.PI代表近似的圆周率常量</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day13</title>
    <url>/2021/09/23/StudyNotes_day13/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的概述"><a href="#继承的概述" class="headerlink" title="继承的概述"></a>继承的概述</h2><p>面向对象的三大特征：封装性、继承性、多态性</p>
<p>继承是多态的前提，如果没有继承，就没有多态</p>
<p>继承主要解决的问题就是：共性抽取</p>
<p>父类，也可以叫基类、超类</p>
<p>子类，也可以叫派生类</p>
<p>​    </p>
<p>继承关系当中的特点：</p>
<p>1.子类可以拥有父类的“内容”</p>
<p>2.子类还可以拥有自己专有的内容</p>
<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><p>在继承的关系中，“子类就是一个父类”，也就是说，子类可以被当做父类看待</p>
<p>例如：父类是员工Employee，子类是讲师Teacher，那么“讲师就是一个员工”，关系：is - a</p>
<p>​    </p>
<p>定义父类的格式：（一个普通的类定义）</p>
<p>public class 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<p>定义子类的格式</p>
<p>public class 子类名称 extends 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<h2 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h2><p>在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</p>
<p>​    </p>
<p>直接通过子类对象访问成员变量：</p>
<p>​        等号左边是谁，就优先用谁，没有则向上找</p>
<p>间接通过成员方法访问成员变量：</p>
<p>​        该方法属于谁，就优先用谁，没有则向上找</p>
<h2 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h2><p>局部变量：                直接写</p>
<p>本来的成员变量：    this.成员变量</p>
<p>父类的成员变量：    super.成员变量</p>
<h2 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h2><p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</p>
<p>​        创建的对象是谁，就优先用谁，如果没有则向上找</p>
<p>注意思想：</p>
<p>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类</p>
<h2 id="继承中方法的覆盖重写"><a href="#继承中方法的覆盖重写" class="headerlink" title="继承中方法的覆盖重写"></a>继承中方法的覆盖重写</h2><p>重写（Override）</p>
<p>概念：在继承关系当中，方法的名称一样，参数列表也一样</p>
<p>​    </p>
<p>重写（Override）:方法的名称一样，参数列表【也一样】，覆盖、覆写</p>
<p>重载（Overload）:方法的名称一样，参数列表【不一样】</p>
<p>​     </p>
<p>方法的覆盖重写的特点：创建的是子类对象，则优先用子类方法</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.必须保证父子类之间方法的名称相同，参数列表也相同</p>
<p>@Override，写在方法上面，用来检测是不是有效的覆盖重写</p>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
<p>java.lang.Objet类是所有类的公共最高父类，java.lang.String就是Object的子类</p>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>public &gt; protected &gt; (default) &gt;private</p>
<p>备注：（default）不是关键字，而是什么都不写，留空</p>
<p>​    </p>
<p>应用场景：</p>
<p>设计原则：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新类继承，来重复利用其中的共性内容，并添加改动新内容</p>
<h2 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h2><p>1.子类构造方法当中有一个默认隐含的“super( )”调用，所以一定是先调用的父类构造，后执行子类的构造</p>
<p>2.子类构造可以通过super关键字来调用父类重载构造</p>
<p>3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p>
<p>只要子类的构造方法才能调用父类的构造方法</p>
<p>总结：</p>
<p>子类必须调用父类构造方法，不写则赠送super( )；写了则用写的指定的super调用，super只能有一个，还必须是第一个</p>
<h2 id="super关键字的三种用法"><a href="#super关键字的三种用法" class="headerlink" title="super关键字的三种用法"></a>super关键字的三种用法</h2><p>1.在子类的成员方法中，访问父类的成员变量    super.</p>
<p>2.在子类的成员方法中，访问父类的成员方法    super.</p>
<p>3.在子类的构造方法中，访问父类的构造方法    super()</p>
<h2 id="this关键字的三种用法"><a href="#this关键字的三种用法" class="headerlink" title="this关键字的三种用法"></a>this关键字的三种用法</h2><p>1.在本来的成员方法中，访问本类的成员变量                this.</p>
<p>2.在本来的成员方法中，访问本类的另一个成员方法    this.</p>
<p>3.在本来的构造方法中，访问本类的另一个构造方法    this()</p>
<p>在第三种用法中注意：</p>
<p>A.this(…)调用也必须是构造方法的第一个语句，唯一一个</p>
<p>B.super和this两种构造调用，不能同时使用</p>
<h2 id="java继承的三个特点"><a href="#java继承的三个特点" class="headerlink" title="java继承的三个特点"></a>java继承的三个特点</h2><p>1.Java语言是单继承的</p>
<p>一个类的直接父类只能有唯一一个</p>
<p>2.Java语言可以多级继承</p>
<p>3.一个子类的直接父类是唯一的，但是一个父类可以有多个子类</p>
<h1 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h1><h2 id="抽象方法和抽象类的格式"><a href="#抽象方法和抽象类的格式" class="headerlink" title="抽象方法和抽象类的格式"></a>抽象方法和抽象类的格式</h2><p>抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束</p>
<p>抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstaract即可</p>
<p>如：</p>
<p>public abstract calss Demo {</p>
<p>​    public abstract void method( );</p>
<p>}</p>
<h2 id="抽象方法和抽象类的使用"><a href="#抽象方法和抽象类的使用" class="headerlink" title="抽象方法和抽象类的使用"></a>抽象方法和抽象类的使用</h2><p>1.不能直接创建new抽象类对象</p>
<p>2.必须用一个子类继承抽象父类</p>
<p>3.子类必须覆盖重写抽象父类中所有的抽象方法</p>
<p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p>
<p>4.创建子类对象进行使用</p>
<h2 id="抽象方法和抽象类的注意事项"><a href="#抽象方法和抽象类的注意事项" class="headerlink" title="抽象方法和抽象类的注意事项"></a>抽象方法和抽象类的注意事项</h2><p>1.抽象类不能创建对象</p>
<p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super(); 需要访问父类构造方法</p>
</blockquote>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必须是抽象类</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的是不想让调用者创建该类对象，通常用于某些特殊的类结构设计</p>
</blockquote>
<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day14</title>
    <url>/2021/09/25/StudyNotes_day14/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种<strong>公共的规范标准</strong></p>
<p>只要符合规范标准，就可以大家通用</p>
<h2 id="接口的定义基本格式"><a href="#接口的定义基本格式" class="headerlink" title="接口的定义基本格式"></a>接口的定义基本格式</h2><p>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法</p>
<p>​    </p>
<p>如何定义一个接口的格式：</p>
<p>public interface 接口名称 {</p>
<p>​    //接口内容</p>
<p>}</p>
<p>备注：换成了interface之后，源文件是：.java，编译生成的字节码文件仍然是：.class</p>
<p>​    </p>
<p>如果是Java 7，那么接口中可以包含的内容有：</p>
<p>1.常量</p>
<p>2.抽象方法</p>
<p>如果是Java 8，还可以额外包含有：</p>
<p>3.默认方法</p>
<p>4.静态方法</p>
<p>如果是Java 9，还可以额外包含有：</p>
<p>5.私有方法</p>
<h2 id="接口的抽象方法定义"><a href="#接口的抽象方法定义" class="headerlink" title="接口的抽象方法定义"></a>接口的抽象方法定义</h2><p>在任何版本的Java中，接口都能定义抽象方法</p>
<p>格式：</p>
<p>public abstract 返回值类型 方法名称（参数列表）；</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.接口当中的抽象方法，修饰符必须是两个固定的关键字，public abstract</p>
<p>2.这两个关键字修饰符，可以选择性地省略</p>
<h2 id="接口的抽象方法使用"><a href="#接口的抽象方法使用" class="headerlink" title="接口的抽象方法使用"></a>接口的抽象方法使用</h2><p>接口的使用步骤：</p>
<p>1.接口不能直接使用，必须有一个“实现类”来“实现”该接口</p>
<p>格式：</p>
<p>public class 实现类名称 implements 接口名称 {</p>
<p>​    //…</p>
<p>}</p>
<p>2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法</p>
<p>实现：去掉abstract关键字，加上方法大括号</p>
<p>3.创建实现类的对象，进行使用</p>
<p>​    </p>
<p>注意事项：</p>
<p>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类</p>
<h2 id="接口的默认方法定义"><a href="#接口的默认方法定义" class="headerlink" title="接口的默认方法定义"></a>接口的默认方法定义</h2><p>从Java 8开始，接口里允许定义默认方法</p>
<p>格式：</p>
<p>public default 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>备注：接口当中的默认方法，可以解决接口升级问题</p>
<h2 id="接口的默认方法使用"><a href="#接口的默认方法使用" class="headerlink" title="接口的默认方法使用"></a>接口的默认方法使用</h2><p>1.接口的默认方法，可以通过接口实现类对象，直接调用</p>
<p>2.接口的默认方法，也可以被接口实现类进行覆盖重写</p>
<h2 id="接口的静态方法定义"><a href="#接口的静态方法定义" class="headerlink" title="接口的静态方法定义"></a>接口的静态方法定义</h2><p>从Java 8开始，接口当中允许定义静态方法</p>
<p>格式：</p>
<p>public static 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>提示：就是将abstract或者defualt换成static即可，带上方法体</p>
<h2 id="接口的静态方法使用"><a href="#接口的静态方法使用" class="headerlink" title="接口的静态方法使用"></a>接口的静态方法使用</h2><p>注意事项：不能通过接口实现类的对象来调用接口当中的静态方法</p>
<p>正确用法：通过接口名称，直接调用其中的静态方法</p>
<p>格式：</p>
<p>接口名称 . 静态方法（参数列表）；</p>
<h2 id="接口的私有方法定义"><a href="#接口的私有方法定义" class="headerlink" title="接口的私有方法定义"></a>接口的私有方法定义</h2><p>问题描述：</p>
<p>我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题</p>
<p>但是这个共有方法不应该让实现类使用，应该是私有化的</p>
<p>​    </p>
<p>解决方案：</p>
<p>从Java 9开始，接口当中允许定义私有方法</p>
<p>1.普通私有方法，解决多个默认方法之间重复代码问题</p>
<p>格式：</p>
<p>private 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<p>2.静态私有方法，解决多个静态方法之间重复代码问题</p>
<p>格式：</p>
<p>private static 返回值类型 方法名称（参数列表）{</p>
<p>​    方法体</p>
<p>}</p>
<h2 id="接口的私有方法使用"><a href="#接口的私有方法使用" class="headerlink" title="接口的私有方法使用"></a>接口的私有方法使用</h2><p>​    </p>
<h2 id="接口的常量定义和使用"><a href="#接口的常量定义和使用" class="headerlink" title="接口的常量定义和使用"></a>接口的常量定义和使用</h2><p>接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰</p>
<p>从效果上看，这其实就是接口的【常量】</p>
<p>格式：</p>
<p>public static final 数据类型 常量名称 = 数据值；</p>
<p>备注：</p>
<p>一旦使用final关键字进行修饰，说明不可改变</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.接口当中的常量，可以省略public static final，注意：不写也是这样</p>
<p>2.接口当中的常量，必须进行赋值，不能不赋值</p>
<p>3.接口当中常量的名称，使用完全大写的字母，用下划线进行分隔</p>
<h2 id="接口的内容小结"><a href="#接口的内容小结" class="headerlink" title="接口的内容小结"></a>接口的内容小结</h2><p>在Java 9+版本中，接口的内容可以有：</p>
<p>​    </p>
<p>[ ]的关键字可以省略不写</p>
<p>1.成员变量其实是常量，格式：</p>
<p>[public] [static] [final] 数据类型 常量名称 = 数据值；</p>
<p>注意：</p>
<p>​        常量必须进行赋值，而且一旦赋值不能改变</p>
<p>​        常量名称完全大写，用下划线进行分隔</p>
<p>​    </p>
<p>2.接口中最重要的就是抽象方法，格式：</p>
<p>[public] [abstract] 返回值类型 方法名称（参数列表）;</p>
<p>注意：实现类必须覆盖重写接口中所有的抽象方法，除非实现类是抽象类</p>
<p>​    </p>
<p>3.从Java 8开始，接口里允许定义静态方法，格式：</p>
<p>[public] default 返回值类型 方法名称（参数列表）{ 方法体 } </p>
<p>注意：默认方法也可被覆盖重写</p>
<p>​    </p>
<p>4.从Java 8开始，接口里允许定义静态方法，格式：</p>
<p>[public] static 返回值类型 方法名称（参数列表）{ 方法体 } </p>
<p>注意：应该通过接口名称进行调用，不能通过实行类对象调用接口静态方法</p>
<p>​    </p>
<p>5.从Java 9开始，接口里允许定义私有方法，格式：</p>
<p>普通私有方法：private 返回值类型 方法名称（参数列表）{ 方法体 }</p>
<p>静态私有方法：private static 返回值类型 方法名称（参数列表）{ 方法体 }</p>
<p>注意：private的方法只有接口自己才能调用，不能被实现类或别人使用</p>
<h2 id="继承父类并实现多个接口"><a href="#继承父类并实现多个接口" class="headerlink" title="继承父类并实现多个接口"></a>继承父类并实现多个接口</h2><p>使用接口的时候，需要注意：</p>
<p>1.接口是没有静态代码块或构造方法的</p>
<p>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</p>
<p>格式：</p>
<p>public class MyInterfaceImpl extends Object implements MyInterfaceA, MyInterfaceB{</p>
<p>​    //覆盖重写所有的抽象方法</p>
<p>}</p>
<p>3.如果实现类实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p>
<p>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类</p>
<p>5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p>
<p>6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法</p>
<p>继承优先于接口实现</p>
<h2 id="接口之间的多继承"><a href="#接口之间的多继承" class="headerlink" title="接口之间的多继承"></a>接口之间的多继承</h2><p>1.类与类之间是单继承的，直接父类只有一个</p>
<p>2.类与接口之间是多实现的，一个类可以实现多个接口</p>
<p>3.接口与接口之间是多继承的</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.多个父接口当中的抽象方法如果重复，没关系</p>
<p>2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】</p>
<p>​    </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day15</title>
    <url>/2021/09/27/StudyNotes_day15/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态的概述"><a href="#多态的概述" class="headerlink" title="多态的概述"></a>多态的概述</h2><p>面向对象的三大特征：封装性、继承性、多态性</p>
<p>extends继承或者implements实现，是多态性的前提</p>
<p>包括了类与类之间继承，接口与接口之间继承，类与接口之间实现</p>
<p>​    </p>
<p>一个对象拥有多种形态，这就是：对象的多态性</p>
<p>继承说的是类，多态说的是对象</p>
<h2 id="多态的格式与使用"><a href="#多态的格式与使用" class="headerlink" title="多态的格式与使用"></a>多态的格式与使用</h2><p>代码当中体现多态性，其实就是一句话，父类引用指向子类对象</p>
<p>​    </p>
<p>格式：</p>
<p>左侧父类的引用，指向了右侧子类的对象</p>
<p>父类名称 对象名 = new 子类名称（）；</p>
<p>或者：</p>
<p>接口名称 对象名 = new 实现类名称（）；</p>
<h2 id="多态中成员变量的使用特点"><a href="#多态中成员变量的使用特点" class="headerlink" title="多态中成员变量的使用特点"></a>多态中成员变量的使用特点</h2><p>访问成员变量的两种方式：</p>
<p>1.直接：通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有向上找</p>
<p>2.间接：通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有向上找</p>
<h2 id="多态中成员方法的使用特点"><a href="#多态中成员方法的使用特点" class="headerlink" title="多态中成员方法的使用特点"></a>多态中成员方法的使用特点</h2><p>在多态代码当中，成员方法的访问规则是：</p>
<p>​        看new的是谁，就优先用谁，没有则向上找</p>
<p>​    </p>
<p>口诀：编译看左边，运行看有右边</p>
<p>​    </p>
<p>对比：</p>
<p>成员变量：编译看左边，运行还看左边</p>
<p>成员方法：编译看左边，运行看右边</p>
<h2 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h2><p>无论右边new的时候换成哪个子类，等号左边调用的方法都不会变化</p>
<p>只能调用父类共有的方法</p>
<p>如果要用子类特有的方法就需要向下转型</p>
<h2 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h2><p>对象的向上转型，其实就是多态的写法</p>
<p>格式：父类名称 对象名称 = new 子类名称（）；</p>
<p>含义：右侧创建一个子类对象，把它当做父类来看待使用</p>
<p>注意事项：向上转型一定是安全的，从小范围转向大范围</p>
<h2 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h2><p>对象的向下转型，其实是一个【还原】的动作</p>
<p>格式：子类名称 对象名称 = （子类名称）父类对象；</p>
<p>含义：将父类对象，【还原】成为本来的子类对象</p>
<p>Animal animal = new Cat()；//本来是猫，向上转型成为动物</p>
<p>Cat cat = (Cat) animal；//本来是猫，已经当做动物了，还原回来成为本来的猫</p>
<p>注意事项：</p>
<p>a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫</p>
<p>b.如果对象创建的时候本来不是猫，非要向下转型成为猫，就会报错，ClassCastException</p>
<h2 id="用instanceof关键字来进行类型判断"><a href="#用instanceof关键字来进行类型判断" class="headerlink" title="用instanceof关键字来进行类型判断"></a>用instanceof关键字来进行类型判断</h2><p>格式：</p>
<p>对象    instanceof    类名称</p>
<p>这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面的类型的实例</p>
<p>向下转型一定要进行instanceof判断</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day16</title>
    <url>/2021/09/30/StudyNotes_day16/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="final关键字概念与四种用法"><a href="#final关键字概念与四种用法" class="headerlink" title="final关键字概念与四种用法"></a>final关键字概念与四种用法</h2><p>final关键字代表最终，不可改变的</p>
<p>​    </p>
<p>常见四种用法：</p>
<p>1.可以用来修饰一个类</p>
<p>2.可以用来修饰一个成员方法</p>
<p>3.还可以用来修饰一个局部变量</p>
<p>4.还可以用来修饰一个成员变量</p>
<h2 id="final关键字用于修饰类"><a href="#final关键字用于修饰类" class="headerlink" title="final关键字用于修饰类"></a>final关键字用于修饰类</h2><p>final修饰类格式：</p>
<p>public final class 类名称{</p>
<p>​    //…</p>
<p>}</p>
<p>修饰的此类不能有子类，因此其中的方法不能进行覆盖重写</p>
<h2 id="final关键字用于修饰成员方法"><a href="#final关键字用于修饰成员方法" class="headerlink" title="final关键字用于修饰成员方法"></a>final关键字用于修饰成员方法</h2><p>修饰方法的时候，这个方法就是最终方法，不能被覆盖重写</p>
<p>格式：</p>
<p>修饰符 final 返回值类型 方法名称（参数列表）{</p>
<p>​    //方法体</p>
<p>}</p>
<p>注意事项：</p>
<p>对于类、方法来说，abstract关键字和final关键字不能同时使用</p>
<h2 id="final关键字用于修饰局部变量"><a href="#final关键字用于修饰局部变量" class="headerlink" title="final关键字用于修饰局部变量"></a>final关键字用于修饰局部变量</h2><p>一旦使用final用来修饰局部变量，这个变量只能有唯一一次的赋值，这个变量不能进行更改</p>
<p>对于基本类型来说，不可变说的是变量当中的数据不可改变</p>
<p>对于引用类型来说，不可变说的是变量当中的地址不可改变</p>
<h2 id="final关键字用于修饰成员变量"><a href="#final关键字用于修饰成员变量" class="headerlink" title="final关键字用于修饰成员变量"></a>final关键字用于修饰成员变量</h2><p>对于成员变量来说，用final关键字修饰，那么这个变量也照样不可改变</p>
<p>1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值</p>
<p>2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一</p>
<p>3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值</p>
<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><h2 id="四种权限的修饰符"><a href="#四种权限的修饰符" class="headerlink" title="四种权限的修饰符"></a>四种权限的修饰符</h2><p>Java中有四种权限修饰符：</p>
<p>​                        public     &gt;    protected    &gt;    (default)    &gt;    private</p>
<p>同一个类            YES                YES                        YES                YES</p>
<p>同一个包            YES                YES                        YES                NO</p>
<p>不同包子类        YES                YES                        NO                 NO    </p>
<p>不同包非子类    YES                NO                         NO                 NO        </p>
<p>注意事项：(default)并不是关键字”default“,而是根本不写</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类的概念与分类"><a href="#内部类的概念与分类" class="headerlink" title="内部类的概念与分类"></a>内部类的概念与分类</h2><p>类是模拟一个事物的，如果一个事物内部包含另一个事物，那么这就是一个类内部包含另一类</p>
<p>例如：身体和心脏的关系。又如：汽车和发动机的关系</p>
<p>​    </p>
<p>分类：</p>
<p>1.成员内部类</p>
<p>2.局部内部类（包含匿名内部类）</p>
<h2 id="成员内部类的定义"><a href="#成员内部类的定义" class="headerlink" title="成员内部类的定义"></a>成员内部类的定义</h2><p>定义格式：</p>
<p>修饰符 class 外部类名称 {</p>
<p>​    修饰符 class 内部类名称{</p>
<p>​        //…</p>
<p>​    }</p>
<p>​    //…</p>
<p>}</p>
<p>注意：内用外，随意访问；外用内，需要内部类对象</p>
<h2 id="成员内部类的使用"><a href="#成员内部类的使用" class="headerlink" title="成员内部类的使用"></a>成员内部类的使用</h2><p>两种方式：</p>
<p>1.间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法</p>
<p>2.直接方式：公式：</p>
<p>【外部类名称.内部类名称    对象名称    =    new    外部类名称（）.new    内部类名称（）；】</p>
<h2 id="内部类的同名变量访问"><a href="#内部类的同名变量访问" class="headerlink" title="内部类的同名变量访问"></a>内部类的同名变量访问</h2><p>格式：外部类.this.外部类成员变量名</p>
<h2 id="局部内部类的定义"><a href="#局部内部类的定义" class="headerlink" title="局部内部类的定义"></a>局部内部类的定义</h2><p>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类</p>
<p>“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能使用了</p>
<p>​    </p>
<p>定义格式：</p>
<p>修饰符 class 外部类名称 {</p>
<p>​    修饰符 返回值类型 方法名称（参数列表）{ </p>
<p>​        class 局部内部类名称 {</p>
<p>​            //…</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>小节一下类的权限修饰：</p>
<p>public &gt; protected &gt; (default) &gt;private</p>
<p>定义一个类的时候，权限修饰符规则：</p>
<p>1.外部类：public / (default)</p>
<p>2.成员内部类：pulbic / protected / (default) / private</p>
<p>3.局部内部类：什么都不能写</p>
<h2 id="局部内部类的final问题"><a href="#局部内部类的final问题" class="headerlink" title="局部内部类的final问题"></a>局部内部类的final问题</h2><p>局部内部类，如果希望访问所在的方法的局部变量，那么这个局部变量必须是【有效的final的】</p>
<p>备注：从Java 8+开始，只有局部变量事实不变，那么final关键字可以省略</p>
<p>原因：</p>
<p>生命周期问题</p>
<p>1.new出来的对象在堆内存中</p>
<p>2.局部变量是跟着方法走的，在栈内存中</p>
<p>3.方法运行结束之后，立刻出栈，局部变量就会立刻消失</p>
<p>4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次</p>
<p>那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】</p>
<p>​    </p>
<p>定义格式：</p>
<p>接口名称 对象名称 = new 接口名称 {</p>
<p>​    //覆盖重写所有的抽象方法</p>
<p>}</p>
<h2 id="匿名内部类的注意事项"><a href="#匿名内部类的注意事项" class="headerlink" title="匿名内部类的注意事项"></a>匿名内部类的注意事项</h2><p>对格式“new 接口名称（）{ .. }”进行解析：</p>
<p>1.new代表创建对象的动作</p>
<p>2.接口名称就是匿名内部类需要实现哪个接口</p>
<p>3.{ … } 这才是匿名内部类的内容</p>
<p>​    </p>
<p>另外还需要注意：</p>
<p>1.匿名内部类，在【创建对象】的时候，只能使用唯一一次</p>
<p>如果需要多次创建对象，而且类的内容一样的话，那就必须使用单独定义的实现类</p>
<p>2.匿名对象，在【调用方法】的时候，只能调用唯一一次</p>
<p>如果希望同一个对象，调用多次方法，那么必须给对象起个名字</p>
<p>3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】</p>
<p>匿名内部类和匿名对象不是一回事</p>
<h2 id="类作为成员变量类型"><a href="#类作为成员变量类型" class="headerlink" title="类作为成员变量类型"></a>类作为成员变量类型</h2><h2 id="接口作为成员变量类型"><a href="#接口作为成员变量类型" class="headerlink" title="接口作为成员变量类型"></a>接口作为成员变量类型</h2><h2 id="接口作为方法的参数和返回值"><a href="#接口作为方法的参数和返回值" class="headerlink" title="接口作为方法的参数和返回值"></a>接口作为方法的参数和返回值</h2><h1 id="成员内部类代码"><a href="#成员内部类代码" class="headerlink" title="成员内部类代码"></a>成员内部类代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//间接访问成员内部类</span></span><br><span class="line"><span class="comment">//        Outer outer = new Outer();</span></span><br><span class="line"><span class="comment">//        outer.methodOuter();</span></span><br><span class="line">        <span class="comment">//直接访问成员内部类</span></span><br><span class="line">        Outer.Inner obj = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        obj.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="局部内部代码"><a href="#局部内部代码" class="headerlink" title="局部内部代码"></a>局部内部代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.methodOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="匿名内部类代码"><a href="#匿名内部类代码" class="headerlink" title="匿名内部类代码"></a>匿名内部类代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.company.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单独使用匿名内部类，再通过对象名去调用匿名内部类中的方法</span></span><br><span class="line"><span class="comment">//        MyInterface obj = new MyInterface() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void method() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;匿名内部类实现了方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        obj.method();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时使用匿名内部类和匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现了接口中的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day17</title>
    <url>/2021/10/02/StudyNotes_day17/</url>
    <content><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>java.lang.Object</p>
<p>Object类是所有的类的父类，一个类都会直接或者间接的继承自该类</p>
<p>该类中提供了一些非常常用的方法</p>
<h2 id="Object类的toString方法"><a href="#Object类的toString方法" class="headerlink" title="Object类的toString方法"></a>Object类的toString方法</h2><p>toSring方法返回地址值</p>
<p>直接打印对象的名字，其实就是调用对象的toString方法</p>
<p>作用：打印对象的信息</p>
<p>重写前：打印的是包名类名@地址值</p>
<p>重写后：打印的是对象中的属性值</p>
<h2 id="Object类的equals方法"><a href="#Object类的equals方法" class="headerlink" title="Object类的equals方法"></a>Object类的equals方法</h2><p>Object类equals方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数：Object obj ：可以传递任意的对象</p>
<p>方法体：</p>
<p>​        == :比较运算符：返回的就是一个布尔值</p>
<p>​        基本数据类型：比较的是值</p>
<p>​        引用数据类型：比较的两个对象的地址值</p>
<p>作用：比较两个对象的</p>
<p>重写前：比较的是对象的地址值</p>
<p>重写后：比较的是对象中的属性值</p>
<h1 id="Objects工具类"><a href="#Objects工具类" class="headerlink" title="Objects工具类"></a>Objects工具类</h1><p>java.util.Objects</p>
<h2 id="Objects类的equals方法"><a href="#Objects类的equals方法" class="headerlink" title="Objects类的equals方法"></a>Objects类的equals方法</h2><p>可以跟Null值比较，两个对象比较，防止空指针异常</p>
<p>作用：比较两个对象是否相同，但是增加了一些完善的判断</p>
<h1 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h1><h2 id="毫秒值的概念和作用"><a href="#毫秒值的概念和作用" class="headerlink" title="毫秒值的概念和作用"></a>毫秒值的概念和作用</h2><p>毫秒：千分之一秒，1000ms = 1s</p>
<p>毫秒值的作用：可以对时间和日期进行计算</p>
<p>2088-01-01到2099-01-03 中间一共有多少天</p>
<p>可以把日期转换为毫秒进行计算，计算完，再把毫秒转换为日期</p>
<p>​    </p>
<p>把日期转换为毫秒：</p>
<p>​        当前日期：2088-01-01</p>
<p>​        时间原点（0毫秒）：1970年1月1日00：00：00</p>
<p>​        计算当前日期到时间原之间一共经历了多少毫秒</p>
<p>注意：</p>
<p>​        中国属于东八区，会把时间增加8个小时</p>
<p>System.currentTimeMillis();获取当前系统时间到1970年1月1日00：00：00经历了多少毫秒</p>
<h2 id="Date类的构造方法和成员方法"><a href="#Date类的构造方法和成员方法" class="headerlink" title="Date类的构造方法和成员方法"></a>Date类的构造方法和成员方法</h2><p>java.util.Date</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>无参构造：Date( )    获取当前系统的日期和时间</p>
<p>有参构造：Date( Long date )    传递毫秒值，把毫秒转换为Data日期 </p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>Long getTime( ):把日期转换为毫秒（相当于System.currentTimeMillis() ）</p>
<p>返回自时间原点之间经过的毫秒</p>
<h2 id="DateFormat类-amp-SimpleDateFormat类"><a href="#DateFormat类-amp-SimpleDateFormat类" class="headerlink" title="DateFormat类&amp;SimpleDateFormat类"></a>DateFormat类&amp;SimpleDateFormat类</h2><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>父类Format:格式化类</p>
<p>子类SimpleDateFormat</p>
<p>java.text.DateFormat是日期/时间格式化子类的<strong>抽象类</strong>，我们可以通过这个类可以帮我们完成日期和文本之间的转换，也就是可以再Data对象与String对象之间进行来回转换</p>
<p>格式化：按照指定格式，从Date对象转换为String对象（日期 -&gt; 文本）</p>
<p>解析：按照指定格式，从String对象转换为Date对象（文本 -&gt; 日期）</p>
<p>成员方法：</p>
<p>​        String format(Date date)    按照指定的格式，把Date日期，格式化为符合模式的字符串</p>
<p>​        Date parse(String source)    把符合模式的字符串，解析为Date日期</p>
<p>注意：</p>
<p>​    DateFormat类是一个抽象类，无法直接创建对象使用，可以创建子类SimpleDateFormat对象</p>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p>构造方法：</p>
<p>​    SimpleDateFormat( String pattern )    用给定的模式和默认语言环境的日期格式符合构造</p>
<p>​    参数：</p>
<p>​            String pattern:传递指定的模式</p>
<p>​            写对应的模式，会把模式替换为对应的日期和时间</p>
<p>​                “yyyy-MM-dd HH:mm:ss”</p>
<p>​                “yyyy年MM月dd日 HH时mm分ss秒”</p>
<p>使用步骤：</p>
<ul>
<li><p>格式化日期</p>
<ol>
<li>创建Date对象</li>
<li>创建SimpleDateFormat对象，构造方法中传递指定的模式</li>
<li>调用SimpleDateFormat对象中的format方法</li>
</ol>
</li>
<li><p>日期解析</p>
<ol>
<li><p>创建SimpleDateFormat对象，构造方法中传递指定的模式</p>
</li>
<li><p>调用SimpleDateFormat对象中的parse方法</p>
</li>
</ol>
</li>
</ul>
<h2 id="日期时间类代码"><a href="#日期时间类代码" class="headerlink" title="日期时间类代码"></a>日期时间类代码</h2><h3 id="Date类使用代码"><a href="#Date类使用代码" class="headerlink" title="Date类使用代码"></a>Date类使用代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统当前的日期和时间</span></span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(d1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传递毫秒参数计算对应的日期和时间</span></span><br><span class="line">        Date d2 = <span class="keyword">new</span> Date(<span class="number">0l</span>);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传递系统当前时间到时间原点经过的毫秒计算当前的日期和时间</span></span><br><span class="line">        Date d3 = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        System.out.println(d3);</span><br><span class="line"></span><br><span class="line">        Date d4 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//getTime等效于System.currentTimeMillis();获取系统当前时间到时间原点之间的毫秒</span></span><br><span class="line">        <span class="keyword">long</span> time = d4.getTime();</span><br><span class="line">        <span class="keyword">long</span> timeMillis = System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(timeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        String text = sdf.format(date);</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//格式化日期</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        String text = sdf.format(date);</span><br><span class="line">        System.out.println(text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//日期解析</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date parse = simpleDateFormat.parse(<span class="string">&quot;2021-10-04 17:08:00&quot;</span>);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>java.util.Calendar是日历类，在Date后出现，替换了许多Date的方法，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的</p>
<p>Calendar为抽象类。调用其中的静态方法，返回子类对象</p>
<p>static Calendar getInstance():使用默认时区和语言环境获得一个日历</p>
<h3 id="Calendar类的常用成员方法"><a href="#Calendar类的常用成员方法" class="headerlink" title="Calendar类的常用成员方法"></a>Calendar类的常用成员方法</h3><p>public int get( int field )：返回给定日历字段的值</p>
<p>public  void set( int field, int value )：将给定日历字段设置为给定值</p>
<p>public abstract void add( int field, int amount )：根据日历的规则，为给定的日历字段添加或减去指定的时间量</p>
<p>public Date getTime( )：把日历对象转成日期对象</p>
<h3 id="日历Calendar类代码"><a href="#日历Calendar类代码" class="headerlink" title="日历Calendar类代码"></a>日历Calendar类代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCalendar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用getInstance静态方法创建Calendar的子类对象</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取给定日历字段的值，西方月份是0-11月</span></span><br><span class="line">        <span class="keyword">int</span> i = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = c.get(Calendar.MARCH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DATE);</span><br><span class="line">        <span class="keyword">int</span> h = c.get(Calendar.HOUR);</span><br><span class="line">        <span class="keyword">int</span> min = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> s = c.get(Calendar.SECOND);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date getTime()把日历对象转成日期对象</span></span><br><span class="line"><span class="comment">//        Date time = c.getTime();</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System类-amp-StringBuilder类"><a href="#System类-amp-StringBuilder类" class="headerlink" title="System类&amp;StringBuilder类"></a>System类&amp;StringBuilder类</h1><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作</p>
<p>常用方法：</p>
<p>public static long currentTimeMillis( )：获取当前系统毫秒值</p>
<p>public static void arraycopy(Object src , int srcPos , Object dest , int dest Pos , int length )：将源数组的部分内容复制到目标数组中</p>
<p>​        参数：src：源数组</p>
<p>​                    srcPos:源数组起始位置</p>
<p>​                    dest:目标数组</p>
<p>​                    destPos:目标数组起始位置</p>
<p>​                    length:要复制的数组元素数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看程序运行效率</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(dest));</span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>java.lang.StringBuilder类：字符串缓冲区，可以提高字符串的效率</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>public StringBuilder( )：创建一个空的字符串缓冲区对象</p>
<p>public StringBuilder( String str )：根据传入的内容创建一个字符串缓冲区对象</p>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><p>public StringBuilder append( … )：添加任意类型数据的字符串形式，并返回当前对象自身</p>
<p>public String toString( )：将当前StringBuilder对象转换为String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder bu1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder bu2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(bu1);</span><br><span class="line">        System.out.println(bu2);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu3 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        bu3.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        bu3.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        bu3.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(bu3);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu4 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        bu4.append(<span class="number">1</span>).append(<span class="number">3.14</span>).append(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        System.out.println(bu4);</span><br><span class="line"></span><br><span class="line">        StringBuilder bu5 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">        String s = bu5.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="基本类型与字符串类型之间的相互转换"><a href="#基本类型与字符串类型之间的相互转换" class="headerlink" title="基本类型与字符串类型之间的相互转换"></a>基本类型与字符串类型之间的相互转换</h2><p>基本类型数据的值 + “ ” 最简单的方式（工作中常用） </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day18</title>
    <url>/2021/10/03/StudyNotes_day18/</url>
    <content><![CDATA[<h1 id="Collection单列集合"><a href="#Collection单列集合" class="headerlink" title="Collection单列集合"></a>Collection单列集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>集合（Collection单列集合和Map双列集合）</p>
<p>集合：java中提供的一种容器，可以用来存储多个数据</p>
<p>数组和集合都是容器，区别有：</p>
<ul>
<li><p>数组长度固定。集合长度可变</p>
</li>
<li><p>数组中存储的是同一类型的元素，可以是基本数据类型或者引用类型。集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用集合进行存储</p>
</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>javaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口实现架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map</p>
<p>集合框架的学习方式：</p>
<p>1.学习顶层：学习顶层接口/抽象类中共性方法，所有的子类都可以使用</p>
<p>2.使用底层：顶层不是接口就是抽象类，无法直接创建对象使用，需要使用底层的子类创建对象使用</p>
<p>​    </p>
<p>Collection:单列集合最顶层的接口，所有单列集合共性的方法，无索引</p>
<p>​    </p>
<p>List集合：有序（可以保证存取顺序），可以存储重复元素，有索引</p>
<p>ArrayList：底层是数组实现的，查询快，增删慢</p>
<p>LinkedList：底层是链表实现的，查询慢，增删快    </p>
<p>​        </p>
<p>Set集合：无序，不可以存储重复的元素，无索引</p>
<p>TreeSet：底层是二叉树实现，一般用于排序</p>
<p>HashSet：底层是哈希表+（红黑树）实现的，无索引，不可存储重复元素，存储无序</p>
<p>LinkedHashSet：底层是哈希表+链表实现的，无索引，不可存储重复元素，存储有序</p>
<h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><ul>
<li>public boolean add( E e )：把给定的对象添加到当前的集合中</li>
<li>public boolean remove( E e )：把给定的对象在当前集合中删除</li>
<li>public boolean contains( E e )：判断当前集合中是否包含给定的对象</li>
<li>public void clear( )：清空集合中所有的元素，清空后集合还在</li>
<li>public boolean  isEmpty( )：判断当前集合是否为空</li>
<li>public int size( )：返回集合中元素的个数</li>
<li>public Object[ ] toArray( )：把集合中的元素，存储到数组中</li>
</ul>
<h1 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h1><p>java.util.Iterator接口：迭代器（对集合进行遍历）</p>
<p>有两个常用方法</p>
<p>​        boolean hasNext( )：判断集合中还有没有下个元素</p>
<p>​        E next( )：返回迭代的下一个元素</p>
<p>创建实现类：</p>
<p>​        Collection接口中的    iterator( )    获取迭代器实现类对象</p>
<p>​        Iterator<E> iterator( ) :泛型<E>和Collection中的元素类型一致</p>
<h1 id="增强for循环-foreach"><a href="#增强for循环-foreach" class="headerlink" title="增强for循环(foreach)"></a>增强for循环(foreach)</h1><p>JDK 1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实就是个Iterator迭代器</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( 元素的数据类型 变量名 ： 需要遍历的集合/数组的名称 )&#123;</span><br><span class="line">    <span class="comment">//循环体语句</span></span><br><span class="line">    System.out.println( 变量名 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Iterator和foreach使用代码"><a href="#Iterator和foreach使用代码" class="headerlink" title="Iterator和foreach使用代码"></a>Iterator和foreach使用代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            String e = iter.next();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><h2 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h2><h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候，确定泛型的数据类型</p>
<h3 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.定义实现类时确定泛型的类型</p>
<p>2.在创建对象时确定泛型类型</p>
<h3 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名（参数列表（使用泛型））&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法时，确定泛型的类型</p>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>不知道用什么类型来接收数据的时候，用泛型通配符&lt;?&gt;</p>
<p>使用方式：</p>
<p>​    不能创建对象使用</p>
<p>​    只能作为方法的参数使用</p>
<p>通配符的高级使用-受限泛型</p>
<p>指定泛型的上限和下限</p>
<p>泛型的上限：</p>
<ul>
<li><p>格式：类型名称&lt;? extends 类&gt;对象名称</p>
</li>
<li><p>意义：只能接受该类型及其子类</p>
</li>
</ul>
<p>泛型的下限：</p>
<ul>
<li>格式：类型名称&lt;? super 类&gt;对象名称</li>
<li>意义：只能接受该类型及其父类</li>
</ul>
<h2 id="泛型代码"><a href="#泛型代码" class="headerlink" title="泛型代码"></a>泛型代码</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E element;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericClass&lt;String&gt; gc1 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc1.setElement(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        String s = gc1.getElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setElement(<span class="number">100</span>);</span><br><span class="line">        Integer i = gc2.getElement();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用成员内部类来方式来测试泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> E element;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DemoGenericClass&lt;String&gt; dgc = <span class="keyword">new</span> DemoGenericClass&lt;&gt;();</span><br><span class="line">        dgc.setElement(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        String s = dgc.getElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DemoGenericClass&lt;Integer&gt; dgc = <span class="keyword">new</span> DemoGenericClass&lt;&gt;();</span><br><span class="line">        dgc.setElement(<span class="number">100</span>);</span><br><span class="line">        Integer i = dgc.getElement();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.method1();</span><br><span class="line">        d.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口，第一种使用方式：定义接口实现类的时候，指定接口的泛型</span></span><br><span class="line"><span class="comment"> * 在创建实现类的时候，就确定了泛型的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口，第二张使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></span><br><span class="line"><span class="comment"> * 相当于定义了一个含有泛型的类，创建对象的时候，确定泛型的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericInterfaceImpl1 gi1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        gi1.print(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; gi2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi2.print(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterface&lt;Double&gt; gi = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi.print(<span class="number">3.14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        gm.method01(<span class="number">100</span>);</span><br><span class="line">        gm.method01(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        gm.method01(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">100</span>);</span><br><span class="line">        GenericMethod.method02(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">3.14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型通配符-1"><a href="#泛型通配符-1" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型通配符测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list02.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printArray(list01);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        printArray(list02);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个方法，能遍历所有类型的ArrayList集合</span></span><br><span class="line"><span class="comment">    这时候不知道ArrayList集合使用什么类型，可以用泛型通配符&lt;?&gt;来接收数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            <span class="comment">//next()方法，取出的元素是Object，可以接收任意的数据类型</span></span><br><span class="line">            Object o = iter.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day19</title>
    <url>/2021/10/05/StudyNotes_day19/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构-栈"><a href="#数据结构-栈" class="headerlink" title="数据结构_栈"></a>数据结构_栈</h2><p>先进后出</p>
<h2 id="数据结构-队列"><a href="#数据结构-队列" class="headerlink" title="数据结构_队列"></a>数据结构_队列</h2><p>先进先出</p>
<h2 id="数据结构-数组"><a href="#数据结构-数组" class="headerlink" title="数据结构_数组"></a>数据结构_数组</h2><p>查询快：数组的地址是连续的，我们通过数组的首地址，可以找到数组，通过数组的索引可以快速查找到某一个元素</p>
<p>增删慢：数组的长度是固定的，想要增加/删除一个元素，必须创建一个新数组，把源数组的数据复制过来</p>
<h2 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构_链表"></a>数据结构_链表</h2><p>查询慢，增删快</p>
<p>单向链表：链表中只有一条链子，不能保证元素的顺序（存取元素和取出元素的顺序有可能不一致）</p>
<p>双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合</p>
<h2 id="数据结构-红黑树"><a href="#数据结构-红黑树" class="headerlink" title="数据结构_红黑树"></a>数据结构_红黑树</h2><p>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</p>
<h1 id="List集合-介绍-amp-常用方法"><a href="#List集合-介绍-amp-常用方法" class="headerlink" title="List集合_介绍&amp;常用方法"></a>List集合_介绍&amp;常用方法</h1><p>List集合中带有索引的方法（特有）</p>
<ul>
<li><p>public void add( int index, E element )：将指定的元素，添加到该集合中的指定位置上</p>
</li>
<li><p>public E get( int index )：返回集合中指定位置的元素</p>
</li>
<li><p>public E remove( int index )：移除列表中指定位置的元素，返回的是被移除的元素</p>
</li>
<li><p>public E set( int index, E element )：用指定元素替换集合中指定位置的元素，返回值的更新前的元素</p>
</li>
</ul>
<p>注意：</p>
<p>​        操作索引的时候，一定要防止索引越界异常</p>
<p>List集合有3中遍历的方式：</p>
<p>前两种是Collection集合中共有的两种遍历方式：Iterator迭代器遍历和foreach遍历</p>
<p>第三种是通过E get( int index )和普通for循环组合进行遍历集合</p>
<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><p>当需求多为查询时用ArrayList</p>
<p>此实现不是同步的，多线程，速度快</p>
<h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p>需求增删多时用LinkedList</p>
<p>双向链表</p>
<p>多线程</p>
<p>有大量的操作首尾元素的方法</p>
<ul>
<li>public void addFirst( E e )：将指定的元素插入此列表的开头</li>
<li>public void addLast( E e )：元素添加到末尾，相当于add方法</li>
<li>public void push( E e )：将元素推入此列表所表示的堆栈，相当于addFirst方法</li>
<li>public E getFirst( )：返回此列表的第一个元素</li>
<li>public E getLast( )：返回最后一个元素</li>
<li>public E removeFirst( )：移除并返回第一个元素</li>
<li>public E removeLast( )：移除并返回最后一个元素</li>
<li>public E pop( )：从此列表所表示的堆栈处弹出一个元素，相当于removeFirst方法</li>
<li>public boolean isEmpty( )：如果列表不含元素，则返回true</li>
</ul>
<h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><p>Java 1.0版本出的，同步的，单线程，速度慢，1.2版本后被ArrayList集合取代</p>
<p>Collection集合1.2版本才出现的</p>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>与Collection接口中的方法基本一致</p>
<p>和Collection集合一样没有索引，不能用普通for循环遍历</p>
<p>用Iterator迭代器和foreach遍历</p>
<h3 id="Set集合存储元素不重复的原理"><a href="#Set集合存储元素不重复的原理" class="headerlink" title="Set集合存储元素不重复的原理"></a>Set集合存储元素不重复的原理</h3><p>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否重复</p>
<p>两个元素的哈希值相同，equals方法返回true，才认定元素相同</p>
<h2 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h2><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>是一个十进制的整数，由系统随机给出（就是对象的地址值，不过地址是十六进制的，是一个逻辑地址，是模拟出来得到的地址，不是数据实际的物理地址）</p>
<p>在Object类有一个方法，可以获取对象的哈希值</p>
<p>int hashCode( )：返回搞对象的哈希值</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>HashSet集合存储数据的结构（哈希表）</p>
<p>哈希表：</p>
<p>​    Jdk 1.8版本之前=数据+链表</p>
<p>​    Jdk 1.8版本之后=数组+红黑树（提高查询速度）</p>
<h3 id="HashSet集合存储自定义类型的元素"><a href="#HashSet集合存储自定义类型的元素" class="headerlink" title="HashSet集合存储自定义类型的元素"></a>HashSet集合存储自定义类型的元素</h3><p>在自定的类中添加重写的equals和hashCode方法实现存储元素唯一</p>
<h2 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h2><p>集合特点：</p>
<p>底层是一个哈希表（数组+链表）+链表；多了一条链表（记录元素的存储顺序，保证元素有序）</p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>Jdk 1.5之后出现的新特性</p>
<p>使用前提：</p>
<p>当方法的参数列表数据类型已经确定，但是参数参数个数不确定，可以使用可变参数</p>
<p>格式：</p>
<p>修饰符 返回值类型 方法名（ 数据类型…变量名 ）{ </p>
<p>​    //方法体</p>
<p> }</p>
<p>原理：</p>
<p>可变参数底层是一个数组，根据传递参数个数不同，会创建不同长度的数组</p>
<p>注意事项：</p>
<p>1.一个方法的参数列表，只能有一个可变参数</p>
<p>2.方法的参数有多个的时候，可变参数必须写在参数列表的末尾</p>
<p>可变参数的特殊（终极）写法</p>
<p>修饰符 返回值类型 方法名（ Object…obj ）{</p>
<p>​    //方法体</p>
<p>}</p>
<h1 id="Collection集合工具类"><a href="#Collection集合工具类" class="headerlink" title="Collection集合工具类"></a>Collection集合工具类</h1><p>java.util.Collections是集合工具类，用来对集合进行操作，部分方法：</p>
<ul>
<li>public static <T> boolean addAll( Collection<T> c, T…elements )：往集合中添加一些元素</li>
<li>public static void shuffle( List&lt;?&gt; list )：打乱顺序</li>
<li>public static <T> void sort( List<T> list )：将集合中元素按照默认规则排序（升序）</li>
<li>public static <T> void sort( List<T> list, Comparator&lt;? super T&gt; )：将集合中元素按照指定规则排序</li>
</ul>
<p>注意：</p>
<p>sort( List<T> list )使用前提：</p>
<p>自定义的类需要排序的时候，（被排序的集合里边存储的元素）必须实现Comparable接口，重写接口中的CompareTo定义排序的规则</p>
<p>Comparable接口排序规则：</p>
<p>​    自己（this）-参数：升序</p>
<p>sort( List<T> list, Comparator&lt;? super T&gt; )：</p>
<p>Comparator和Comparable的区别</p>
<p>​    Comparable：自己（this）和别（参数）比较，自己需要实现Comparable接口</p>
<p>​    Comparator：相当于找一个第三方的裁判，比较两个，使用时直接在参数中使用匿名内部类实现接口中的方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day2</title>
    <url>/2021/02/16/StudyNotes_day2/</url>
    <content><![CDATA[<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>​    java程序运行期间固定不变的数据</p>
<p>分类：</p>
<ul>
<li>整数常量        例如：100， 0 ， -100</li>
<li>小数常量        例如：1.1， 0.0 ， -1.1</li>
<li>布尔常量                    true,false</li>
<li>字符常量        例如:   ‘a’,’A’,’9’</li>
<li>字符串常量    例如：”abc”,”a”,”123”</li>
<li>空常量                         null,代表没有任何数据</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>​    程序运行期间，内容可以发生改变的量</p>
<p>创建一个变量的一步到位格式：</p>
<p>数据类型    变量名称    =    数据值</p>
<p>​    </p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day20</title>
    <url>/2021/10/06/StudyNotes_day20/</url>
    <content><![CDATA[<h1 id="Map双列集合"><a href="#Map双列集合" class="headerlink" title="Map双列集合"></a>Map双列集合</h1><p>java.util</p>
<p>接口    Map&lt;K,V&gt;</p>
<h2 id="Map集合的特点"><a href="#Map集合的特点" class="headerlink" title="Map集合的特点"></a>Map集合的特点</h2><p>1.Map集合是一个双列集合，一个元素包含两个值（一个key,一个value），即Map存放的是两个对象</p>
<p>2.Map集合中的元素，key和value的数据可以相同，也可以不同</p>
<p>3.Map集合中的元素，key是不允许重复的，value是可以重复的</p>
<p>4.Map集合中的元素，key和value是一一对应</p>
<h2 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h2><p>常用的HashMap集合，LinkedHashMap集合</p>
<p>java.util.HashMap&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</p>
<p>HashMap集合的特点：</p>
<p>1.HashMapj集合底层是哈希表：查询的速度特别快</p>
<p>​                Jdk 1.8之前：数组+单向链表</p>
<p>​                Jdk 1.8之后：数组+单向链表/红黑树（链表长度超过8）</p>
<p>2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p>
<p>java.util.LinkHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合</p>
<p>LinkedHashMap集合的特点：</p>
<p>1.底层是哈希表+链表（保证迭代的顺序）</p>
<p>2.有序集合</p>
<h2 id="Map接口中常用的方法"><a href="#Map接口中常用的方法" class="headerlink" title="Map接口中常用的方法"></a>Map接口中常用的方法</h2><ul>
<li>public V put( K key, V value )：把指定的键与值添加到Map集合中</li>
<li>public V remove( Object key )：把指定的键所对应的键值对元素，在Map集合中删除，返回被删除元素的值</li>
<li>public V get( Object key )：根据指定的键，在Map集合中获取对应的值</li>
<li>boolean containsKey( Object key )：判断集合中是否包含指定的键</li>
<li>public Set<K> keySet( )： 获取Map集合中所有的键，存储到Set集合中</li>
<li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet( )：获取到Map集合中所有的键值对对象的集合（Set集合）</li>
</ul>
<h2 id="Map集合遍历-键找值的方式"><a href="#Map集合遍历-键找值的方式" class="headerlink" title="Map集合遍历_键找值的方式"></a>Map集合遍历_键找值的方式</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map集合的第一种遍历方式：通过键找值的方式</span></span><br><span class="line"><span class="comment"> * 实现步骤：</span></span><br><span class="line"><span class="comment"> *      1.使用Map集合中的keySet(),把Map集合中所有的key取出来，存储到一个Set集合中</span></span><br><span class="line"><span class="comment"> *      2.遍历Set集合，获取Map集合中的每一个key</span></span><br><span class="line"><span class="comment"> *      3.用Map集合中的get(kay)方法找到value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">&quot;John&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            String key = iter.next();</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String key : set)&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><p>java.util.Map.Entry&lt;K,V&gt; 是 Map&lt;K,V&gt;接口中静态的成员内部类</p>
<p>Map集合中存放的是两种对象，一种称为Key（键），一种称为Value（值），他们在Map集合中一一对应，Entry将键值对的对应关系封装成了对象。</p>
<p>键值对（Entry）对象中获取对应键和值的方法：</p>
<ul>
<li>public K getKey( )：获取Entry对象中的键</li>
<li>public V getValue( )：获取Entry对象中的值</li>
</ul>
<h2 id="Map集合遍历-键值对的方式"><a href="#Map集合遍历-键值对的方式" class="headerlink" title="Map集合遍历_键值对的方式"></a>Map集合遍历_键值对的方式</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map集合的第二张遍历方式：通过键值对（Entry）对象</span></span><br><span class="line"><span class="comment"> * 实现步骤：</span></span><br><span class="line"><span class="comment"> *      1.Map集合中的entrySet()方法，把Map集合中所有的Entry对象取出来，放到一个Set集合中</span></span><br><span class="line"><span class="comment"> *      2.遍历Set集合，获取每一个Entry对象</span></span><br><span class="line"><span class="comment"> *      3.使用Entry对象中的getKey()和getValue()获取键与值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iter.next();</span><br><span class="line">            Integer key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">            Integer key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap集合存储自定义类型的键值"><a href="#HashMap集合存储自定义类型的键值" class="headerlink" title="HashMap集合存储自定义类型的键值"></a>HashMap集合存储自定义类型的键值</h2><p>Map集合保证key唯一</p>
<p>Map存放两个对象，也就是可以存放一个或两个自己写的类的对象</p>
<p>自己写的类的对象如果作为key，就必须重写hashCode方法和equals方法，以保证key唯一</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(p1,<span class="number">1</span>);</span><br><span class="line">        map.put(p2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet())&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LinkedHashMap集合"><a href="#LinkedHashMap集合" class="headerlink" title="LinkedHashMap集合"></a>LinkedHashMap集合</h2><p>HashMap的子类LinkedHashMap查询速度快，且有序</p>
<h2 id="Hashtable集合"><a href="#Hashtable集合" class="headerlink" title="Hashtable集合"></a>Hashtable集合</h2><p>java.util.Hashtable是Map接口的另一个实现类</p>
<p>Jdk 1.0就存在，是同步，单线程</p>
<p>键和值不可以为空null</p>
<p>Hashtable和Vector集合都在 Jdk 1.2版本之后被更先进的集合（HashMap，ArrayList）取代了</p>
<p>Hashtable的子类Properties依然活跃在历史舞台</p>
<p>Properties集合是一个唯一和IO流相结合的集合</p>
<h1 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h1><p>Debug调试程序：</p>
<p>可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug</p>
<p>使用方式：</p>
<p>在行号的右边，鼠标左键单击，添加断点（初学者：每个方法的第一行，熟练者：哪有有bug添加哪里）</p>
<p>右键，选择Debug执行程序</p>
<p>程序就会停留在添加的第一个断点处</p>
<p>执行程序：</p>
<p>​        f8：逐行执行程序</p>
<p>​        f7：进入到方法中</p>
<p>​        shift+f8：跳出方法</p>
<p>​        f9：跳到下一个断点，如果没有下一个断点，那么就结束程序</p>
<p>​        ctrl+f2：退出Debug模式，停止程序</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day21</title>
    <url>/2021/10/10/StudyNotes_day21/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><p>在java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象</p>
<h2 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h2><p>异常的根类是 java.lang.Throwable</p>
<p>其下有个子类： java.lang.Error与java.lang.Exception</p>
<p>平常所说的异常指: Exception</p>
<p>Throwable类中定义了一些查看的方法：</p>
<ul>
<li>public String getMessage( )：返回异常简短描述</li>
<li>public String toString( )：返回异常详细消息字符串，直接打印异常变量，就是调用此方法</li>
<li>public void printStackTrace( )：JVM打印异常对象，默认此方法，信息最全面</li>
</ul>
<h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Throwable：可抛出的意思，是所有异常的根类</p>
<p>错误：Error：内存溢出、系统崩溃</p>
<p>异常：Exception：其他的Exception（必须处理）、RuntimeException（一般不处理）</p>
<h1 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h1><p>java异常处理的五个关键字：try、catch、finally、throw、throws</p>
<h2 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h2><p>作用：</p>
<p>​    可以使用throw关键字在指定的方法中抛出指定的异常</p>
<p>使用格式：</p>
<p>​    throw new xxxException（“异常产生的原因”）；</p>
<p>注意：</p>
<p>​    1.throw关键字必须卸写在方法的内部</p>
<p>​    2.throw关键字后边new的对象必须是Exception或Exception的子类对象</p>
<p>​    3.throw关键字抛出指定的异常对象，要处理这个对象</p>
<p>​            throw关键字后边创建的是RuntimeException或其子类对象，可以不处理，默认交给JVM处理（打印异常对象，中断程序）</p>
<p>​            throw关键字后边创建的是编译异常，必须处理，要么throws,要么try…catch</p>
<h2 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h2><p>public static <T> requireNonNull(T obj)：查看指定引用对象是不是null</p>
<p>Objects.requireNonNull( T obj ,  “产生原因”);</p>
<h2 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h2><p>格式：</p>
<p>​    修饰符 返回值类型 方法名（参数列表） throws AAAException,BBBException…{</p>
<p>​    throw new AAAException(“产生原因”);</p>
<p>​    throw new BBBException(“产生原因”);</p>
<p>​    …</p>
<p>}</p>
<p>注意：</p>
<p>1.必须写在方法声明处</p>
<p>2.声明的异常必须是Exception或其子类</p>
<p>3.方法内部抛出了多个了多个异常，那么throws后面也声明多个异常</p>
<p>如果抛出的多个异常有子父类关系，那么直接声明父类异常</p>
<p>4.调用了一个声明抛出异常的方法，就必须处理，那么继续throws，那么try…catch自己处理异常</p>
<h2 id="捕获异常try…catch…finally"><a href="#捕获异常try…catch…finally" class="headerlink" title="捕获异常try…catch…finally"></a>捕获异常try…catch…finally</h2><p>格式：</p>
<p> try{</p>
<p>​            可能产生异常的代码</p>
<p> }catch( 定义一个异常的变量，用来接收try中抛出的异常对象 ) {</p>
<p>​            异常处理的逻辑</p>
<p>​            一般在工作中，会把异常的信息记录到一个日志中</p>
<p>}</p>
<p>…</p>
<p>catch（异常类名 变量名）{</p>
<p>}finally{</p>
<p>​    一般用于资源释放（finally里不要写return）</p>
<p>}</p>
<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="多异常的捕获处理："><a href="#多异常的捕获处理：" class="headerlink" title="多异常的捕获处理："></a>多异常的捕获处理：</h3><p>如果一定要写多个catch语句块，那么顺序应该是子类异常放到前面，父类放再后面</p>
<p>不严谨的就用Exception</p>
<h3 id="子父类的异常："><a href="#子父类的异常：" class="headerlink" title="子父类的异常："></a>子父类的异常：</h3><p>父类抛出什么异常，子类就抛出什么异常</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxException</span> <span class="keyword">extends</span> <span class="title">Expcetion</span>/<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">	<span class="comment">//添加一个无参构造</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">xxxException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">xxxException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习代码："><a href="#练习代码：" class="headerlink" title="练习代码："></a>练习代码：</h3><p>模拟用户注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; usernames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(usernames,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;输入要注册的用户名：&quot;</span>);</span><br><span class="line">        String username = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name = checkname(usernames, username);</span><br><span class="line">            usernames.add(name);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RegisterException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkname</span><span class="params">(ArrayList&lt;String&gt; usernames ,String name)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String username : usernames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(name))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day22</title>
    <url>/2021/10/16/StudyNotes_day22/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day3</title>
    <url>/2021/04/05/StudyNotes_day3/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>算数运算符、赋值运算符、比较运算符、逻辑运算符、三元运算符</p>
<h1 id="算数运算符-加号的多种用法"><a href="#算数运算符-加号的多种用法" class="headerlink" title="算数运算符_加号的多种用法"></a>算数运算符_加号的多种用法</h1><p>四则运算当中的加号“+”有常见的三种用法：</p>
<ol>
<li>对于数值来说，那就是加法</li>
<li>对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算<br>char类型字符，int类型数字，之间的对照关系表：ASCII、Unicode</li>
<li>对于字符串String（首字母大写，不是关键字）来说，加号代表字符串拼接（连接）操作<br> 任何数据类型和字符串进行连接时，结果都会变成字符串</li>
</ol>
<h1 id="算数运算符-自增自减运算符"><a href="#算数运算符-自增自减运算符" class="headerlink" title="算数运算符_自增自减运算符"></a>算数运算符_自增自减运算符</h1><p>自增运算符： ++<br>自减运算符： –</p>
<p>基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1使用格式：写在变量名称之前，或者写在变量名称之后，例如：++num，也可以num++<br>使用方法：<br>      1.单独使用：不和其他操作混合，自己独立成为一个步骤<br>      2.混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等<br>使用区别：<br>      1.在单独使用的时候，前++和后++没有任何区别，也就是 ++num 和 num++ 是完全一样的<br>     2.在混合使用的时候，有【重大区别】<br>          A、如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用      【先加后用】<br>        B、如果是【后++】，难么首先使用变量本来的数值，【然后再让变量+1】    【先用后加】<br>        总计：[先加减，后使用]，[先使用，后加减]</p>
<p>注意事项：<br>     只有变量才能使用自增、自减运算符，常量不可发生改变，所以不能用</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day4</title>
    <url>/2021/05/05/StudyNotes_day4/</url>
    <content><![CDATA[<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>与（并且）    &amp;&amp;    全都是true,才是true；否则就是false</p>
<p>或（或者）    ||    至少一个是true,就是true；全都是false，才是false</p>
<p>非（取反）    ！    本来是true,变成false；本来是false,变成true</p>
<p>与”&amp;&amp;”，或”||”，具有短路效果；如果根据左边已经判断得到最终结果，那么右边的代码将不再执行，从而节省一定性能。</p>
<p>注意事项：</p>
<p>1.逻辑运算符只能用于boolean值</p>
<p>2.与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可</p>
<p>3.与、或两种运算符，如果有多个条件，可以连续写</p>
<p>两个条件：条件A    &amp;&amp;    条件B</p>
<p>多个条件：条件A    &amp;&amp;    条件B    &amp;&amp;    条件C</p>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反！、自增++、自减–</p>
<p>二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=</p>
<p>三元运算符：需要三个数据才可以进行操作的运算符。</p>
<p>格式：</p>
<p>数据类型    变量名称    =    条件判断    ？    表达式A    ：    表达式B;</p>
<p>流程：</p>
<p>首先判断条件是否成立：</p>
<p>​        如果成立为true，那么将表达式A的值赋值给左侧的变量；</p>
<p>​        如果成立为false，那么将表达式B的值赋值给左侧的变量；</p>
<p>二者选其一。</p>
<p>注意事项：</p>
<p>1.必须同时保证表达式A和表达式B都符合左侧数据类型的要求</p>
<p>2.三元运算符的结果必须被使用</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day5</title>
    <url>/2021/05/31/StudyNotes_day5/</url>
    <content><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ol>
<li><p><strong>什么是流程控制</strong></p>
<p>流程控制是指“程序代码执行的顺序”，即这些代码哪行先执行，哪行后执行，某行执行完了之后再执行哪行</p>
</li>
<li><p><strong>流程控制的结构</strong></p>
<blockquote>
<p>顺序: 从上到下执行代码<br>选择: 有选择的执行代码<br>循环: 循环执行某一段代码</p>
</blockquote>
<p>由图灵提出，图灵认为世界上任何复杂的问题，总可以用上面三种流程控制进行编程实现.(这个可以证明的)</p>
</li>
</ol>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h5 id="判断语句：if语句"><a href="#判断语句：if语句" class="headerlink" title="判断语句：if语句"></a>判断语句：if语句</h5><ul>
<li>if语句第一种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句第二种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句第三种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">	执行语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择语句：switch语句"><a href="#选择语句：switch语句" class="headerlink" title="选择语句：switch语句"></a>选择语句：switch语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul>
<li>for</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①;布尔表达式②;步进表达式④)&#123;</span><br><span class="line">	循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">	循环体③</span><br><span class="line">	步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do-while</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	循环体③</span><br><span class="line">	步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②)</span><br></pre></td></tr></table></figure>
<p>break</p>
<p>continue</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day6</title>
    <url>/2021/09/08/StudyNotes_day6/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h2><p>定义方法的完整格式：</p>
<p>​    </p>
<p>修饰符     返回值类型      方法名称      (参数类型     参数名称）{<br>            方法体；<br>            return 返回值；<br>}</p>
<p>​    </p>
<p>修饰符：public    static</p>
<p>返回值类型：也就是方法最终产生的数据是什么类型</p>
<p>方法名称：方法的名字，规则和变量一样，小驼峰</p>
<p>参数类型：进入方法的数据是什么类型</p>
<p>参数名称：进入方法的数据对应的变量名称</p>
<p>ps:参数如果有多个，使用逗号进行分隔</p>
<p>方法体：方法需要做的事情，若干行代码</p>
<p>return:两个作用，第一停止当前方法，第二讲后面的返回值还给调用处</p>
<p>返回值：也就是方法执行后最终产生的数据结果</p>
<p>注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”保持对应。</p>
<p>​    </p>
<p>方法三要素：</p>
<p>返回值类型</p>
<p>方法名</p>
<p>参数列表</p>
<p>​    </p>
<p>方法调用的三种格式：</p>
<p>1.单独调用：方法名称(参数);</p>
<p>2.打印调用：System.out.println(方法名称（参数）);</p>
<p>3.赋值调用：数据类型    变量名称    =    方法名称(参数)；</p>
<p>​        </p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>方法重载（overload）:多个方法的名称一样，但是参数列表不一样</p>
<p>好处：只需要记住唯一一个方法名，就可以实现类似的多个功能</p>
<p>​    </p>
<p>方法重载与下列因素相关：</p>
<p>1.参数个数不同</p>
<p>2.参数类型不同</p>
<p>3.参数的多类型顺序不同</p>
<p>​    </p>
<p>方法重载与下列因素无关：</p>
<p>1.与参数的名称无关</p>
<p>2.与方法的返回值类型无关</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day7</title>
    <url>/2021/09/11/StudyNotes_day7/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的概念：是一种容器，可以同时存放多个数据值</p>
<p>​    </p>
<p>数组的特点：</p>
<p>1.数组是一种引用类型</p>
<p>2.数组当中的多个数据，类型必须统一</p>
<p>3.数组的长度在程序运行期间不可改变</p>
<p>​    </p>
<p>动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数</p>
<p>静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定</p>
<p>​    </p>
<h2 id="数组的定义格式-动态初始化"><a href="#数组的定义格式-动态初始化" class="headerlink" title="数组的定义格式_动态初始化"></a>数组的定义格式_动态初始化</h2><p>数据类型[]    数组名称    =    new    数据类型[数组长度];</p>
<p>​    </p>
<p>解析含义:</p>
<p>左侧数据类型：也就是数组当中存放的数据，全都是统一的什么类型</p>
<p>左侧的中括号：代表是一个数组</p>
<p>左侧数组名称：给数组取一个名字</p>
<p>右侧的new：代表创建数组的动作</p>
<p>右侧数据类型：必须和左边的数据类型保持一致</p>
<p>右侧中括号的长度：也就是数组中，到底可以保存多少个数据，是一个int数字</p>
<p>​    </p>
<h2 id="数组的定义格式-静态初始化"><a href="#数组的定义格式-静态初始化" class="headerlink" title="数组的定义格式_静态初始化"></a>数组的定义格式_静态初始化</h2><p>数据类型[]    数组名称    =    new    数据类型[]{ 元素1, 元素2, …};</p>
<p>​    </p>
<p>注意事项：</p>
<p>虽然静态初始化没有直接告诉长度，但是根据大括号里面的具体内容，也可以算出长度</p>
<p>​    </p>
<h2 id="数组的定义格式-省略的静态初始化"><a href="#数组的定义格式-省略的静态初始化" class="headerlink" title="数组的定义格式_省略的静态初始化"></a>数组的定义格式_省略的静态初始化</h2><p>数据类型[]    数组名称    =    { 元素1, 元素2, …};</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.动态初始化和静态初始化标准格式可以拆分成两个步骤</p>
<p>2.静态初始化一旦使用省略格式，就不能拆分成两个步骤</p>
<p>​    </p>
<h2 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h2><p>格式：数组名称[索引值]</p>
<p>索引值从0开始，一直到“数组长度-1”为止</p>
<h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>格式：数组名称.length</p>
<p>​    </p>
<h2 id="数组的遍历输出"><a href="#数组的遍历输出" class="headerlink" title="数组的遍历输出"></a>数组的遍历输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">	System.out.println(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array.fori</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="数组作为方法参数-传递地址"><a href="#数组作为方法参数-传递地址" class="headerlink" title="数组作为方法参数_传递地址"></a>数组作为方法参数_传递地址</h2><p>数组可以作为方法的参数</p>
<p>当调用方法时候，向方法的小括号进行传参，传递进去的其实是数组的地址值</p>
<p>​    </p>
<h2 id="数组作为方法返回值-返回地址"><a href="#数组作为方法返回值-返回地址" class="headerlink" title="数组作为方法返回值_返回地址"></a>数组作为方法返回值_返回地址</h2><p>任何数据类型都能作为方法的参数类型，或者返回值类型</p>
<p>数组作为方法的参数，传递进去的其实是数组的地址值</p>
<p>数组作为方法的返回值，返回的其实也是数组的地址值</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day8</title>
    <url>/2021/09/12/StudyNotes_day8/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象思想的概述"><a href="#面向对象思想的概述" class="headerlink" title="面向对象思想的概述"></a>面向对象思想的概述</h2><p>面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节</p>
<p>面向对象：但需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事</p>
<p>​    </p>
<p>面向过程：强调步骤</p>
<p>面向对象：强调对象</p>
<p>​    </p>
<p>特点：</p>
<p>面向对象思想是一种更符合我们思考习惯的思想，他可以将复杂的事情简单化，并将我们从执行者变成了指挥者</p>
<p>​    </p>
<p>面向对象三大基本特征：封装、继承、多态</p>
<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul>
<li><p>类：是一组相关属性和行为的集合，可以看成是一类事物的模板，使用事物的属性特征和行为来描述该类事物</p>
</li>
<li><p>属性：就是该事物的状态信息</p>
</li>
<li><p>行为：就是该事物能够做什么</p>
</li>
</ul>
<p>举例：小猫</p>
<p>​        属性：名字、体重、年龄、颜色</p>
<p>​        行为：走、跑、叫</p>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li>对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为</li>
</ul>
<p>现实中，一类事物的一个实例：一只小猫</p>
<p>举例：一只小猫</p>
<p>​        属性：tom、5kg、2years、yellow</p>
<p>​        行为：溜墙根走、蹦跶的跑、喵喵叫</p>
<h3 id="类和对象的关系-1"><a href="#类和对象的关系-1" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul>
<li><p>类是对一类事物的描述，是<strong>抽象的</strong></p>
</li>
<li><p>对象是一类事物的实例，是<strong>具体的</strong></p>
</li>
<li><p><strong>类是对象的模板，对象是类的实例</strong></p>
</li>
</ul>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h3><p>现实世界的一类事物：</p>
<p>​        <strong>属性</strong>：事物的状态信息</p>
<p>​        <strong>行为</strong>：事物能够做什么</p>
<p>java中class描述事物也是如此：</p>
<p>​        <strong>成员变量</strong>：对应事物的<strong>属性</strong></p>
<p>​        <strong>成员方法</strong>：对象事物的<strong>行为</strong></p>
<h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>1.成员变量是直接定义在类当中的，在方法外边</p>
<p>2.成员方法不要写static</p>
<h2 id="对象的创建及其使用"><a href="#对象的创建及其使用" class="headerlink" title="对象的创建及其使用"></a>对象的创建及其使用</h2><p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用</p>
<p>1.导包：也就是指出需要使用的类，在什么位置</p>
<p>import 包名称.类名称</p>
<p>import com.company.demo.Student;</p>
<p>对于和当前类属于同一个包的情况，可以省略导包语句</p>
<p>​    </p>
<p>2.创建，格式：</p>
<p>类名称    对象名称    =    new    类名称（）；</p>
<p>Student    stu    =    new    Student();</p>
<p>​    </p>
<p>3.使用，分为两种情况</p>
<p>使用成员变量：对象名.成员变量</p>
<p>使用成员方法：对象名.成员方法（参数）</p>
<p>（也就是，想用谁，就用对象名点儿谁。）</p>
<h2 id="使用对象类型作为方法的参数"><a href="#使用对象类型作为方法的参数" class="headerlink" title="使用对象类型作为方法的参数"></a>使用对象类型作为方法的参数</h2><p>当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象地址值</p>
<h2 id="使用对象类型作为方法的返回值"><a href="#使用对象类型作为方法的返回值" class="headerlink" title="使用对象类型作为方法的返回值"></a>使用对象类型作为方法的返回值</h2><p>当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值</p>
<h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>1.定义的位置不一样</p>
<p>局部变量：在方法的内部</p>
<p>成员变量：在方法的外边，直接写在类当中</p>
<p>​    </p>
<p>2.作用范围不一样</p>
<p>局部变量：只有方法当中才可以使用，出了方法就不能再用</p>
<p>成员变量：整个类都可以通用</p>
<p>​    </p>
<p>3.默认值不一样</p>
<p>局部变量：没有默认值，如果要想使用，必须手动进行赋值</p>
<p>成员变量：如果没有赋值，会有默认值，规则和数组一样</p>
<p>​    </p>
<p>4.内存的位置不一样</p>
<p>局部变量：位于栈内存</p>
<p>成员变量：位于堆内存</p>
<p>​    </p>
<p>5.生命周期不一样</p>
<p>局部变量：随着方法进栈而诞生，随着方法出栈而消失</p>
<p>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StudyNotes_day9</title>
    <url>/2021/09/12/StudyNotes_day9/</url>
    <content><![CDATA[<h1 id="面向对象三大特征之封装性"><a href="#面向对象三大特征之封装性" class="headerlink" title="面向对象三大特征之封装性"></a>面向对象三大特征之封装性</h1><p>面向对象三大特征：封装、继承、多态</p>
<p>​    </p>
<p>封装性在Java当中的体现：</p>
<p>1.方法就是一种封装</p>
<p>2.关键字private也是一种封装</p>
<p>​    </p>
<p>封装就是将一些细节信息隐藏起来，对于外界不可见</p>
<h2 id="private关键字的作用及使用"><a href="#private关键字的作用及使用" class="headerlink" title="private关键字的作用及使用"></a>private关键字的作用及使用</h2><p>一旦使用了private进行修饰，那么本类当中仍然可以随意访问</p>
<p>但是超出了本类范围之外就不能直接访问</p>
<p>private关键字提高代码的安全性</p>
<p>​    </p>
<p>间接访问private成员变量，就是定义一对Getter/Setter方法</p>
<p>必须叫setXxx或getXxx命名规则</p>
<p>对于Getter，不能有参数，返回值类型和成员变量对应</p>
<p>对于Setter，不能有返回值，参数类型和成员变量对应</p>
<h2 id="this关键字的作用"><a href="#this关键字的作用" class="headerlink" title="this关键字的作用"></a>this关键字的作用</h2><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量</p>
<p>如果需要访问本类当中的成员变量，需要使用格式：</p>
<p>this.成员变量名</p>
<p>​    </p>
<p>“通过谁调用的方法，谁就是this”</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是专门用来创建对象的方法，当通过关键字new来创建对象时，其实就是在调用构造方法</p>
<p>格式：</p>
<p>public 类名称（参数类型    参数名称）{</p>
<p>​    方法体</p>
<p>}</p>
<h2 id="定义一个标准的类"><a href="#定义一个标准的类" class="headerlink" title="定义一个标准的类"></a>定义一个标准的类</h2><p>一个标准的类通常要拥有下面四个组成部分：</p>
<p>​    </p>
<p>1.所有的成员变量都要使用private关键字来修饰</p>
<p>2.为每一个成员变量编写一对儿Getter/Setter方法</p>
<p>3.编写一个无参数的构造方法</p>
<p>4.编写一个全参数的构造方法</p>
<p>​    </p>
<p>这样标准的类也叫做Java Bean</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Windows容易忘记但好用的快捷键</title>
    <url>/2021/02/14/Windows%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Windows容易忘记但好用的快捷键"><a href="#Windows容易忘记但好用的快捷键" class="headerlink" title="Windows容易忘记但好用的快捷键"></a>Windows容易忘记但好用的快捷键</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win+Shift+S				Windows自带截图</span><br><span class="line">Win+PrintScreen				截取当前屏幕到剪贴板，并保存截屏图片文件到“图片”文件夹中</span><br><span class="line">Win+D					显示桌面</span><br><span class="line">Win+E					打开文件管理器</span><br><span class="line">Win+I					打开Windows10设置</span><br><span class="line">Win+S					搜索</span><br><span class="line">Win+T					快速切换任务栏程序</span><br><span class="line">Win+Ctrl+D				创建一个新的虚拟桌面</span><br><span class="line">Win+Ctrl+左&#x2F;右	   	   		切换虚拟桌面</span><br><span class="line">Win+Ctrl+F4			  	关闭虚拟桌面</span><br><span class="line">Ctrl+Shift+Esc				开任务管理</span><br><span class="line">Ctrl+Shift+N				新建文件夹</span><br><span class="line">shift+del				彻底删除</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一篇博文</title>
    <url>/2021/02/11/%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h2 id="建站（折腾）历程"><a href="#建站（折腾）历程" class="headerlink" title="建站（折腾）历程"></a>建站（折腾）历程</h2><p>​        建这个博客的起因是想记录和总结学到的知识点，其实自己并没有记录和总结的习惯，一个教训就是之前学习java没有及时总结到后期忘记前面的知识点复习起来很痛苦，这次我在边复习java和学习新的知识时边在自己的博客上做些总结。</p>
<p>​         这个博客是用hexo博客框架搭建的，并部署到了自己的Github上，第一个使用的主题是diaspora，很好看的一个主题，修改后搭建了一个自己的ACG主题博客。博客的搭建和部署过程还是比较的顺利，但主题是真的折腾了好久，还是有部分配置不会弄。下一篇博客会总结下hexo+github方式搭建博客。</p>
<p>​        </p>
<p>​        </p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>java</tag>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的Dos命令</title>
    <url>/2021/02/13/%E5%9F%BA%E6%9C%AC%E7%9A%84Dos%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h1><h2 id="盘符切换"><a href="#盘符切换" class="headerlink" title="盘符切换"></a>盘符切换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d:			#格式 &quot;需要切换的盘符：&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir 			#查看当前目录下的所有文件</span><br></pre></td></tr></table></figure>
<h2 id="切换目录-change-directory"><a href="#切换目录-change-directory" class="headerlink" title="切换目录(change directory)"></a>切换目录(change directory)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">cd &#x2F;d f:		#切换到f盘 &#x2F;d 是参数		   </span><br><span class="line">cd..			#返回上一级</span><br><span class="line">cd\ 			#返回根目录</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md		创建目录   ( mkdir )</span><br><span class="line">rd		删除空目录  ( rmdir )</span><br><span class="line">	</span><br><span class="line">rd&#x2F;s&#x2F;q 盘符:\某个文件夹  （强制删除文件文件夹和文件夹内所有文件）</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd&gt;		创建文件 （ cd&gt;a.txt ）	</span><br><span class="line">del		删除文件 （ del a.txt ）	</span><br><span class="line">	</span><br><span class="line">del&#x2F;f&#x2F;s&#x2F;q 盘符:\文件名  （强制删除文件，文件名必须加文件后缀名）</span><br></pre></td></tr></table></figure>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy 源文件 新文件位置</span><br><span class="line"></span><br><span class="line">	将当前目录下的 1.txt 文件复制到 bak 目录下，</span><br><span class="line">	就输入 copy 1.txt bak\</span><br><span class="line">	</span><br><span class="line">	将当前目录下的 1.txt 这个文件复制到 bak 目录下，</span><br><span class="line">	并且更名为 a.txt，就输入 copy 1.txt bak\a.txt</span><br></pre></td></tr></table></figure>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move D:\a.txt F:\</span><br></pre></td></tr></table></figure>
<h2 id="清屏（clear-screen-）"><a href="#清屏（clear-screen-）" class="headerlink" title="清屏（clear screen ）"></a>清屏（clear screen ）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure>
<h2 id="退出终端"><a href="#退出终端" class="headerlink" title="退出终端"></a>退出终端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="查看电脑的ip"><a href="#查看电脑的ip" class="headerlink" title="查看电脑的ip"></a>查看电脑的ip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<h2 id="打开应用"><a href="#打开应用" class="headerlink" title="打开应用"></a>打开应用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc			计算器</span><br><span class="line">mspaint			画板</span><br><span class="line">notepad			记事本</span><br><span class="line">control			控制面板</span><br></pre></td></tr></table></figure>
<h2 id="shutdown-命令"><a href="#shutdown-命令" class="headerlink" title="shutdown 命令"></a>shutdown 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown -s -t 0		#-s参数：关机	-t参数：执行时间</span><br><span class="line">shutdown -r -t 0		#重启</span><br><span class="line">shutdown -l				#注销</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Dos</category>
      </categories>
  </entry>
</search>
