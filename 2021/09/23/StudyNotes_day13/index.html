
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>StudyNotes_day13（继承、抽象类） - MyBlog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="继承继承的概述面向对象的三大特征：封装性、继承性、多态性
继承是多态的前提，如果没有继承，就没有多态
继承主要解决的问题就是：共性抽取
父类，也可以叫基类、超类
子类，也可以叫派生类
​    
继,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="MyBlog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">MyBlog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://yotsugi0.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">StudyNotes_day13（继承、抽象类）</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">StudyNotes_day13（继承、抽象类）</h1>
        <div class="stuff">
            <span>九月 23, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的概述"><a href="#继承的概述" class="headerlink" title="继承的概述"></a>继承的概述</h2><p>面向对象的三大特征：封装性、继承性、多态性</p>
<p>继承是多态的前提，如果没有继承，就没有多态</p>
<p>继承主要解决的问题就是：共性抽取</p>
<p>父类，也可以叫基类、超类</p>
<p>子类，也可以叫派生类</p>
<p>​    </p>
<p>继承关系当中的特点：</p>
<p>1.子类可以拥有父类的“内容”</p>
<p>2.子类还可以拥有自己专有的内容</p>
<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><p>在继承的关系中，“子类就是一个父类”，也就是说，子类可以被当做父类看待</p>
<p>例如：父类是员工Employee，子类是讲师Teacher，那么“讲师就是一个员工”，关系：is - a</p>
<p>​    </p>
<p>定义父类的格式：（一个普通的类定义）</p>
<p>public class 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<p>定义子类的格式</p>
<p>public class 子类名称 extends 父类名称 {</p>
<p>​    …</p>
<p>}</p>
<h2 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h2><p>在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</p>
<p>​    </p>
<p>直接通过子类对象访问成员变量：</p>
<p>​        等号左边是谁，就优先用谁，没有则向上找</p>
<p>间接通过成员方法访问成员变量：</p>
<p>​        该方法属于谁，就优先用谁，没有则向上找</p>
<h2 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h2><p>局部变量：                直接写</p>
<p>本来的成员变量：    this.成员变量</p>
<p>父类的成员变量：    super.成员变量</p>
<h2 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h2><p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</p>
<p>​        创建的对象是谁，就优先用谁，如果没有则向上找</p>
<p>注意思想：</p>
<p>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类</p>
<h2 id="继承中方法的覆盖重写"><a href="#继承中方法的覆盖重写" class="headerlink" title="继承中方法的覆盖重写"></a>继承中方法的覆盖重写</h2><p>重写（Override）</p>
<p>概念：在继承关系当中，方法的名称一样，参数列表也一样</p>
<p>​    </p>
<p>重写（Override）:方法的名称一样，参数列表【也一样】，覆盖、覆写</p>
<p>重载（Overload）:方法的名称一样，参数列表【不一样】</p>
<p>​     </p>
<p>方法的覆盖重写的特点：创建的是子类对象，则优先用子类方法</p>
<p>​    </p>
<p>注意事项：</p>
<p>1.必须保证父子类之间方法的名称相同，参数列表也相同</p>
<p>@Override，写在方法上面，用来检测是不是有效的覆盖重写</p>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
<p>java.lang.Objet类是所有类的公共最高父类，java.lang.String就是Object的子类</p>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>public &gt; protected &gt; (default) &gt;private</p>
<p>备注：（default）不是关键字，而是什么都不写，留空</p>
<p>​    </p>
<p>应用场景：</p>
<p>设计原则：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新类继承，来重复利用其中的共性内容，并添加改动新内容</p>
<h2 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h2><p>1.子类构造方法当中有一个默认隐含的“super( )”调用，所以一定是先调用的父类构造，后执行子类的构造</p>
<p>2.子类构造可以通过super关键字来调用父类重载构造</p>
<p>3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p>
<p>只要子类的构造方法才能调用父类的构造方法</p>
<p>总结：</p>
<p>子类必须调用父类构造方法，不写则赠送super( )；写了则用写的指定的super调用，super只能有一个，还必须是第一个</p>
<h2 id="super关键字的三种用法"><a href="#super关键字的三种用法" class="headerlink" title="super关键字的三种用法"></a>super关键字的三种用法</h2><p>1.在子类的成员方法中，访问父类的成员变量    super.</p>
<p>2.在子类的成员方法中，访问父类的成员方法    super.</p>
<p>3.在子类的构造方法中，访问父类的构造方法    super()</p>
<h2 id="this关键字的三种用法"><a href="#this关键字的三种用法" class="headerlink" title="this关键字的三种用法"></a>this关键字的三种用法</h2><p>1.在本来的成员方法中，访问本类的成员变量                this.</p>
<p>2.在本来的成员方法中，访问本类的另一个成员方法    this.</p>
<p>3.在本来的构造方法中，访问本类的另一个构造方法    this()</p>
<p>在第三种用法中注意：</p>
<p>A.this(…)调用也必须是构造方法的第一个语句，唯一一个</p>
<p>B.super和this两种构造调用，不能同时使用</p>
<h2 id="java继承的三个特点"><a href="#java继承的三个特点" class="headerlink" title="java继承的三个特点"></a>java继承的三个特点</h2><p>1.Java语言是单继承的</p>
<p>一个类的直接父类只能有唯一一个</p>
<p>2.Java语言可以多级继承</p>
<p>3.一个子类的直接父类是唯一的，但是一个父类可以有多个子类</p>
<h1 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h1><h2 id="抽象方法和抽象类的格式"><a href="#抽象方法和抽象类的格式" class="headerlink" title="抽象方法和抽象类的格式"></a>抽象方法和抽象类的格式</h2><p>抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束</p>
<p>抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstaract即可</p>
<p>如：</p>
<p>public abstract calss Demo {</p>
<p>​    public abstract void method( );</p>
<p>}</p>
<h2 id="抽象方法和抽象类的使用"><a href="#抽象方法和抽象类的使用" class="headerlink" title="抽象方法和抽象类的使用"></a>抽象方法和抽象类的使用</h2><p>1.不能直接创建new抽象类对象</p>
<p>2.必须用一个子类继承抽象父类</p>
<p>3.子类必须覆盖重写抽象父类中所有的抽象方法</p>
<p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p>
<p>4.创建子类对象进行使用</p>
<h2 id="抽象方法和抽象类的注意事项"><a href="#抽象方法和抽象类的注意事项" class="headerlink" title="抽象方法和抽象类的注意事项"></a>抽象方法和抽象类的注意事项</h2><p>1.抽象类不能创建对象</p>
<p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super(); 需要访问父类构造方法</p>
</blockquote>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必须是抽象类</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的是不想让调用者创建该类对象，通常用于某些特殊的类结构设计</p>
</blockquote>
<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/454494.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">继承的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">继承中成员变量的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E9%87%8D%E5%90%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">区分子类方法中重名的三种变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">继承中成员方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99"><span class="toc-number">1.6.</span> <span class="toc-text">继承中方法的覆盖重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.</span> <span class="toc-text">继承中构造方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">super关键字的三种用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">this关键字的三种用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-number">1.10.</span> <span class="toc-text">java继承的三个特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">抽象方法和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">抽象方法和抽象类的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">抽象方法和抽象类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text">抽象方法和抽象类的注意事项</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
