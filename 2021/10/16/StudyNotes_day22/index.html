
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>StudyNotes_day22（线程） - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="线程基本概念并发与并行并发：指两个或多个事件在同一时间段内发生（在多个事件快速来回切换执行）
并行：指两个或多个事件在同一时刻发生（同时发生）
并行的运行速度更快，但并发效率更高
所以并发编程的目标,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">StudyNotes_day22（线程）</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">StudyNotes_day22（线程）</h1>
        <div class="stuff">
            <span>十月 16, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间段内发生（在多个事件快速来回切换执行）</p>
<p>并行：指两个或多个事件在同一时刻发生（同时发生）</p>
<p>并行的运行速度更快，但并发效率更高</p>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程：是指内存中一个在运行的应用程序。</p>
<p>线程：是进程中的一个执行单元。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<p>一些程序进程运行后，会调用其他进程，这样就组成了一个进程树</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>分时调度：所有线程轮流获得CPU，平均分配每个线程占用CPU的时间</p>
<p>抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的就是抢占式调度</p>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>main线程（主线程）：执行main（主）方法的线程</p>
<p>JVM执行main方法，main方法会进入到栈内存</p>
<p>JVM会找操作系统开辟一条main方法通向cpu的执行路径</p>
<p>cpu就可以通过这条路径来执行main方法</p>
<p>而这个路径就叫main（主）线程</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="创建多线程程序的第一种方式-创建Thread类的子类"><a href="#创建多线程程序的第一种方式-创建Thread类的子类" class="headerlink" title="创建多线程程序的第一种方式_创建Thread类的子类"></a>创建多线程程序的第一种方式_创建Thread类的子类</h2><p>步骤：</p>
<p>1.创建一个Thread类的子类</p>
<p>2.在Thread类的子类中重写Thread类中的run方法，设置线程任务</p>
<p>3.创建Thread类的子类对象</p>
<p>4.调用Thread类中的start()方法，开启新的线程，执行run方法</p>
<p>备注：    </p>
<p>void start( ) 使该线程开始执行；Java虚拟机调用该线程的run方法</p>
<p>结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>java.lang.Thread</p>
<p>extends Object</p>
<p>implements Runnable</p>
<p><strong>构造方法</strong>：</p>
<ul>
<li>public Thread( )：分配一个新的线程对象</li>
<li>public Thread( String name )：分配一个指定名字的新的线程对象</li>
<li>public Thread( Runnable target )：通过传递Runnable接口实现类对象来创建一个新线程</li>
<li>public Thread( Runnable target, String name )：通过传递Runnable接口实现类对象来创建一个指定名字的新线程</li>
</ul>
<p><strong>常用方法</strong>：</p>
<ul>
<li><p>public String getName( )：获取当前线程名称</p>
</li>
<li><p>public void start( )：导致此线程开始执行，Java虚拟机调用此线程的run方法</p>
</li>
<li><p>public void run( )：此线程要执行的任务在此处定义代码</p>
</li>
<li><p>pubic static void sleep( long millis )：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）</p>
</li>
<li><p>public static Thread currentThread( )：返回当前正在执行的线程对象的引用</p>
</li>
</ul>
<h3 id="Thread类的常用方法-获取线程的名称"><a href="#Thread类的常用方法-获取线程的名称" class="headerlink" title="Thread类的常用方法_获取线程的名称"></a>Thread类的常用方法_获取线程的名称</h3><p>使用Thread类中的getName（）方法 </p>
<p>或者 </p>
<p>先同过Thread类中的currentThread（）方法获取当前执行的线程，再使用线程中的getName（）方法</p>
<p>一步到位，链式编程方式：</p>
<p>Thread.currentThread( ).getName( )</p>
<h3 id="Thread类的常用方法-设置线程的名称"><a href="#Thread类的常用方法-设置线程的名称" class="headerlink" title="Thread类的常用方法_设置线程的名称"></a>Thread类的常用方法_设置线程的名称</h3><p>使用Thread类中的setName( 名字 )</p>
<p>void setName( String name )</p>
<p>或</p>
<p>使用Thread类的带参构造public Thread( String name )在创建线程的时候就设置线程名称</p>
<h3 id="Thread类的常用方法-sleep"><a href="#Thread类的常用方法-sleep" class="headerlink" title="Thread类的常用方法_sleep"></a>Thread类的常用方法_sleep</h3><p>Thread.sleep( long Millis );</p>
<h2 id="创建线程的第二种方式-实现Runnable接口"><a href="#创建线程的第二种方式-实现Runnable接口" class="headerlink" title="创建线程的第二种方式_实现Runnable接口"></a>创建线程的第二种方式_实现Runnable接口</h2><p>java.lang.Runnable</p>
<p>步骤：</p>
<p>1.创建一个Runable接口的实现类</p>
<p>2.在实现类中重写run方法，设置线程任务</p>
<p>3.创建一个Runnable接口的实现类对象</p>
<p>4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象</p>
<p>5.调用Thread类中的start方法，开启新的线程执行run方法</p>
<h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>即实现Runnable接口创建多线程的程序的好处：<br>1.避免了单继承的局限性</p>
<p>一个类只能继承一个类，类继承了Thread类就不能继承其他的类</p>
<p><strong>实现Runnable接口，还可以继承其他的类，实现其他的接口</strong></p>
<p>2.增强了程序的扩展性，降低了程序的耦合性（解耦）</p>
<p>实现Runnable接口的方式，把设置线程任务和开启线程进行了分离（解耦）</p>
<p>实现类中，重写了run方法：设置线程任务</p>
<p>创建Thread类对象，传递Runnable接口实现类对象，调用start方法：开启线程</p>
<p><strong>传递不同的实现类，实现不同任务</strong></p>
<h2 id="匿名内部类方式实现线程的创建"><a href="#匿名内部类方式实现线程的创建" class="headerlink" title="匿名内部类方式实现线程的创建"></a>匿名内部类方式实现线程的创建</h2><p>格式：</p>
<p>new 父类/接口（）{</p>
<p>​    重写父类/接口中的方法</p>
<p>}；</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程访问共享的资源可能会出现线程安全问题</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多</p>
<p>主要三种方式完成同步操作：</p>
<p>1.同步代码块</p>
<p>2.同步方法</p>
<p>3.锁机制</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>synchronized（ 同步锁 ）{</p>
<p>​    可能会出现线程安全问题的代码（访问了共享数据的代码）</p>
<p>}</p>
<p>同步锁（监视器对象）：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁</p>
<p>1.锁对象，可以是任意类型，锁对象要创建在run方法外面使得锁唯一</p>
<p>2.多个线程对象，需要使用同一把锁</p>
<blockquote>
<p>注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外面等着（BLOCKED）</p>
</blockquote>
<p>锁对象作用：</p>
<p>把同步代码锁住，只让一个线程在同步代码块中执行</p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>使用synchronized关键字修饰的方法，就叫做同步方法</p>
<p>保证A线程执行该方法的时候，其他线程只能在方法外面等着</p>
<p>格式：</p>
<p>public synchroized 返回值类型 方法名称（参数列表）{</p>
<p>​    可能会出现线程安全问题的代码（访问了共享数据的代码）</p>
<p>}</p>
<blockquote>
<p>同步锁是谁？</p>
<p>​    对于非static方法，同步锁就是this，即实现类对象，new RunnableImpl（）</p>
<p>​    对于static方法，是使用的当前方法所在类的字节码对象（类名.class）（class文件对象——&gt;反射）</p>
</blockquote>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>java.util.concurrent.locks.Lock接口</p>
<p>Lock接口中的方法：</p>
<p>​    void lock（）：获取锁</p>
<p>​    void unlock（）：释放锁</p>
<p>java.util.concurrent.locks.ReentrantLock    implements     Lock</p>
<p>使用步骤：</p>
<p>​    1.在成员位置创建一个ReentrantLack对象</p>
<p>​    2.可能会出现线程安全问题的代码前调用Lock接口中的方法lock（）获取锁</p>
<p>​    3.可能会出现线程安全问题的代码后调用Lock接口中的方法unlock（）释放锁</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><ul>
<li>NEW：新建状态</li>
<li>RUNNABLE：运行状态</li>
<li>TERMINATED：死亡状态</li>
<li>BLOCKED：阻塞状态</li>
<li>TIMED_WAITING：休眠（睡眠）状态，计时等待</li>
<li>WAITING：无限（永久）等待</li>
</ul>
<h2 id="Timed-Waiting（-计时等待-）"><a href="#Timed-Waiting（-计时等待-）" class="headerlink" title="Timed Waiting（ 计时等待 ）"></a>Timed Waiting（ 计时等待 ）</h2><p>调用sleep带参（时间）成为计时等待状态，</p>
<p>参数时间到达且获取到了锁将又成为运行状态</p>
<h2 id="BLOCKED（-锁阻塞-）"><a href="#BLOCKED（-锁阻塞-）" class="headerlink" title="BLOCKED（ 锁阻塞 ）"></a>BLOCKED（ 锁阻塞 ）</h2><p>没有争取到锁对象成为阻塞状态，</p>
<p>获取到了锁对象又成为可运行状态</p>
<h2 id="Waiting（-无限等待-）"><a href="#Waiting（-无限等待-）" class="headerlink" title="Waiting（ 无限等待 ）"></a>Waiting（ 无限等待 ）</h2><p>调用Object类中的wait方法进入无限等待状态，</p>
<p>直到调用了Object类中的notify方法且获取到了锁成为运行状态</p>
<h3 id="Object类中的wait方法和notify方法"><a href="#Object类中的wait方法和notify方法" class="headerlink" title="Object类中的wait方法和notify方法"></a>Object类中的wait方法和notify方法</h3><ul>
<li><p>wait（）：进入无限等待状态</p>
</li>
<li><p>wait（时间毫秒值）：带参的wait方法等效于Thread类中的sleep方法，到时间后自己醒来</p>
</li>
<li><p>notify：唤醒一个无限等待的线程（等待时间最久的优先唤醒）</p>
</li>
<li><p>notifyAll：唤醒所有的无限等待线程</p>
</li>
</ul>
<p><strong>wait方法和notify方法必须由同一个锁对象调用，且必须要写在同步代码块或同步方法中</strong></p>
<h2 id="线程间通信（等待唤醒机制）"><a href="#线程间通信（等待唤醒机制）" class="headerlink" title="线程间通信（等待唤醒机制）"></a>线程间通信（等待唤醒机制）</h2><p><strong>一、为什么要线程通信？</strong></p>
<p>1.多个线程并发执行时, 在默认情况下CPU是<strong>随机切换线程</strong>的，当我们需要多个线程来<strong>共同完成</strong>一件任务，</p>
<p>　　 并且我们希望他们<strong>有规律</strong>的执行, 那么多线程之间需要一些<strong>协调通信</strong>，以此来帮我们达到<strong>多线程共同操作一份数据</strong>。</p>
<p>2.当然如果我们没有使用线程通信来使用多线程共同操作同一份数据的话，虽然可以实现，</p>
<p>　　但是在很大程度会造成多线程之间对同一共享变量的争夺，那样的话势必为造成很多错误和损失！</p>
<p>3.所以，我们才引出了线程之间的通信，<code>多线程之间的通信能够避免对同一共享变量的争夺。</code></p>
<p><strong>二、什么是线程通信？</strong></p>
<p>　　多个线程在处理<strong>同一个资源</strong>，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的<strong>使用或操作</strong>。</p>
<p>　   就是<strong>多个线程在操作同一份数据时， 避免对同一共享变量的争夺</strong>。</p>
<p>　　于是我们引出了<strong>等待唤醒机制</strong>：（<strong>wait()**、</strong>notify()**）</p>
<p>　　就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify</strong>）</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h2><p>线程池：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源</p>
<p>线程池中有很多操作是与优化资源相关的</p>
<p>​    </p>
<p>线程池是Jdk 1.5之后提供的</p>
<p>​    </p>
<p>java里面线程池的顶级接口是java.util.concurrent.Executor,</p>
<p>但是严格意义上讲Executor并不是一个线程池，</p>
<p>而只是一个执行线程的工具，</p>
<p>真正的线程池接口是java.util.concurrent.ExecutorService</p>
<p>​    </p>
<p>要配置一个线程池是比较复杂的，尤其是对线程池的原理不是很清楚的情况下，很有可能配置的线程不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>java.util.concurrent.Exectors：线程池工厂类，用来生成线程池</p>
<p>Executors类中静态方法：</p>
<ul>
<li>static ExecutorService newFixedThreadPool（ int nThreads ）：创建一个可重复用固定线程数的线程池</li>
</ul>
<p>​    参数：</p>
<p>​            int nThreads：指定创建的线程池中的线程数量</p>
<p>​    返回值：</p>
<p>​            ExecutroService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）</p>
<p>​    </p>
<p>java.util.concurrent.ExecutorService：线程池接口，用来从线程池中获取线程，调用start方法，执行任务</p>
<p>ExecutorService接口中的方法：</p>
<ul>
<li>submit（ Runnable task ）：提交一个Runnable任务用于执行</li>
</ul>
<p>​    </p>
<p>线程池的使用步骤：</p>
<ol>
<li>使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
</ol>
<h1 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h1><h2 id="实现Runnable接口方式创建多线程程序的好处"><a href="#实现Runnable接口方式创建多线程程序的好处" class="headerlink" title="实现Runnable接口方式创建多线程程序的好处"></a>实现Runnable接口方式创建多线程程序的好处</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondRunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;名字为：&quot;</span> + Thread.currentThread().getName() </span><br><span class="line">                                   + <span class="string">&quot;的线程算出了100以内的整数和为：&quot;</span> +sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        SecondRunnableImpl secondRunnable = <span class="keyword">new</span> SecondRunnableImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现Runnable接口方式创建线程的好处：传递不同的实现类实现不同的功能</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(secondRunnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类加匿名对象方式创建线程"><a href="#匿名内部类加匿名对象方式创建线程" class="headerlink" title="匿名内部类加匿名对象方式创建线程"></a>匿名内部类加匿名对象方式创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例"><a href="#线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例" class="headerlink" title="线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例"></a>线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi baoZi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    baoZi.pi=<span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    baoZi.xian=<span class="string">&quot;牛肉粉丝&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    baoZi.pi=<span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    baoZi.xian=<span class="string">&quot;水果草莓&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺正在生产：&quot;</span> + baoZi.pi+baoZi.xian+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺生产包子需要5秒&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子生产好了!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                baoZi.flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                baoZi.notify();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi baoZi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃：&quot;</span> + baoZi.pi + baoZi.xian +<span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;3秒吃完了&quot;</span>);</span><br><span class="line"></span><br><span class="line">                baoZi.flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                baoZi.notify();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaoZi baoZi = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(baoZi).start();</span><br><span class="line">        <span class="keyword">new</span> ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/454494.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">主线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%88%9B%E5%BB%BAThread%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">创建多线程程序的第一种方式_创建Thread类的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">Thread类的常用方法_获取线程的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">Thread类的常用方法_设置线程的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-sleep"><span class="toc-number">2.2.3.</span> <span class="toc-text">Thread类的常用方法_sleep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">创建线程的第二种方式_实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">Thread和Runnable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.5.</span> <span class="toc-text">匿名内部类方式实现线程的创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1"><span class="toc-number">3.1.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.2.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">Lock锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">线程状态概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timed-Waiting%EF%BC%88-%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85-%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Timed Waiting（ 计时等待 ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BLOCKED%EF%BC%88-%E9%94%81%E9%98%BB%E5%A1%9E-%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">BLOCKED（ 锁阻塞 ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Waiting%EF%BC%88-%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85-%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">Waiting（ 无限等待 ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E4%B8%AD%E7%9A%84wait%E6%96%B9%E6%B3%95%E5%92%8Cnotify%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">Object类中的wait方法和notify方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">线程间通信（等待唤醒机制）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">线程池的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">线程池的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">练习代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.1.</span> <span class="toc-text">实现Runnable接口方式创建多线程程序的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">匿名内部类加匿名对象方式创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%EF%BC%89%E2%80%94%E2%80%94%E5%8C%85%E5%AD%90%E9%93%BA%E7%94%9F%E4%BA%A7%E5%8C%85%E5%AD%90%E3%80%81%E5%90%83%E8%B4%A7%E5%90%83%E5%8C%85%E5%AD%90%E6%A1%88%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">线程通信（等待唤醒机制）——包子铺生产包子、吃货吃包子案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">线程池使用</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
